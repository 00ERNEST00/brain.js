{"version":3,"sources":["../../src/layer/fully-connected.js"],"names":["predict","learnInputs","learnFilters","learnBiases","FullyConnected","settings","inputLayer","depth","Error","width","height","learnInputsKernel","learnFiltersKernel","learnBiasKernel","predictKernel","output","constants","inputDepth","inputHeight","inputWidth","learnBiasesKernel","learnKernel","filters","deltas","outputs","biases","weights","filterDeltas","bias","inputs","y","x","thread","filterDelta"],"mappings":"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","file":"fully-connected.js","sourcesContent":["import Base from './base';\nimport makeKernel from '../utilities/make-kernel';\n\nexport default class FullyConnected extends Base {\n  constructor(settings, inputLayer) {\n    super(settings);\n\n    if (this.inputLayer.depth !== 1) {\n      //TODO: make go away and handle 3d, should be fairly easy\n      throw new Error('depth of 1 only supported at this time');\n    }\n\n    this.width = inputLayer.width * inputLayer.height * inputLayer.depth;\n    this.inputLayer = inputLayer;\n    this.learnInputsKernel = null;\n    this.learnFiltersKernel = null;\n    this.learnBiasKernel = null;\n  }\n\n  setupKernels() {\n    this.predictKernel = makeKernel(predict, {\n      output: [this.width],\n      constants: {\n        inputDepth: this.inputLayer.depth,\n        inputHeight: this.inputLayer.height,\n        inputWidth: this.inputLayer.width\n      }\n    });\n\n    this.learnInputsKernel = makeKernel(learnInputs, {\n      output: [this.width],\n      constants: {\n        inputDepth: this.inputLayer.depth,\n        inputHeight: this.inputLayer.height,\n        inputWidth: this.inputLayer.width\n      }\n    });\n\n    this.learnFiltersKernel = makeKernel(learnFilters, {\n      output: [this.width],\n      constants: {\n        inputDepth: this.inputLayer.depth,\n        inputHeight: this.inputLayer.height,\n        inputWidth: this.inputLayer.width\n      }\n    });\n\n    this.learnBiasesKernel = makeKernel(learnBiases, {\n      output: [this.width],\n      constants: {\n        inputDepth: this.inputLayer.depth,\n        inputHeight: this.inputLayer.height,\n        inputWidth: this.inputLayer.width\n      }\n    });\n\n    this.learnKernel = () => {\n      this.learnInputsKernel(this.filters, this.deltas);\n      this.learnFiltersKernel(this.inputLayer.outputs, this.deltas);\n      this.learnBiasKernel(this.biases, this.deltas);\n    };\n  }\n\n  predict() {\n    this.weights = this.predictKernel(this.inputLayer.weights, this.filters, this.biases);\n  }\n\n  learn() {\n    this.filterDeltas = this.learnFilters(this.inputLayer, this.deltas);\n    this.biases = this.learnBiasesKernel(this.bias, this.deltas);\n    this.deltas = this.learnInputs(this.filters);\n  }\n}\n\nexport function predict(inputs, filters, biases) {\n  let output = 0;\n  for (let y = 0; y < this.constants.inputHeight; y++) {\n    for (let x = 0; x < this.constants.inputWidth; x++) {\n      output += inputs[y][x] * filters[y][x];\n    }\n  }\n  return output + biases[this.thread.x];\n}\n\nexport function learnInputs(filters, weights) {\n  let filterDelta = 0;\n  for (let y = 0; y < this.constants.inputWidth; y++) {\n    filterDelta += filters[this.thread.x][y] * weights[this.thread.x];\n  }\n  return filterDelta;\n}\n\nexport function learnFilters(inputs, weights) {\n  //0 here should probably be depth\n  return inputs[0][this.thread.y] * weights[this.thread.x];\n}\n\nexport function learnBiases(biases, deltas) {\n  return biases[this.output.x] * deltas[this.output.x];\n}"]}