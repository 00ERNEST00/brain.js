{"version":3,"sources":["../../src/layer/multiply-sigmoid.js"],"names":["Sigmoid","predictKernel","predict","output","width","height","depth","functions","compareKernel","compare","map","errors","calcError","deltas","calcDeltas","learnKernel","learn","weights","calcWeights","changes","calcChanges","inputs","x","outputs","biases","nextLayer","previousLayer","learningRate","momentum","sum","k","y","nextLayerWeights","nextLayerDeltas","thread","nextWeights","nextDeltas","error","previousLayerOutputs","previousLayerChanges","delta","change","previousChanges","previousOutputs","i"],"mappings":"AAAA;;;;;;;;AAEA;;;;AACA;;AACA;;AACA;;;;;;;;;;;;IAEqBA,O;;;;;;;;;;;mCACJ;AACb,WAAKC,aAAL,GAAqB,0BAAWC,OAAX,EAAoB;AACvCC,gBAAQ,CAAC,KAAKC,KAAN,EAAa,KAAKC,MAAlB,EAA0B,KAAKC,KAA/B,CAD+B;AAEvCC,mBAAW;AAF4B,OAApB,CAArB;;AAKA,WAAKC,aAAL,GAAqB,0BAAWC,OAAX,EAAoB;AACvCN,gBAAQ,CAAC,KAAKC,KAAN,EAAa,KAAKC,MAAlB,EAA0B,KAAKC,KAA/B,CAD+B;AAEvCI,aAAK;AACHC,kBAAQC,SADL;AAEHC,kBAAQC;AAFL;AAFkC,OAApB,CAArB;;AAQA,WAAKC,WAAL,GAAmB,0BAAWC,KAAX,EAAkB;AACnCb,gBAAQ,CAAC,KAAKC,KAAN,EAAa,KAAKC,MAAlB,EAA0B,KAAKC,KAA/B,CAD2B;AAEnCI,aAAK;AACHO,mBAASC,WADN;AAEHC,mBAASC;AAFN;AAF8B,OAAlB,CAAnB;AAOD;;;4BAEOC,M,EAAQC,C,EAAG;AACjB,WAAKC,OAAL,GAAe,KAAKtB,aAAL,CAAmBoB,MAAnB,EAA2BC,CAA3B,EAA8B,KAAKL,OAAnC,EAA4C,KAAKO,MAAjD,CAAf;AACD;;;8BAES;AACR,UAAMrB,SAAS,KAAKK,aAAL,CAAmB,KAAKe,OAAxB,EAAiC,KAAKE,SAAL,CAAeR,OAAhD,EAAyD,KAAKQ,SAAL,CAAeZ,MAAxE,CAAf;AACA,WAAKF,MAAL,GAAcR,OAAOQ,MAArB;AACA,WAAKE,MAAL,GAAcV,OAAOU,MAArB;AACD;;;4BAEO;AACN,UAAMV,SAAS,KAAKY,WAAL,CACb,KAAKF,MADQ,EAEb,KAAKI,OAFQ,EAGb,KAAKS,aAAL,CAAmBH,OAHN,EAIb,KAAKG,aAAL,CAAmBP,OAJN,EAKbQ,YALa,EAMbC,QANa,CAAf;AAQA,WAAKX,OAAL,GAAed,OAAOc,OAAtB;AACA,WAAKE,OAAL,GAAehB,OAAOgB,OAAtB;AACD;;;;;;kBA7CkBnB,O;;;AAgDrB,SAASE,OAAT,CAAiBmB,MAAjB,EAAyBC,CAAzB,EAA4BL,OAA5B,EAAqCO,MAArC,EAA6C;AAC3C,MAAIK,MAAML,OAAOF,CAAP,CAAV;AACA,OAAK,IAAIQ,IAAI,CAAb,EAAgBA,IAAI,KAAK3B,MAAL,CAAY4B,CAAhC,EAAmCD,GAAnC,EAAwC;AACtCD,WAAOZ,QAAQK,CAAR,EAAWQ,CAAX,IAAgBT,OAAOS,CAAP,CAAvB;AACD;AACD,SAAO,sBAAQD,GAAR,CAAP;AACD;;AAED,SAASpB,OAAT,CAAiBc,OAAjB,EAA0BS,gBAA1B,EAA4CC,eAA5C,EAA6D;AAC3D,MAAI9B,SAASoB,QAAQ,KAAKW,MAAL,CAAYZ,CAApB,CAAb;AACA,SAAO,gCAAkBnB,MAAlB,EAA0BS,UAAUoB,gBAAV,EAA4BC,eAA5B,CAA1B,CAAP;AACD;;AAED,SAASrB,SAAT,CAAmBuB,WAAnB,EAAgCC,UAAhC,EAA4C;AAC1C,MAAIC,QAAQ,CAAZ;AACA,OAAI,IAAIP,IAAI,CAAZ,EAAeA,IAAI,KAAK3B,MAAL,CAAYmB,CAA/B,EAAkCQ,GAAlC,EAAsC;AACpCO,aAASD,WAAWN,CAAX,IAAgBK,YAAYL,CAAZ,EAAe,KAAKI,MAAL,CAAYZ,CAA3B,CAAzB;AACD;AACD,SAAOe,KAAP;AACD;;AAED,SAASrB,KAAT,CAAeH,MAAf,EAAuBI,OAAvB,EAAgCqB,oBAAhC,EAAsDC,oBAAtD,EAA4EZ,YAA5E,EAA0FC,QAA1F,EAAoG;AAClG,MAAMY,QAAQ3B,OAAO,KAAKqB,MAAL,CAAYH,CAAnB,CAAd;AACA,MAAMU,SAASrB,YACbmB,oBADa,EAEbC,KAFa,EAGbF,oBAHa,EAIbX,YAJa,EAKbC,QALa,CAAf;;AAQA,SAAOV,YAAYuB,MAAZ,EAAoBxB,OAApB,CAAP;AACD;;AAED,SAASG,WAAT,CAAqBsB,eAArB,EAAsCF,KAAtC,EAA6CG,eAA7C,EAA8DhB,YAA9D,EAA4EC,QAA5E,EAAsF;AACpF,MAAIC,MAAM,CAAV;AACA,OAAK,IAAIe,IAAI,CAAb,EAAgBA,IAAI,KAAKzC,MAAL,CAAYmB,CAAhC,EAAmCsB,GAAnC,EAAwC;AACtCf,WAAQF,eAAea,KAAf,GAAuBG,gBAAgB,KAAKT,MAAL,CAAYZ,CAA5B,CAAxB,GACFM,WAAWc,gBAAgB,KAAKR,MAAL,CAAYH,CAA5B,EAA+Ba,CAA/B,CADhB;AAED;AACD,SAAOf,GAAP;AACD;;AAED,SAASX,WAAT,CAAqBuB,MAArB,EAA6BxB,OAA7B,EAAsC;AACpC,SAAOwB,SAASxB,QAAQ,KAAKiB,MAAL,CAAYH,CAApB,EAAuB,KAAKG,MAAL,CAAYZ,CAAnC,CAAhB;AACD","file":"multiply-sigmoid.js","sourcesContent":["'use strict';\n\nimport Base from './base';\nimport { predict as multiply } from './multiply';\nimport { sigmoid, sigmoidDerivative } from '../activation/sigmoid';\nimport makeKernel from '../utilities/make-kernel';\n\nexport default class Sigmoid extends Base {\n  setupKernels() {\n    this.predictKernel = makeKernel(predict, {\n      output: [this.width, this.height, this.depth],\n      functions: [sigmoid]\n    });\n\n    this.compareKernel = makeKernel(compare, {\n      output: [this.width, this.height, this.depth],\n      map: {\n        errors: calcError,\n        deltas: calcDeltas\n      }\n    });\n\n    this.learnKernel = makeKernel(learn, {\n      output: [this.width, this.height, this.depth],\n      map: {\n        weights: calcWeights,\n        changes: calcChanges\n      }\n    });\n  }\n\n  predict(inputs, x) {\n    this.outputs = this.predictKernel(inputs, x, this.weights, this.biases);\n  }\n\n  compare() {\n    const output = this.compareKernel(this.outputs, this.nextLayer.weights, this.nextLayer.deltas);\n    this.errors = output.errors;\n    this.deltas = output.deltas;\n  }\n\n  learn() {\n    const output = this.learnKernel(\n      this.deltas,\n      this.weights,\n      this.previousLayer.outputs,\n      this.previousLayer.changes,\n      learningRate,\n      momentum\n    );\n    this.weights = output.weights;\n    this.changes = output.changes;\n  }\n}\n\nfunction predict(inputs, x, weights, biases) {\n  let sum = biases[x];\n  for (let k = 0; k < this.output.y; k++) {\n    sum += weights[x][k] * inputs[k];\n  }\n  return sigmoid(sum);\n}\n\nfunction compare(outputs, nextLayerWeights, nextLayerDeltas) {\n  let output = outputs[this.thread.x];\n  return sigmoidDerivative(output, calcError(nextLayerWeights, nextLayerDeltas));\n}\n\nfunction calcError(nextWeights, nextDeltas) {\n  let error = 0;\n  for(let k = 0; k < this.output.x; k++){\n    error += nextDeltas[k] * nextWeights[k][this.thread.x];\n  }\n  return error;\n}\n\nfunction learn(deltas, weights, previousLayerOutputs, previousLayerChanges, learningRate, momentum) {\n  const delta = deltas[this.thread.y];\n  const change = calcChanges(\n    previousLayerChanges,\n    delta,\n    previousLayerOutputs,\n    learningRate,\n    momentum\n  );\n\n  return calcWeights(change, weights);\n}\n\nfunction calcChanges(previousChanges, delta, previousOutputs, learningRate, momentum) {\n  let sum = 0;\n  for (let i = 0; i < this.output.x; i++) {\n    sum += (learningRate * delta * previousOutputs[this.thread.x])\n      + (momentum * previousChanges[this.thread.y][i]);\n  }\n  return sum;\n}\n\nfunction calcWeights(change, weights) {\n  return change + weights[this.thread.y][this.thread.x];\n}"]}