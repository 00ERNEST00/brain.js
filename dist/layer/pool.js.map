{"version":3,"sources":["../../src/layer/pool.js"],"names":["predict","learn","Pool","stride","padding","bias","filterWidth","filterHeight","settings","inputLayer","switchX","switchY","predictKernel","output","width","height","depth","map","setSwitchX","setSwitchY","learnKernel","weights","inputs","x","thread","constants","inputWidth","paddingX","y","inputHeight","paddingY","largestValue","Infinity","largestX","largestY","filterY","inputY","filterX","inputX","input","z","value","deltas","Math","floor","outputWidth","outputHeight","deltaXIndex","deltaYIndex"],"mappings":"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","file":"pool.js","sourcesContent":["import Base from './base';\nimport makeKernel from '../utilities/make-kernel';\nimport { setPadding, setStride } from \"../utilities/layer-setup\"\nexport default class Pool extends Base {\n  static get defaults() {\n    return {\n      stride: 0,\n      padding: 0,\n      bias: 0,\n      filterWidth: 0,\n      filterHeight: 0\n    };\n  }\n\n  constructor(settings, inputLayer) {\n    super(settings);\n    this.inputLayer = inputLayer;\n\n    setPadding(this, settings);\n    setStride(this, settings);\n\n    this.switchX = null;\n    this.switchY = null;\n  }\n\n  setupKernels() {\n    this.predictKernel = makeKernel(predict, {\n      output: [this.width, this.height, this.depth],\n      map: {\n        switchX: setSwitchX,\n        switchY: setSwitchY\n      }\n    });\n\n    this.learnKernel = makeKernel(learn, {\n      output: [this.width, this.height, this.depth]\n    });\n  }\n\n  predict() {\n    const weights = this.predictKernel(this.inputLayer);\n    this.switchX = weights.switchX;\n    this.switchY = weights.switchY;\n    return this.weights = weights;\n  }\n}\n\nexport function predict(inputs) {\n  const x = ((this.thread.x / this.output.x) * this.constants.inputWidth) - this.constants.paddingX;\n  const y = ((this.thread.y / this.output.y) * this.constants.inputHeight) - this.constants.paddingY;\n  let largestValue = -Infinity;\n  let largestX = -1;\n  let largestY = -1;\n\n  // convolve centered at this particular location\n  for (let filterY = 0; filterY < this.constants.filterHeight; filterY++) {\n    // coordinates in the original input array coordinates\n    let inputY = filterY + y;\n    for (let filterX = 0; filterX < this.constants.filterWidth; filterX++) {\n      let inputX = filterX + x;\n      if (\n        inputY >= 0\n        && inputY < this.constants.inputHeight\n        && inputX >= 0\n        && inputX < this.constants.inputWidth\n      ) {\n        const input = inputs[this.output.z][inputY][inputX];\n        if (input > largestValue) {\n          largestValue = input;\n          largestY = inputY;\n          largestX = inputX;\n        }\n      }\n    }\n  }\n  setSwitchY(largestY);\n  setSwitchX(largestX);\n  return largestValue;\n}\n\nfunction setSwitchY(value) {\n  return value;\n}\n\nfunction setSwitchX(value) {\n  return value;\n}\n\nexport function learn(deltas, switchY, switchX) {\n  const x = Math.floor(((this.thread.x / this.output.x) * this.constants.outputWidth) - this.constants.paddingX);\n  const y = Math.floor(((this.thread.y / this.output.y) * this.constants.outputHeight) - this.constants.paddingY);\n  const deltaXIndex = switchX[y][x];\n  const deltaYIndex = switchY[y][x];\n\n  if (deltaXIndex !== this.thread.y) return 0;\n  if (deltaYIndex !== this.thread.x) return 0;\n\n  return deltas[y][x];\n}\n"]}