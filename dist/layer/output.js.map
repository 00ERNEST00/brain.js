{"version":3,"sources":["../../src/layer/output.js"],"names":["Output","settings","inputLayer","compareKernel","output","width","height","learnKernel","outputs","target","thread","x","calcDeltas","calcError","error","weights","deltas","k"],"mappings":"AAAA;;;;;;;;AAEA;;;;AACA;;;;;;;;;;;;IAEqBA,M;;;AACnB,kBAAYC,QAAZ,EAAsBC,UAAtB,EAAkC;AAAA;;AAAA,gHAC1BD,QAD0B;;AAEhC,UAAKC,UAAL,GAAkBA,UAAlB;AAFgC;AAGjC;;;;mCAEc;AACb,WAAKC,aAAL,GAAqB,0BAAW,YAAW,CAE1C,CAFoB,EAElB;AACDC,gBAAQ,CAAC,KAAKF,UAAL,CAAgBG,KAAjB,EAAwB,KAAKH,UAAL,CAAgBI,MAAxC;AADP,OAFkB,CAArB;AAKA,WAAKC,WAAL,GAAmB,0BAAW,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;AACtD,YAAML,SAASI,QAAQ,KAAKE,MAAL,CAAYC,CAApB,CAAf;AACA,eAAOC,WAAWC,UAAUT,MAAV,EAAkBK,MAAlB,CAAX,EAAsCL,MAAtC,CAAP;AACD,OAHkB,EAGhB;AACDA,gBAAQ,CAAC,KAAKF,UAAL,CAAgBG,KAAjB,EAAwB,KAAKH,UAAL,CAAgBI,MAAxC;AADP,OAHgB,CAAnB;AAMD;;;8BAES;AACR,WAAKE,OAAL,GAAe,KAAKN,UAAL,CAAgBM,OAA/B;AACD;;;8BAES,CAET;;;4BAEO,CAEP;;;;;;kBA9BkBR,M;;;AAiCrB,SAASY,UAAT,CAAoBE,KAApB,EAA2BV,MAA3B,EAAmC;AACjC,SAAOU,QAAQV,MAAR,IAAkB,IAAIA,MAAtB,CAAP;AACD;;AAED,SAASS,SAAT,CAAmBE,OAAnB,EAA4BC,MAA5B,EAAoC;AAClC,MAAIF,QAAQ,CAAZ;AACA,OAAI,IAAIG,IAAI,CAAZ,EAAeA,IAAI,KAAKb,MAAL,CAAYO,CAA/B,EAAkCM,GAAlC,EAAsC;AACpCH,aAASE,OAAOC,CAAP,IAAYF,QAAQE,CAAR,EAAW,KAAKP,MAAL,CAAYC,CAAvB,CAArB;AACD;AACD,SAAOG,KAAP;AACD","file":"output.js","sourcesContent":["'use strict';\n\nimport Base from './base';\nimport makeKernel from '../utilities/make-kernel';\n\nexport default class Output extends Base {\n  constructor(settings, inputLayer) {\n    super(settings);\n    this.inputLayer = inputLayer;\n  }\n\n  setupKernels() {\n    this.compareKernel = makeKernel(function() {\n\n    }, {\n      output: [this.inputLayer.width, this.inputLayer.height]\n    });\n    this.learnKernel = makeKernel(function(outputs, target) {\n      const output = outputs[this.thread.x];\n      return calcDeltas(calcError(output, target), output);\n    }, {\n      output: [this.inputLayer.width, this.inputLayer.height]\n    });\n  }\n\n  predict() {\n    this.outputs = this.inputLayer.outputs;\n  }\n\n  compare() {\n\n  }\n\n  learn() {\n\n  }\n}\n\nfunction calcDeltas(error, output) {\n  return error * output * (1 - output);\n}\n\nfunction calcError(weights, deltas) {\n  let error = 0;\n  for(let k = 0; k < this.output.x; k++){\n    error += deltas[k] * weights[k][this.thread.x];\n  }\n  return error;\n}"]}