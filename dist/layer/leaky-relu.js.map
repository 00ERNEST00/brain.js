{"version":3,"sources":["../../src/layer/leaky-relu.js"],"names":["predict","learn","LeakyRelu","inputLayer","width","height","depth","predictKernel","functions","learnKernel","weights","deltas","inputs","thread","y","x"],"mappings":";;;;;;;;QA+BgBA,O,GAAAA,O;QAIAC,K,GAAAA,K;;AAnChB;;;;AACA;;;;AACA;;;;;;;;;;IAEqBC,S;;;AACnB,qBAAYC,UAAZ,EAAwB;AAAA;;AAAA;;AAEtB,UAAKC,KAAL,GAAaD,WAAWC,KAAxB;AACA,UAAKC,MAAL,GAAcF,WAAWE,MAAzB;AACA,UAAKC,KAAL,GAAaH,WAAWG,KAAxB;AACA,UAAKH,UAAL,GAAkBA,UAAlB;AALsB;AAMvB;;;;mCACc;AACb,WAAKI,aAAL,GAAqB,0BAAWP,OAAX,EAAoB;AACvCQ,mBAAW;AAD4B,OAApB,CAArB;;AAIA,WAAKC,WAAL,GAAmB,0BAAWR,KAAX,EAAkB;AACnCO,mBAAW;AADwB,OAAlB,CAAnB;AAGD;;;8BAES;AACR,WAAKE,OAAL,GAAe,KAAKH,aAAL,CAAmB,KAAKJ,UAAL,CAAgBO,OAAnC,CAAf;AACD;;;4BAEO;AACN,WAAKC,MAAL,GAAc,KAAKF,WAAL,CAAiB,KAAKC,OAAtB,EAA+B,KAAKC,MAApC,CAAd;AACD;;;;;;kBAxBkBT,S;AA2Bd,SAASF,OAAT,CAAiBY,MAAjB,EAAyB;AAC9B,SAAO,0BAAUA,OAAO,KAAKC,MAAL,CAAYC,CAAnB,EAAsB,KAAKD,MAAL,CAAYE,CAAlC,CAAV,CAAP;AACD;;AAEM,SAASd,KAAT,CAAeS,OAAf,EAAwBC,MAAxB,EAAgC;AACrC,SAAO,oCAAoBD,QAAQ,KAAKG,MAAL,CAAYC,CAApB,EAAuB,KAAKD,MAAL,CAAYE,CAAnC,CAApB,EAA2DJ,OAAO,KAAKE,MAAL,CAAYC,CAAnB,EAAsB,KAAKD,MAAL,CAAYE,CAAlC,CAA3D,CAAP;AACD","file":"leaky-relu.js","sourcesContent":["import Base from './base';\nimport makeKernel from '../utilities/make-kernel';\nimport { leakyRelu, leakyReluDerivative } from '../activation/leaky-relu';\n\nexport default class LeakyRelu extends Base {\n  constructor(inputLayer) {\n    super();\n    this.width = inputLayer.width;\n    this.height = inputLayer.height;\n    this.depth = inputLayer.depth;\n    this.inputLayer = inputLayer;\n  }\n  setupKernels() {\n    this.predictKernel = makeKernel(predict, {\n      functions: [leakyRelu]\n    });\n\n    this.learnKernel = makeKernel(learn, {\n      functions: [leakyReluDerivative]\n    });\n  }\n\n  predict() {\n    this.weights = this.predictKernel(this.inputLayer.weights);\n  }\n\n  learn() {\n    this.deltas = this.learnKernel(this.weights, this.deltas);\n  }\n}\n\nexport function predict(inputs) {\n  return leakyRelu(inputs[this.thread.y][this.thread.x]);\n}\n\nexport function learn(weights, deltas) {\n  return leakyReluDerivative(weights[this.thread.y][this.thread.x], deltas[this.thread.y][this.thread.x]);\n}"]}