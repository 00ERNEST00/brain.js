{"version":3,"sources":["../../src/layer/sigmoid.js"],"names":["predict","learn","Sigmoid","inputLayer","width","height","weights","deltas","predictKernel","output","functions","compareKernel","compare","map","errors","calcError","constants","learnKernel","result","previousLayer","nextLayer","inputs","thread","y","x","nextLayerWeights","nextLayerDeltas","weight","nextWeights","nextDeltas","error","k"],"mappings":"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","file":"sigmoid.js","sourcesContent":["import Base from './base';\nimport makeKernel from '../utilities/make-kernel';\nimport { activate, measure } from '../activation/sigmoid';\nimport randos from '../utilities/randos';\nimport randos2d from '../utilities/randos-2d';\nimport zeros from '../utilities/zeros';\nimport zeros2d from '../utilities/zeros-2d';\n\nexport default class Sigmoid extends Base {\n  constructor(inputLayer) {\n    const { width, height} = inputLayer;\n    super({ width, height });\n    this.inputLayer = inputLayer;\n    this.weights = randos2d(width, height);\n    this.deltas = zeros(width);\n  }\n\n  setupKernels() {\n    this.predictKernel = makeKernel(predict, {\n      output: [this.width, this.height],\n      functions: [activate]\n    });\n\n    this.compareKernel = makeKernel(compare, {\n      output: [this.width, this.height],\n      map: {\n        errors: calcError,\n        deltas: measure\n      },\n      constants: { width: this.width }\n    });\n\n    this.learnKernel = makeKernel(learn, {\n      output: [this.width, this.height],\n      functions: [measure]\n    });\n  }\n\n  predict() {\n    const result = this.predictKernel(this.inputLayer.weights);\n    this.weights = result;\n  }\n\n  compare(previousLayer, nextLayer) {\n    const { errors, deltas } = this.compareKernel(this.weights, nextLayer.weights, nextLayer.deltas);\n    this.errors = errors;\n    this.deltas = deltas;\n  }\n\n  learn() {\n    this.deltas = this.learnKernel(this.weights, this.errors);\n  }\n}\n\nexport function predict(inputs) {\n  return activate(inputs[this.thread.y][this.thread.x]);\n}\n\nfunction compare(weights, nextLayerWeights, nextLayerDeltas) {\n  let weight = weights[this.thread.x];\n  return measure(weight, calcError(nextLayerWeights, nextLayerDeltas));\n}\n\nexport function learn(weights, errors) {\n  return measure(weights[this.thread.y][this.thread.x], errors[this.thread.y][this.thread.x]);\n}\n\nfunction calcError(nextWeights, nextDeltas) {\n  let error = 0;\n  for(let k = 0; k < this.constants.width; k++) {\n    debugger;\n    error += nextDeltas[k] * nextWeights[k][this.thread.x];\n  }\n  return error;\n}"]}