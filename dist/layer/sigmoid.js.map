{"version":3,"sources":["../../src/layer/sigmoid.js"],"names":["predict","learn","Sigmoid","inputLayer","width","height","depth","predictKernel","output","functions","compareKernel","compare","map","errors","calcError","deltas","learnKernel","outputs","previousLayer","nextLayer","weights","inputs","thread","y","x","nextLayerWeights","nextLayerDeltas","nextWeights","nextDeltas","error","k"],"mappings":"AAAA;;;;;;;;QAkDgBA,O,GAAAA,O;QASAC,K,GAAAA,K;;AAzDhB;;;;AACA;;;;AACA;;;;;;;;;;IAEqBC,O;;;AACnB,mBAAYC,UAAZ,EAAwB;AAAA;;AAAA;;AAEtB,UAAKC,KAAL,GAAaD,WAAWC,KAAxB;AACA,UAAKC,MAAL,GAAcF,WAAWE,MAAzB;AACA,UAAKC,KAAL,GAAaH,WAAWG,KAAxB;AACA,UAAKH,UAAL,GAAkBA,UAAlB;AALsB;AAMvB;;;;mCAEc;AACb,WAAKI,aAAL,GAAqB,0BAAWP,OAAX,EAAoB;AACvCQ,gBAAQ,CAAC,KAAKJ,KAAN,EAAa,KAAKC,MAAlB,EAA0B,KAAKC,KAA/B,CAD+B;AAEvCG,mBAAW;AAF4B,OAApB,CAArB;;AAKA,WAAKC,aAAL,GAAqB,0BAAWC,OAAX,EAAoB;AACvCH,gBAAQ,CAAC,KAAKJ,KAAN,EAAa,KAAKC,MAAlB,EAA0B,KAAKC,KAA/B,CAD+B;AAEvCM,aAAK;AACHC,kBAAQC,SADL;AAEHC;AAFG;AAFkC,OAApB,CAArB;;AAQA,WAAKC,WAAL,GAAmB,0BAAWf,KAAX,EAAkB;AACnCO,gBAAQ,CAAC,KAAKJ,KAAN,EAAa,KAAKC,MAAlB,EAA0B,KAAKC,KAA/B,CAD2B;AAEnCG,mBAAW;AAFwB,OAAlB,CAAnB;AAID;;;8BAES;AACR,WAAKQ,OAAL,GAAe,KAAKV,aAAL,CAAmB,KAAKJ,UAAL,CAAgBc,OAAnC,CAAf;AACD;;;4BAEOC,a,EAAeC,S,EAAW;AAAA,2BACL,KAAKT,aAAL,CAAmB,KAAKO,OAAxB,EAAiCE,UAAUC,OAA3C,EAAoDD,UAAUJ,MAA9D,CADK;AAAA,UACxBF,MADwB,kBACxBA,MADwB;AAAA,UAChBE,MADgB,kBAChBA,MADgB;;AAEhC,WAAKF,MAAL,GAAcA,MAAd;AACA,WAAKE,MAAL,GAAcA,MAAd;AACD;;;4BAEO;AACN,WAAKA,MAAL,GAAc,KAAKC,WAAL,CAAiB,KAAKI,OAAtB,EAA+B,KAAKP,MAApC,CAAd;AACD;;;;;;kBAzCkBX,O;AA4Cd,SAASF,OAAT,CAAiBqB,MAAjB,EAAyB;AAC9B,SAAO,sBAAQA,OAAO,KAAKC,MAAL,CAAYC,CAAnB,EAAsB,KAAKD,MAAL,CAAYE,CAAlC,CAAR,CAAP;AACD;;AAED,SAASb,OAAT,CAAiBM,OAAjB,EAA0BQ,gBAA1B,EAA4CC,eAA5C,EAA6D;AAC3D,MAAIlB,SAASS,QAAQ,KAAKK,MAAL,CAAYE,CAApB,CAAb;AACA,SAAO,gCAAkBhB,MAAlB,EAA0BM,UAAUW,gBAAV,EAA4BC,eAA5B,CAA1B,CAAP;AACD;;AAEM,SAASzB,KAAT,CAAemB,OAAf,EAAwBP,MAAxB,EAAgC;AACrC,SAAO,gCAAkBO,QAAQ,KAAKE,MAAL,CAAYC,CAApB,EAAuB,KAAKD,MAAL,CAAYE,CAAnC,CAAlB,EAAyDX,OAAO,KAAKS,MAAL,CAAYC,CAAnB,EAAsB,KAAKD,MAAL,CAAYE,CAAlC,CAAzD,CAAP;AACD;;AAED,SAASV,SAAT,CAAmBa,WAAnB,EAAgCC,UAAhC,EAA4C;AAC1C,MAAIC,QAAQ,CAAZ;AACA,OAAI,IAAIC,IAAI,CAAZ,EAAeA,IAAI,KAAKtB,MAAL,CAAYgB,CAA/B,EAAkCM,GAAlC,EAAsC;AACpCD,aAASD,WAAWE,CAAX,IAAgBH,YAAYG,CAAZ,EAAe,KAAKR,MAAL,CAAYE,CAA3B,CAAzB;AACD;AACD,SAAOK,KAAP;AACD","file":"sigmoid.js","sourcesContent":["'use strict';\n\nimport Base from './base';\nimport makeKernel from '../utilities/make-kernel';\nimport { sigmoid, sigmoidDerivative } from '../activation/sigmoid';\n\nexport default class Sigmoid extends Base {\n  constructor(inputLayer) {\n    super();\n    this.width = inputLayer.width;\n    this.height = inputLayer.height;\n    this.depth = inputLayer.depth;\n    this.inputLayer = inputLayer;\n  }\n\n  setupKernels() {\n    this.predictKernel = makeKernel(predict, {\n      output: [this.width, this.height, this.depth],\n      functions: [sigmoid]\n    });\n\n    this.compareKernel = makeKernel(compare, {\n      output: [this.width, this.height, this.depth],\n      map: {\n        errors: calcError,\n        deltas: sigmoidDerivative\n      }\n    });\n\n    this.learnKernel = makeKernel(learn, {\n      output: [this.width, this.height, this.depth],\n      functions: [sigmoidDerivative]\n    });\n  }\n\n  predict() {\n    this.outputs = this.predictKernel(this.inputLayer.outputs);\n  }\n\n  compare(previousLayer, nextLayer) {\n    const { errors, deltas } = this.compareKernel(this.outputs, nextLayer.weights, nextLayer.deltas);\n    this.errors = errors;\n    this.deltas = deltas;\n  }\n\n  learn() {\n    this.deltas = this.learnKernel(this.weights, this.errors);\n  }\n}\n\nexport function predict(inputs) {\n  return sigmoid(inputs[this.thread.y][this.thread.x]);\n}\n\nfunction compare(outputs, nextLayerWeights, nextLayerDeltas) {\n  let output = outputs[this.thread.x];\n  return sigmoidDerivative(output, calcError(nextLayerWeights, nextLayerDeltas));\n}\n\nexport function learn(weights, errors) {\n  return sigmoidDerivative(weights[this.thread.y][this.thread.x], errors[this.thread.y][this.thread.x]);\n}\n\nfunction calcError(nextWeights, nextDeltas) {\n  let error = 0;\n  for(let k = 0; k < this.output.x; k++){\n    error += nextDeltas[k] * nextWeights[k][this.thread.x];\n  }\n  return error;\n}"]}