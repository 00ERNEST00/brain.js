{"version":3,"sources":["../src/neural-network-gpu.js"],"names":["NeuralNetworkGPU","options","forwardPropagate","backwardPropagate","changesPropagate","biasesPropagate","count","error","logCount","gpu","mode","sizes","keepNetworkIntact","buildRunInput","buildCalculateDeltas","buildGetChanges","buildChangeBiases","input","target","learningRate","runInput","calculateDeltas","getChanges","changeBiases","iterations","i","errors","length","toArray","outputLayer","weightedSum","activation","weightedSumSigmoid","weightedSumRelu","weightedSumLeakyRelu","weightedSumTanh","Error","layer","kernel","createKernelMap","alias","weights","biases","inputs","thread","x","constants","size","setOutput","setOutputToTexture","output","outputs","result","calcDeltas","calcDeltasSigmoid","calcDeltasRelu","calcDeltasLeakyRelu","calcDeltasTanh","calcError","deltas","calcErrorOutput","nextWeights","nextDeltas","addWeights","calcChanges","previousOutputs","changes","momentum","delta","y","change","addBiases","inputLookup","outputLookup","toHash","data","constructor","Array","tmp","push","datum","Float64Array","buildLookup","map","value","array","Object","assign","trainDefaults","errorThresh","log","logPeriod","callback","callbackPeriod","defaults","binaryThresh","hiddenLayers","sum","k","Math","exp","tanh","previousChange"],"mappings":"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","file":"neural-network-gpu.js","sourcesContent":["import NeuralNetwork from './neural-network';\nimport lookup from './lookup';\nimport TrainStream from './train-stream';\nimport max from './utilities/max';\nimport mse from './utilities/mse';\nimport randos from './utilities/randos';\nimport range from './utilities/range';\nimport toArray from './utilities/to-array';\nimport zeros from './utilities/zeros';\nimport GPU from 'gpu.js';\n\n/**\n *\n * @param {object} options\n * @constructor\n */\nexport default class NeuralNetworkGPU extends NeuralNetwork {\n  constructor(options = {}) {\n    super(options);\n\n    this.forwardPropagate = [];\n    this.backwardPropagate = [];\n    this.changesPropagate = [];\n    this.biasesPropagate = [];\n\n    this.count = 0;\n    this.error = 1;\n    this.logCount = options.logCount;\n    this.gpu = new GPU({mode: options.mode});\n  }\n\n  /**\n   *\n   * @param {} sizes\n   * @param {Boolean} keepNetworkIntact\n   */\n  initialize(sizes, keepNetworkIntact) {\n    super.initialize(sizes, keepNetworkIntact);\n    this.buildRunInput();\n    this.buildCalculateDeltas();\n    this.buildGetChanges();\n    this.buildChangeBiases();\n  }\n\n  setActivation() {}\n\n  /**\n   *\n   * @param input\n   * @param target\n   * @param learningRate\n   */\n  trainPattern(input, target, learningRate) {\n    learningRate = learningRate || this.learningRate;\n    // forward propagate\n    this.runInput(input);\n\n    // backward propagate\n    this.calculateDeltas(target);\n    this.getChanges(learningRate);\n    this.changeBiases(learningRate);\n    \n    if (this.count % this.logCount === 0 || this.count === 1 || this.iterations === this.count) {\n      for (let i = 0; i < this.errors.length; i++) {\n        this.errors[i] = this.errors[i].toArray\n          ? this.errors[i].toArray(this.gpu)\n          : this.errors[i];\n      }\n      let error = this.error = mse(this.errors[this.outputLayer]);\n      return error;\n    } else {\n      return this.error;\n    }\n  }\n\n  buildRunInput() {\n    let weightedSum = null;\n\n    switch (this.activation) {\n      case 'sigmoid':\n        weightedSum = weightedSumSigmoid;\n        break;\n      case 'relu':\n        weightedSum = weightedSumRelu;\n        break;\n      case 'leaky-relu':\n        weightedSum = weightedSumLeakyRelu;\n        break;\n      case 'tanh':\n        weightedSum = weightedSumTanh;\n        break;\n      default:\n        throw new Error('unknown activation ' + this.activation);\n    }\n\n    for(let layer = 1; layer <= this.outputLayer; layer++){\n      const kernel = this.gpu.createKernelMap({ weightedSum: GPU.alias('weightedSum', weightedSum) },\n        function(weights, biases, inputs){\n          return weightedSum(weights, biases, this.thread.x, inputs);\n        }, {\n        constants:{\n          size: this.sizes[layer - 1]\n        }\n      })\n      .setOutput([this.sizes[layer]])\n      .setOutputToTexture(true);\n      this.forwardPropagate[layer] = kernel;\n    }\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  runInput(input) {\n    let output;\n    this.outputs[0] = input;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      this.outputs[layer] = this.forwardPropagate[layer](\n        this.weights[layer], \n        this.biases[layer], \n        input\n      ).result;\n\n      output = input = this.outputs[layer];\n    }\n      // console.log(this.outputs[2], 'Outputs')\n    return output;\n  }\n\n  buildCalculateDeltas() {\n    let calcDeltas = null;\n\n    switch (this.activation) {\n      case 'sigmoid':\n        calcDeltas = calcDeltasSigmoid;\n        break;\n      case 'relu':\n        calcDeltas = calcDeltasRelu;\n        break;\n      case 'leaky-relu':\n        calcDeltas = calcDeltasLeakyRelu;\n        break;\n      case 'tanh':\n        calcDeltas = calcDeltasTanh;\n        break;\n      default:\n        throw new Error('unknown activation ' + this.activation);\n    }\n\n    for (let layer = this.outputLayer; layer > 0; layer--) {\n      if (layer === this.outputLayer){\n        const kernel = this.gpu.createKernelMap({\n          error: GPU.alias('calcError', calcError),\n          deltas: GPU.alias('calcDeltas', calcDeltas)\n        }, function(outputs, target){\n          let output = outputs[this.thread.x];\n          return calcDeltas(calcError(output, target), output);\n      })\n       .setOutput([this.sizes[layer]])\n       .setOutputToTexture(true);\n        \n        this.backwardPropagate[layer] = kernel;\n\n      } else {\n        const kernel = this.gpu.createKernelMap({\n          error: GPU.alias('calcErrorOutput', calcErrorOutput),\n          deltas: GPU.alias('calcDeltas', calcDeltas),\n        }, function(nextWeights, outputs, nextDeltas){\n          let output = outputs[this.thread.x];\n          return calcDeltas(calcErrorOutput(nextWeights, nextDeltas), output);\n        }, {\n          constants: {\n            size: this.deltas[layer + 1].length\n          }\n        })\n        .setOutput([this.sizes[layer]])\n        .setOutputToTexture(true);\n        \n        this.backwardPropagate[layer] = kernel;\n      }\n    }\n  }\n\n  calculateDeltas(target,learningRate) {\n    for (let layer = this.outputLayer; layer > 0; layer--) {\n      let output;\n      if (layer === this.outputLayer){\n        output = this.backwardPropagate[layer](\n          this.outputs[layer],\n          target);\n      } else {\n        output = this.backwardPropagate[layer](\n          this.weights[layer + 1],\n          this.outputs[layer],\n          this.deltas[layer + 1],\n        )}\n\n      this.deltas[layer] = output.result; \n      this.errors[layer] = output.error;\n    }\n  }\n\n  buildGetChanges() {\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n     const kernel = this.gpu.createKernelMap({\n         addWeights, calcChanges},\n        function(previousOutputs, deltas, weights, changes, learningRate, momentum){\n          let delta = deltas[this.thread.y];\n          let change = calcChanges(\n            changes, \n            delta, \n            previousOutputs, \n            learningRate, \n            momentum, \n            this.thread.x, \n            this.thread.y);\n\n          return addWeights(change, weights, this.thread.x, this.thread.y);\n        }, {\n          constants:{\n            size: this.outputs[layer - 1].length\n          }\n        })\n          .setOutput([this.sizes[layer -1], this.sizes[layer]])\n          .setOutputToTexture(true);\n        \n      this.changesPropagate[layer] = kernel;\n    }    \n  }\n  \n  getChanges(learningRate){\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      let output = this.changesPropagate[layer](\n        this.outputs[layer - 1],\n        this.deltas[layer],\n        this.weights[layer],\n        this.changes[layer],\n        learningRate,\n        this.momentum\n      );\n      \n      this.changes[layer] = output.calcChanges;\n      this.weights[layer] = output.result;\n    }\n  }\n\n  buildChangeBiases() {\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      const kernel = this.gpu.createKernelMap({\n        addBiases\n      }, function (biases, deltas, learningRate) {\n        return addBiases(biases, deltas, learningRate, this.thread.x);\n      })\n        .setOutput([this.sizes[layer]])\n        .setOutputToTexture(true);\n\n      this.biasesPropagate[layer] = kernel;\n    }\n  }\n\n  changeBiases(learningRate) {\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      let output = this.biasesPropagate[layer](\n        this.biases[layer],\n        this.deltas[layer],\n        learningRate\n      );\n      this.biases[layer] = output.result;\n    }\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  run(input) {\n    if (this.inputLookup) {\n      input = lookup.toArray(this.inputLookup, input);\n    }\n    let output = this.runInput(input);\n\n    if (this.outputLookup) {\n      output = lookup.toHash(this.outputLookup, output);\n    }\n    return output;\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {*}\n   */\n  formatData(data) {\n    if (data.constructor !== Array) { // turn stream datum into array\n      let tmp = [];\n      tmp.push(data);\n      data = tmp;\n    }\n    // turn sparse hash input into arrays with 0s as filler\n    let datum = data[0].input;\n    if (datum.constructor !== Array && !(datum instanceof Float64Array)) {\n      if (!this.inputLookup) {\n        this.inputLookup = lookup.buildLookup(data.map(value => value['input']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.inputLookup, datum.input);\n        return Object.assign({}, datum, { input: array });\n      }, this);\n    }\n\n    if (data[0].output.constructor !== Array) {\n      if (!this.outputLookup) {\n        this.outputLookup = lookup.buildLookup(data.map(value => value['output']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.outputLookup, datum.output);\n        return Object.assign({}, datum, { output: array });\n      }, this);\n    }\n    return data;\n  }\n\n}\n\nNeuralNetworkGPU.trainDefaults = {\n  iterations: 20000,\n  errorThresh: 0.005,\n  log: false,\n  logPeriod: 10,\n  learningRate: 0.3,\n  callback: null,\n  callbackPeriod: 10,\n  keepNetworkIntact: false\n};\n\nNeuralNetworkGPU.defaults = {\n  learningRate: 0.3,\n  momentum: 0.1,\n  binaryThresh: 0.5,\n  hiddenLayers: null\n};\n\nfunction weightedSumSigmoid(weights, biases, x, inputs) {\n  let sum = biases[x];\n  for (let k = 0; k < size; k++) {\n    sum += weights[x][k] * inputs[k];\n  }\n  //sigmoid\n  return 1 / (1 + Math.exp(-sum));\n}\n\nfunction weightedSumRelu(weights, biases, x, inputs) {\n  let sum = biases[x];\n  for (let k = 0; k < size; k++) {\n    sum += weights[x][k] * inputs[k];\n  }\n  //relu\n  return (sum < 0 ? 0 : sum);\n}\n\nfunction weightedSumLeakyRelu(weights, biases, x, inputs) {\n  let sum = biases[x];\n  for (let k = 0; k < size; k++) {\n    sum += weights[x][k] * inputs[k];\n  }\n  //leaky relu\n  return (sum < 0 ? 0 : 0.01 * sum);\n}\n\nfunction weightedSumTanh(weights, biases, x, inputs) {\n  let sum = biases[x];\n  for (let k = 0; k < size; k++) {\n    sum += weights[x][k] * inputs[k];\n  }\n  //tanh\n  return Math.tanh(sum);\n}\n\nfunction calcError(outputs, target) {\n  return target[this.thread.x] - outputs;\n}\n\nfunction calcDeltasSigmoid(error, output) {\n  //sigmoid derivative\n  return error * output * (1 - output);\n}\n\nfunction calcDeltasRelu(error, output) {\n  //relu derivative\n  return output > 0 ? error : 0;\n}\n\nfunction calcDeltasLeakyRelu(error, output) {\n  //leaky relu derivative\n  return output > 0 ? error : 0.01 * error;\n}\n\nfunction calcDeltasTanh(error, output) {\n  //tanh derivative\n  return (1 - output * output) * error;\n}\n\nfunction calcErrorOutput(nextWeights, nextDeltas){\n  let error = 0;\n  for(let k = 0; k < size; k++){\n    error += nextDeltas[k] * nextWeights[k][this.thread.x];\n  }\n  return error;\n}\n\nfunction calcChanges(previousChange, deltas, previousOutputs, learningRate, momentum, x, y) {\n  let sum = 0;\n  for (let i = 0; i < this.constants.size; i++) {\n    sum += (learningRate * deltas * previousOutputs[x])\n      + (momentum * previousChange[y][i]);\n  }\n  return sum;\n}\n\nfunction addWeights(change, weights, x, y){\n  return change + weights[y][x];\n}\n\nfunction addBiases(biases, deltas, learningRate, x){\n  return biases[x] + (deltas[x] * learningRate);\n}"]}