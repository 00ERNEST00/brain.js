{"version":3,"sources":["../../src/recurrent/equation.js"],"names":["Equation","inputRow","states","previousResults","previousResultInputs","size","into","push","left","right","weights","length","Error","rows","columns","forwardFn","backpropagationFn","m","self","iForward","iBackpropagate","console","log","rowIndex","state","i","max","hasOwnProperty","equation","prev"],"mappings":"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","file":"equation.js","sourcesContent":["import Matrix from './matrix';\nimport _copy from './matrix/copy';\nimport _add from './matrix/add';\nimport _addB from './matrix/add-b';\nimport _multiply from './matrix/multiply';\nimport _multiplyB from './matrix/multiply-b';\nimport _multiplyElement from './matrix/multiply-element';\nimport _multiplyElementB from './matrix/multiply-element-b';\nimport _relu from './matrix/relu';\nimport _reluB from './matrix/relu-b';\nimport _rowPluck from './matrix/row-pluck';\nimport _rowPluckB from './matrix/row-pluck-b';\nimport _sigmoid from './matrix/sigmoid';\nimport _sigmoidB from './matrix/sigmoid-b';\nimport _tanh from './matrix/tanh';\nimport _tanhB from './matrix/tanh-b';\n\nexport default class Equation {\n  constructor() {\n    this.inputRow = 0;\n    this.states = [];\n    this.previousResults = [];\n    this.previousResultInputs = [];\n  }\n\n  /**\n   *\n   * @param {Number} size\n   * @returns {Matrix}\n   */\n  previousResult(size) {\n    let into = new Matrix(size, 1);\n    this.previousResultInputs.push(into);\n    return into;\n  }\n\n  /**\n   * connects two matrices together by add\n   * @param {Matrix} left\n   * @param {Matrix} right\n   * @returns {Matrix}\n   */\n  add(left, right) {\n    if (left.weights.length !== right.weights.length) {\n      throw new Error('misaligned matrices');\n    }\n    let into = new Matrix(left.rows, left.columns);\n    this.states.push({\n      left: left,\n      right: right,\n      into: into,\n      forwardFn: _add,\n      backpropagationFn: _addB\n    });\n    return into;\n  }\n\n  /**\n   * connects two matrices together by multiply\n   * @param {Matrix} left\n   * @param {Matrix} right\n   * @returns {Matrix}\n   */\n  multiply(left, right) {\n    if (left.columns !== right.rows) {\n      throw new Error('misaligned matrices');\n    }\n    let into = new Matrix(left.rows, right.columns);\n    this.states.push({\n      left: left,\n      right: right,\n      into: into,\n      forwardFn: _multiply,\n      backpropagationFn: _multiplyB\n    });\n    return into;\n  }\n\n  /**\n   * connects two matrices together by multiplyElement\n   * @param {Matrix} left\n   * @param {Matrix} right\n   * @returns {Matrix}\n   */\n  multiplyElement(left, right) {\n    if (left.weights.length !== right.weights.length) {\n      throw new Error('misaligned matrices');\n    }\n    let into = new Matrix(left.rows, left.columns);\n    this.states.push({\n      left: left,\n      right: right,\n      into: into,\n      forwardFn: _multiplyElement,\n      backpropagationFn: _multiplyElementB\n    });\n    return into;\n  }\n\n  /**\n   * connects a matrix to relu\n   * @param {Matrix} m\n   * @returns {Matrix}\n   */\n  relu(m) {\n    let into = new Matrix(m.rows, m.columns);\n    this.states.push({\n      left: m,\n      into: into,\n      forwardFn: _relu,\n      backpropagationFn: _reluB\n    });\n    return into;\n  }\n\n  /**\n   * connects a matrix via a row\n   * @param {Matrix} m\n   * @returns {Matrix}\n   */\n  inputMatrixToRow(m) {\n    let self = this;\n    let into = new Matrix(m.columns, 1);\n    this.states.push({\n      left: m,\n      get right () {\n        return self.inputRow;\n      },\n      into: into,\n      forwardFn: _rowPluck,\n      backpropagationFn: _rowPluckB\n    });\n    return into;\n  }\n\n  /**\n   * connects a matrix to sigmoid\n   * @param {Matrix} m\n   * @returns {Matrix}\n   */\n  sigmoid(m) {\n    let into = new Matrix(m.rows, m.columns);\n    this.states.push({\n      left: m,\n      into: into,\n      forwardFn: _sigmoid,\n      backpropagationFn: _sigmoidB\n    });\n    return into;\n  }\n\n  /**\n   * connects a matrix to tanh\n   * @param {Matrix} m\n   * @returns {Matrix}\n   */\n  tanh(m) {\n    let into = new Matrix(m.rows, m.columns);\n    this.states.push({\n      left: m,\n      into: into,\n      forwardFn: _tanh,\n      backpropagationFn: _tanhB\n    });\n    return into;\n  }\n\n  observe(m) {\n    let iForward = 0;\n    let iBackpropagate = 0;\n    this.states.push({\n      forwardFn: function() {\n        iForward++;\n        console.log(m);\n      },\n      backpropagationFn: function() {\n        iBackpropagate++;\n        console.log(m);\n      }\n    });\n    return m;\n  }\n\n  /**\n   *\n   * @output {Matrix}\n   */\n  run(rowIndex) {\n    this.inputRow = rowIndex || 0;\n\n    let state;\n    for (let i = 0, max = this.states.length; i < max; i++) {\n      state = this.states[i];\n      if (!state.hasOwnProperty('forwardFn')) {\n        continue;\n      }\n      state.forwardFn(state.into, state.left, state.right);\n    }\n\n    return state.into;\n  }\n\n  /**\n   * @output {Matrix}\n   */\n  runBackpropagate() {\n    let i = this.states.length;\n    while (i-- > 0) {\n      let state = this.states[i];\n      if (!state.hasOwnProperty('backpropagationFn')) {\n        continue;\n      }\n      state.backpropagationFn(state.into, state.left, state.right);\n    }\n  }\n\n  updatePreviousResults() {\n    for (let i = 0, max = this.previousResults.length; i < max; i++) {\n      _copy(this.previousResultInputs[i], this.previousResults[i]);\n    }\n  }\n\n  copyPreviousResultsTo(equation) {\n    for (let i = 0, max = this.previousResults.length; i < max; i++) {\n      _copy(equation.previousResultInputs[i], this.previousResults[i]);\n    }\n  }\n\n  resetPreviousResults() {\n    for (let i = 0, max = this.previousResults.length; i < max; i++) {\n      let prev = this.previousResultInputs[i];\n      _copy(prev, new Matrix(prev.rows, 1));\n    }\n  }\n\n  addPreviousResult(m) {\n    this.previousResults.push(m);\n  }\n\n  toFunction() {\n    throw new Error('not yet implemented');\n    /*var lookupTable = [model.input, model.hiddenLayers, model.outputConnector, model.output];\n    var hiddenLayers = this.model.hiddenLayers;\n    for (var i = 0, max = hiddenLayers.length; i < max; i++) {\n      var hiddenLayer = hiddenLayers[i];\n      for (var p in hiddenLayer) {\n        lookupTable.push(hiddenLayer[p]);\n      }\n    }\n\n    var fowardFunctionList = [];\n    for (var i = 0, max = this.states.length; i++) {\n      var state = this.states[i];\n      if (!state.forwardFn) continue;\n      if (fowardFunctionList.indexOf(state.forwardFn) > -1) continue;\n      fowardFunctionList.push(state.forwardFn);\n    }\n\n    var connectorMatrices = [];\n    for (var i = 0, max = this.states.length; i++) {\n      var state = this.states[i];\n      if (!state.into) continue;\n      if (connectorMatrices.indexOf(state.into) > -1) continue;\n      connectorMatrices.push(state.into);\n    }\n\n    return new Function('rowIndex', '\\\n  inputRow = rowIndex || 0;\\\n\\\n      for (var i = 0, max = this.states.length; i < max; i++) {\\\n      var state = this.states[i];\\\n      if (!state.hasOwnProperty(\\'forwardFn\\')) {\\\n        continue;\\\n      }\\\n      state.forwardFn(state.into, state.left, state.right);\\\n    }\\\n\\\n    return state.into;\\\n');*/\n  }\n\n  toFunctionStates() {\n\n  }\n}\n"]}