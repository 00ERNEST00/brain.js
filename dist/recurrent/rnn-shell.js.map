{"version":3,"sources":["../../src/recurrent/rnn-shell.js"],"names":[],"mappings":"AAAA","file":"rnn-shell.js","sourcesContent":["/*function run() {\n  bindEquations: function() {\n    var model = this.model;\n    var hiddenSizes = this.hiddenSizes;\n    var hiddenLayers = model.hiddenLayers;\n\n    var equation = new Equation();\n    model.equations.push(equation);\n    // 0 index\n    var output = this.getEquation(equation, equation.inputMatrixToRow(this.model.input), hiddenSizes[0], hiddenLayers[0]);\n    equation.addPreviousResult(output);\n    // 1+ indexes\n    for (var i = 1, max = hiddenSizes.length; i < max; i++) {\n      output = this.getEquation(equation, output, hiddenSizes[i], hiddenLayers[i]);\n      equation.addPreviousResult(output);\n    }\n    equation.add(equation.multiply(model.outputConnector, output), model.output);\n  },\n\n  run: function(input) {\n    this.runs++;\n    input = input || this.model.input;\n    var equations = this.model.equations;\n    var max = input.length;\n    var log2ppl = 0;\n    var cost = 0;\n\n    for (var equationIndex = 0, equationMax = equations.length; equationIndex < equationMax; equationIndex++) {\n      equations[equationIndex].resetPreviousResults();\n    }\n\n    while (equations.length <= max) {\n      this.bindEquations();\n    }\n\n    for (var i = -1; i < max; i++) {\n      // start and end tokens are zeros\n      var equation = equations[i + 1];\n      var ixSource = (i === -1 ? 0 : input[i]); // first step: start with START token\n      var ixTarget = (i === max - 1 ? 0 : input[i + 1]); // last step: end with END token\n      var output = equation.run(ixSource);\n      if (equations[i + 2]) {\n        equation.copyPreviousResultsTo(equations[i + 2]);\n      }\n\n      // set gradients into log probabilities\n      this.logProbabilities = output; // interpret output as log probabilities\n      var probabilities = softmax(output); // compute the softmax probabilities\n\n      log2ppl += -Math.log2(probabilities.weights[ixTarget]); // accumulate base 2 log prob and do smoothing\n      cost += -Math.log(probabilities.weights[ixTarget]);\n\n      // write gradients into log probabilities\n      this.logProbabilities.recurrence = probabilities.weights.slice(0);\n      this.logProbabilities.recurrence[ixTarget] -= 1\n    }\n\n    while (i > -1) {\n      equations[i--].runBackpropagate();\n    }\n\n    this.step();\n\n    this.totalPerplexity = Math.pow(2, log2ppl / (max - 1));\n    this.totalCost = cost;\n    return output;\n  }\n}*/"]}