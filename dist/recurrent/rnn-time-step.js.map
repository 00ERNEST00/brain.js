{"version":3,"sources":["../../src/recurrent/rnn-time-step.js"],"names":["RNNTimeStep","options","defaults","p","hasOwnProperty","stepCache","runs","totalCost","ratioClipped","model","initialLayerInputs","hiddenSizes","map","size","inputLookup","outputLookup","initialize","input","hiddenLayers","output","equations","allMatrices","equationConnections","json","fromJSON","mapModel","push","getModel","inputSize","prevSize","d","length","hiddenSize","weight","transition","bias","equation","inputMatrix","previousResult","hiddenLayer","relu","sigmoid","bind","add","multiply","outputSize","lastHiddenSize","outputConnector","outputs","equationConnection","getEquation","i","max","createInputMatrix","Error","createHiddenLayers","hiddenMatrix","property","createOutputMatrix","learningRate","error","runInput","runBackpropagate","step","errorSum","bindEquation","inputIndex","current","next","weights","Math","abs","deltas","stepSize","regc","clipval","numClipped","numTot","matrixIndex","matrix","rows","columns","cache","r","w","decayRate","sqrt","smoothEps","maxPredictionLength","isSampleI","temperature","isRunnable","lastOutput","outputMatrix","logProbabilities","data","Object","assign","RnnTimeStep","trainDefaults","iterations","errorThresh","log","console","logPeriod","callback","callbackPeriod","Infinity","setupData","keepNetworkIntact","sum","j","err","trainPattern","isNaN","type","constructor","name","toJSON","layers","JSON","stringify","dataFormatter","parse","states","jsonString","matrixOrigin","m","stateIndex","state","previousConnectionIndex","left","right","product","connection","indexOf","matrixToString","toInner","fnString","toString","split","shift","join","pop","replace","fileName","fnName","value","toLowerCase","statesRaw","usedFunctionNames","innerFunctionsSwitch","forwardFn","src","toFunctionString","formatDataIn","formatDataOut","Function"],"mappings":"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","file":"rnn-time-step.js","sourcesContent":["import Matrix from './matrix';\nimport RandomMatrix from './matrix/random-matrix';\nimport Equation from './matrix/equation';\nimport sampleI from './matrix/sample-i';\nimport maxI from './matrix/max-i';\nimport softmax from './matrix/softmax';\nimport copy from './matrix/copy';\nimport { randomF } from '../utilities/random';\nimport zeros from '../utilities/zeros';\nimport DataFormatter from '../utilities/data-formatter';\n\nexport default class RNNTimeStep {\n  constructor(options = {}) {\n    const defaults = RNNTimeStep.defaults;\n\n    for (let p in defaults) {\n      if (!defaults.hasOwnProperty(p)) continue;\n      this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n    }\n\n    this.stepCache = {};\n    this.runs = 0;\n    this.totalCost = null;\n    this.ratioClipped = null;\n    this.model = null;\n\n    this.initialLayerInputs = this.hiddenSizes.map((size) => new Matrix(this.hiddenSizes[0], 1));\n    this.inputLookup = null;\n    this.outputLookup = null;\n    this.initialize();\n  }\n\n  initialize() {\n    this.model = {\n      input: null,\n      hiddenLayers: [],\n      output: null,\n      equations: [],\n      allMatrices: [],\n      equationConnections: []\n    };\n\n    if (this.json) {\n      this.fromJSON(this.json);\n    } else {\n      this.mapModel();\n    }\n  }\n\n  createHiddenLayers() {\n    let hiddenSizes = this.hiddenSizes;\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    //0 is end, so add 1 to offset\n    hiddenLayers.push(this.getModel(hiddenSizes[0], this.inputSize));\n    let prevSize = hiddenSizes[0];\n\n    for (let d = 1; d < hiddenSizes.length; d++) { // loop over depths\n      let hiddenSize = hiddenSizes[d];\n      hiddenLayers.push(this.getModel(hiddenSize, prevSize));\n      prevSize = hiddenSize;\n    }\n  }\n\n  /**\n   *\n   * @param {Number} hiddenSize\n   * @param {Number} prevSize\n   * @returns {object}\n   */\n  getModel(hiddenSize, prevSize) {\n    return {\n      //wxh\n      weight: new RandomMatrix(hiddenSize, prevSize, 0.08),\n      //whh\n      transition: new RandomMatrix(hiddenSize, hiddenSize, 0.08),\n      //bhh\n      bias: new Matrix(hiddenSize, 1)\n    };\n  }\n\n  /**\n   *\n   * @param {Equation} equation\n   * @param {Matrix} inputMatrix\n   * @param {Matrix} previousResult\n   * @param {Object} hiddenLayer\n   * @returns {Matrix}\n   */\n  getEquation(equation, inputMatrix, previousResult, hiddenLayer) {\n    let relu = equation.sigmoid.bind(equation);\n    let add = equation.add.bind(equation);\n    let multiply = equation.multiply.bind(equation);\n\n    return relu(\n      add(\n        add(\n          multiply(\n            hiddenLayer.weight,\n            inputMatrix\n          ),\n          multiply(\n            hiddenLayer.transition,\n            previousResult\n          )\n        ),\n        hiddenLayer.bias\n      )\n    );\n  }\n\n  createInputMatrix() {\n    //0 is end, so add 1 to offset\n    this.model.input = new RandomMatrix(1, this.inputSize, 0.08);\n  }\n\n  createOutputMatrix() {\n    let model = this.model;\n    let outputSize = this.outputSize;\n    let lastHiddenSize = this.hiddenSizes[this.hiddenSizes.length - 1];\n\n    //whd\n    model.outputConnector = new RandomMatrix(outputSize, lastHiddenSize, 0.08);\n    //bd\n    model.output = new Matrix(outputSize, 1);\n  }\n\n  bindEquation() {\n    let model = this.model;\n    let hiddenSizes = this.hiddenSizes;\n    let hiddenLayers = model.hiddenLayers;\n    let equation = new Equation();\n    let outputs = [];\n    let equationConnection = model.equationConnections.length > 0\n      ? model.equationConnections[model.equationConnections.length - 1]\n      : this.initialLayerInputs\n      ;\n\n      // 0 index\n    let output = this.getEquation(equation, equation.input(model.input), equationConnection[0], hiddenLayers[0]);\n    outputs.push(output);\n    // 1+ indices\n    for (let i = 1, max = hiddenSizes.length; i < max; i++) {\n      output = this.getEquation(equation, output, equationConnection[i], hiddenLayers[i]);\n      outputs.push(output);\n    }\n\n    model.equationConnections.push(outputs);\n    equation.add(equation.multiply(model.outputConnector, output), model.output);\n    model.equations.push(equation);\n  }\n\n  mapModel() {\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    let allMatrices = model.allMatrices;\n\n    this.createInputMatrix();\n    if (!model.input) throw new Error('net.model.input not set');\n    allMatrices.push(model.input);\n\n    this.createHiddenLayers();\n    if (!model.hiddenLayers.length) throw new Error('net.hiddenLayers not set');\n    for (let i = 0, max = hiddenLayers.length; i < max; i++) {\n      let hiddenMatrix = hiddenLayers[i];\n      for (let property in hiddenMatrix) {\n        if (!hiddenMatrix.hasOwnProperty(property)) continue;\n        allMatrices.push(hiddenMatrix[property]);\n      }\n    }\n\n    this.createOutputMatrix();\n    if (!model.outputConnector) throw new Error('net.model.outputConnector not set');\n    if (!model.output) throw new Error('net.model.output not set');\n\n    allMatrices.push(model.outputConnector);\n    allMatrices.push(model.output);\n  }\n\n  /**\n   *\n   * @param {Number[]} input\n   * @param {Number} [learningRate]\n   * @returns {number}\n   */\n  trainPattern(input, learningRate = null) {\n    const error = this.runInput(input);\n    this.runBackpropagate(input);\n    this.step(learningRate);\n    return error;\n  }\n\n  /**\n   *\n   * @param {Number[]} input\n   * @returns {number}\n   */\n  runInput(input) {\n    this.runs++;\n    let model = this.model;\n    let errorSum = 0;\n    let equation;\n    while (model.equations.length < input.length - 1) {\n      this.bindEquation();\n    }\n    const outputs = [];\n    for (let inputIndex = 0, max = input.length - 1; inputIndex < max; inputIndex++) {\n      // start and end tokens are zeros\n      equation = model.equations[inputIndex];\n\n      const current = input[inputIndex];\n      const next = input[inputIndex + 1];\n      const output = equation.runInput(current);\n      const error = output.weights[0] - next;\n\n      // set gradients into log probabilities\n      errorSum += Math.abs(error);\n\n      // write gradients into log probabilities\n      output.deltas[0] = error;\n      outputs.push(output.weights[0]);\n    }\n\n    //this.model.equations.length - 1;\n    this.totalCost = errorSum;\n    return errorSum;\n  }\n\n  runBackpropagate() {\n    for (let i = this.model.equations.length - 1; i > -1; i--) {\n      this.model.equations[i].runBackpropagate();\n    }\n  }\n\n  /**\n   *\n   * @param {Number} [learningRate]\n   */\n  step(learningRate = null) {\n    // perform parameter update\n    //TODO: still not sure if this is ready for learningRate\n    let stepSize = this.learningRate;\n    let regc = this.regc;\n    let clipval = this.clipval;\n    let model = this.model;\n    let numClipped = 0;\n    let numTot = 0;\n    let allMatrices = model.allMatrices;\n    for (let matrixIndex = 0; matrixIndex < allMatrices.length; matrixIndex++) {\n      const matrix = allMatrices[matrixIndex];\n      const { weights, deltas }  = matrix;\n      if (!(matrixIndex in this.stepCache)) {\n        this.stepCache[matrixIndex] = zeros(matrix.rows * matrix.columns);\n      }\n      const cache = this.stepCache[matrixIndex];\n      for (let i = 0; i < weights.length; i++) {\n        let r = deltas[i];\n        let w = weights[i];\n        // rmsprop adaptive learning rate\n        cache[i] = cache[i] * this.decayRate + (1 - this.decayRate) * r * r;\n        // gradient clip\n        if (r > clipval) {\n          r = clipval;\n          numClipped++;\n        }\n        if (r < -clipval) {\n          r = -clipval;\n          numClipped++;\n        }\n        numTot++;\n        // update (and regularize)\n        weights[i] = w + -stepSize * r / Math.sqrt(cache[i] + this.smoothEps) - regc * w;\n      }\n    }\n    this.ratioClipped = numClipped / numTot;\n  }\n\n\n  /**\n   *\n   * @returns boolean\n   */\n  get isRunnable(){\n    if(this.model.equations.length === 0){\n      console.error(`No equations bound, did you run train()?`);\n      return false;\n    }\n\n    return true;\n  }\n\n\n  /**\n   *\n   * @param {Number[]|*} [rawInput]\n   * @param {Number} [maxPredictionLength]\n   * @param {Boolean} [isSampleI]\n   * @param {Number} temperature\n   * @returns {*}\n   */\n  run(input = [], maxPredictionLength = 1, isSampleI = false, temperature = 1) {\n    if (!this.isRunnable) return null;\n    const model = this.model;\n    while (model.equations.length < maxPredictionLength) {\n      this.bindEquation();\n    }\n    let lastOutput;\n    for (let i = 0; i < input.length; i++) {\n      let outputMatrix = model.equations[i].runInput(input[i]);\n      let logProbabilities = new Matrix(model.output.rows, model.output.columns);\n      copy(logProbabilities, outputMatrix);\n      lastOutput = logProbabilities.weights[0];\n    }\n\n    /**\n     * we slice the input length here, not because output contains it, but it will be erroneous as we are sending the\n     * network what is contained in input, so the data is essentially guessed by the network what could be next, till it\n     * locks in on a value.\n     * Kind of like this, values are from input:\n     * 0 -> 4 (or in English: \"beginning on input\" -> \"I have no idea? I'll guess what they want next!\")\n     * 2 -> 2 (oh how interesting, I've narrowed down values...)\n     * 1 -> 9 (oh how interesting, I've now know what the values are...)\n     * then the output looks like: [4, 2, 9,...]\n     * so we then remove the erroneous data to get our true output\n     */\n    return lastOutput;\n  }\n\n  /**\n   *\n   * @param {Object[]|String[]} data an array of objects: `{input: 'string', output: 'string'}` or an array of strings\n   * @param {Object} [options]\n   * @returns {{error: number, iterations: number}}\n   */\n  train(data, options = {}) {\n    options = Object.assign({}, RnnTimeStep.trainDefaults, options);\n    let iterations = options.iterations;\n    let errorThresh = options.errorThresh;\n    let log = options.log === true ? console.log : options.log;\n    let logPeriod = options.logPeriod;\n    let learningRate = options.learningRate || this.learningRate;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod;\n    let error = Infinity;\n    let i;\n\n    if (this.hasOwnProperty('setupData')) {\n      data = this.setupData(data);\n    }\n\n    if (!options.keepNetworkIntact) {\n      this.initialize();\n    }\n\n    for (i = 0; i < iterations && error > errorThresh; i++) {\n      let sum = 0;\n      for (let j = 0; j < data.length; j++) {\n        let err = this.trainPattern(data[j], learningRate);\n        sum += err;\n      }\n      error = sum / data.length;\n      \n      if (isNaN(error)) throw new Error('network error rate is unexpected NaN, check network configurations and try again');\n      if (log && (i % logPeriod == 0)) {\n        log('iterations:', i, 'training error:', error);\n      }\n      if (callback && (i % callbackPeriod == 0)) {\n        callback({ error: error, iterations: i });\n      }\n    }\n\n    return {\n      error: error,\n      iterations: i\n    };\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @returns {Object}\n   */\n  toJSON() {\n    const defaults = RnnTimeStep.defaults;\n    let model = this.model;\n    let options = {};\n    for (let p in defaults) {\n      options[p] = this[p];\n    }\n\n    return {\n      type: this.constructor.name,\n      options: options,\n      input: model.input.toJSON(),\n      hiddenLayers: model.hiddenLayers.map((hiddenLayer) => {\n        let layers = {};\n        for (let p in hiddenLayer) {\n          layers[p] = hiddenLayer[p].toJSON();\n        }\n        return layers;\n      }),\n      outputConnector: this.model.outputConnector.toJSON(),\n      output: this.model.output.toJSON()\n    };\n  }\n\n  toJSONString() {\n    return JSON.stringify(this.toJSON());\n  }\n\n  fromJSON(json) {\n    this.json = json;\n    const defaults = RnnTimeStep.defaults;\n    let model = this.model;\n    let options = json.options;\n    let allMatrices = model.allMatrices;\n    model.input = Matrix.fromJSON(json.input);\n    allMatrices.push(model.input);\n    model.hiddenLayers = json.hiddenLayers.map((hiddenLayer) => {\n      let layers = {};\n      for (let p in hiddenLayer) {\n        layers[p] = Matrix.fromJSON(hiddenLayer[p]);\n        allMatrices.push(layers[p]);\n      }\n      return layers;\n    });\n    model.outputConnector = Matrix.fromJSON(json.outputConnector);\n    model.output = Matrix.fromJSON(json.output);\n    allMatrices.push(model.outputConnector);\n    allMatrices.push(model.output);\n\n    for (let p in defaults) {\n      if (!defaults.hasOwnProperty(p)) continue;\n      this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n    }\n\n    if (options.hasOwnProperty('dataFormatter') && options.dataFormatter !== null) {\n      this.dataFormatter = DataFormatter.fromJSON(options.dataFormatter);\n      delete options.dataFormatter;\n    }\n\n    this.bindEquation();\n  }\n\n  fromJSONString(json) {\n    return this.fromJSON(JSON.parse(json));\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    let model = this.model;\n    let equations = this.model.equations;\n    let equation = equations[1];\n    let states = equation.states;\n    let jsonString = JSON.stringify(this.toJSON());\n\n    function matrixOrigin(m, stateIndex) {\n      for (let i = 0, max = states.length; i < max; i++) {\n        let state = states[i];\n\n        if (i === stateIndex) {\n          let j = previousConnectionIndex(m);\n          switch (m) {\n            case state.left:\n              if (j > -1) {\n                return `typeof prevStates[${ j }] === 'object' ? prevStates[${ j }].product : new Matrix(${ m.rows }, ${ m.columns })`;\n              }\n            case state.right:\n              if (j > -1) {\n                return `typeof prevStates[${ j }] === 'object' ? prevStates[${ j }].product : new Matrix(${ m.rows }, ${ m.columns })`;\n              }\n            case state.product:\n              return `new Matrix(${ m.rows }, ${ m.columns })`;\n            default:\n              throw Error('unknown state');\n          }\n        }\n\n        if (m === state.product) return `states[${ i }].product`;\n        if (m === state.right) return `states[${ i }].right`;\n        if (m === state.left) return `states[${ i }].left`;\n      }\n    }\n\n    function previousConnectionIndex(m) {\n      const connection = model.equationConnections[0];\n      const states = equations[0].states;\n      for (let i = 0, max = states.length; i < max; i++) {\n        if (states[i].product === m) {\n          return i;\n        }\n      }\n      return connection.indexOf(m);\n    }\n\n    function matrixToString(m, stateIndex) {\n      if (!m || !m.rows || !m.columns) return 'null';\n\n      if (m === model.input) return `json.input`;\n      if (m === model.outputConnector) return `json.outputConnector`;\n      if (m === model.output) return `json.output`;\n\n      for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {\n        let hiddenLayer = model.hiddenLayers[i];\n        for (let p in hiddenLayer) {\n          if (!hiddenLayer.hasOwnProperty(p)) continue;\n          if (hiddenLayer[p] !== m) continue;\n          return `json.hiddenLayers[${ i }].${ p }`;\n        }\n      }\n\n      return matrixOrigin(m, stateIndex);\n    }\n\n    function toInner(fnString) {\n      // crude, but should be sufficient for now\n      // function() { body }\n      fnString = fnString.toString().split('{');\n      fnString.shift();\n      // body }\n      fnString = fnString.join('{');\n      fnString = fnString.split('}');\n      fnString.pop();\n      // body\n      return fnString.join('}').split('\\n').join('\\n        ')\n        .replace('product.deltas[i] = 0;', '')\n        .replace('product.deltas[column] = 0;', '')\n        .replace('left.deltas[leftIndex] = 0;', '')\n        .replace('right.deltas[rightIndex] = 0;', '')\n        .replace('product.deltas = left.deltas.slice(0);', '');\n    }\n\n    function fileName(fnName) {\n      return `src/recurrent/matrix/${ fnName.replace(/[A-Z]/g, function(value) { return '-' + value.toLowerCase(); }) }.js`;\n    }\n\n    let statesRaw = [];\n    let usedFunctionNames = {};\n    let innerFunctionsSwitch = [];\n    for (let i = 0, max = states.length; i < max; i++) {\n      let state = states[i];\n      statesRaw.push(`states[${ i }] = {\n      name: '${ state.forwardFn.name }',\n      left: ${ matrixToString(state.left, i) },\n      right: ${ matrixToString(state.right, i) },\n      product: ${ matrixToString(state.product, i) }\n    }`);\n\n      let fnName = state.forwardFn.name;\n      if (!usedFunctionNames[fnName]) {\n        usedFunctionNames[fnName] = true;\n        innerFunctionsSwitch.push(\n          `        case '${ fnName }': //compiled from ${ fileName(fnName) }\n          ${ toInner(state.forwardFn.toString()) }\n          break;`\n        );\n      }\n    }\n\n    const src = `\n  if (typeof rawInput === 'undefined') rawInput = [];\n  if (typeof maxPredictionLength === 'undefined') maxPredictionLength = 100;\n  if (typeof isSampleI === 'undefined') isSampleI = false;\n  if (typeof temperature === 'undefined') temperature = 1;\n  ${ (this.dataFormatter !== null) ? this.dataFormatter.toFunctionString() : '' }\n  \n  var input = ${\n      (this.dataFormatter !== null && typeof this.formatDataIn === 'function')\n        ? 'formatDataIn(rawInput)' \n        : 'rawInput'\n    };\n  var json = ${ jsonString };\n  var _i = 0;\n  var output = [];\n  var states = [];\n  var prevStates;\n  while (true) {\n    var previousIndex = _i < input.length\n          ? input[_i - 1]\n          : output[_i - 1])\n          ;\n    var rowPluckIndex = previousIndex;\n    prevStates = states;\n    states = [];\n    ${ statesRaw.join(';\\n    ') };\n    for (var stateIndex = 0, stateMax = ${ statesRaw.length }; stateIndex < stateMax; stateIndex++) {\n      var state = states[stateIndex];\n      var product = state.product;\n      var left = state.left;\n      var right = state.right;\n      \n      switch (state.name) {\n${ innerFunctionsSwitch.join('\\n') }\n      }\n    }\n    \n    var logProbabilities = state.product;\n    if (temperature !== 1 && isSampleI) {\n      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {\n        logProbabilities.weights[q] /= temperature;\n      }\n    }\n\n    var probs = softmax(logProbabilities);\n    var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);\n    \n    _i++;\n    if (nextIndex === 0) {\n      break;\n    }\n    if (_i >= maxPredictionLength) {\n      break;\n    }\n\n    output.push(nextIndex);\n  }\n  ${ (this.dataFormatter !== null && typeof this.formatDataOut === 'function') \n      ? 'return formatDataOut(input, output.slice(input.length).map(function(value) { return value - 1; }))'\n      : 'return output.slice(input.length).map(function(value) { return value - 1; })' };\n  function Matrix(rows, columns) {\n    this.rows = rows;\n    this.columns = columns;\n    this.weights = zeros(rows * columns);\n  }\n  ${ this.dataFormatter !== null && typeof this.formatDataIn === 'function'\n      ? `function formatDataIn(input, output) { ${\n          toInner(this.formatDataIn.toString())\n            .replace(/this[.]dataFormatter[\\n\\s]+[.]/g, '')\n            .replace(/this[.]dataFormatter[.]/g, '')\n            .replace(/this[.]dataFormatter/g, 'true')\n        } }`\n      : '' }\n  ${ this.dataFormatter !== null && typeof this.formatDataOut === 'function'\n        ? `function formatDataOut(input, output) { ${\n            toInner(this.formatDataOut.toString())\n              .replace(/this[.]dataFormatter[\\n\\s]+[.]/g, '')\n              .replace(/this[.]dataFormatter[.]/g, '')\n              .replace(/this[.]dataFormatter/g, 'true')\n          } }` \n        : '' }\n  ${ zeros.toString() }\n  ${ softmax.toString().replace('_2.default', 'Matrix') }\n  ${ randomF.toString() }\n  ${ sampleI.toString() }\n  ${ maxI.toString() }`;\n    return new Function('rawInput', 'maxPredictionLength', 'isSampleI', 'temperature', src);\n  }\n}\n\nRnnTimeStep.defaults = {\n  inputSize: 1,\n  hiddenSizes:[20],\n  outputSize: 1,\n  learningRate: 0.01,\n  decayRate: 0.999,\n  smoothEps: 1e-8,\n  regc: 0.000001,\n  clipval: 5,\n  json: null,\n  dataFormatter: null\n};\n\nRnnTimeStep.trainDefaults = {\n  iterations: 20000,\n  errorThresh: 0.005,\n  log: false,\n  logPeriod: 10,\n  learningRate: 0.3,\n  callback: null,\n  callbackPeriod: 10,\n  keepNetworkIntact: false\n};"]}