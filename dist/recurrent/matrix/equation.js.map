{"version":3,"sources":["../../../src/recurrent/matrix/equation.js"],"names":["Equation","inputRow","states","previousResults","previousResultInputs","allMatrices","size","product","push","self","i","parseInt","length","left","backpropagationFn","m","weights","Error","right","rows","columns","forwardFn","add","allOnes","cloneNegative","iForward","iBackpropagate","rowIndex","state","max","hasOwnProperty"],"mappings":"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","file":"equation.js","sourcesContent":["import Matrix from './';\nimport OnesMatrix from './ones-matrix';\nimport copy from './copy';\nimport cloneNegative from './clone-negative';\nimport add from './add';\nimport addB from './add-b';\nimport allOnes from './all-ones';\nimport multiply from './multiply';\nimport multiplyB from './multiply-b';\nimport multiplyElement from './multiply-element';\nimport multiplyElementB from './multiply-element-b';\nimport relu from './relu';\nimport reluB from './relu-b';\nimport rowPluck from './row-pluck';\nimport rowPluckB from './row-pluck-b';\nimport sigmoid from './sigmoid';\nimport sigmoidB from './sigmoid-b';\nimport tanh from './tanh';\nimport tanhB from './tanh-b';\n\nexport default class Equation {\n  constructor() {\n    this.inputRow = 0;\n    this.states = [];\n    this.previousResults = [];\n    this.previousResultInputs = [];\n    this.allMatrices = [];\n  }\n\n  /**\n   *\n   * @param {Number} size\n   * @returns {Matrix}\n   */\n  previousResult(size) {\n    let product = new Matrix(size, 1);\n    this.allMatrices.push(product);\n    let self = this;\n    let i = parseInt(this.previousResults.length);\n    this.previousResultInputs.push(product);\n\n    this.states.push({\n      product: product,\n      get left() {\n        return self.previousResults[i];\n      },\n      backpropagationFn: copy\n    });\n\n    return product;\n  }\n\n  result(m) {\n    if (m.weights.length !== this.previousResultInputs[this.previousResultInputs.length - 1].weights.length) {\n      throw new Error('misaligned matrices');\n    }\n    this.previousResults.push(m);\n    if (this.previousResults.length !== this.previousResultInputs.length) {\n      throw new Error('previousResults does not match size of previousResultInputs');\n    }\n    return m;\n  }\n\n  /**\n   * connects two matrices together by add\n   * @param {Matrix} left\n   * @param {Matrix} right\n   * @returns {Matrix}\n   */\n  add(left, right) {\n    if (left.weights.length !== right.weights.length) {\n      throw new Error('misaligned matrices');\n    }\n    let product = new Matrix(left.rows, left.columns);\n    this.allMatrices.push(product);\n    this.states.push({\n      left: left,\n      right: right,\n      product: product,\n      forwardFn: add,\n      backpropagationFn: addB\n    });\n    return product;\n  }\n\n  /**\n   *\n   * @param {Number} rows\n   * @param {Number} columns\n   * @returns {Matrix}\n   */\n  allOnes(rows, columns) {\n    let product = new Matrix(rows, columns);\n    this.allMatrices.push(product);\n    this.states.push({\n      left: product,\n      product: product,\n      forwardFn: allOnes\n    });\n    return product;\n  }\n\n  /**\n   *\n   * @param {Matrix} m\n   * @returns {Matrix}\n   */\n  cloneNegative(m) {\n    let product = new Matrix(m.rows, m.columns);\n    this.allMatrices.push(product);\n    this.states.push({\n      left: m,\n      product: product,\n      forwardFn: cloneNegative\n    });\n    return product;\n  }\n\n  /**\n   * connects two matrices together by subtract\n   * @param {Matrix} left\n   * @param {Matrix} right\n   * @returns {Matrix}\n   */\n  subtract(left, right) {\n    if (left.weights.length !== right.weights.length) {\n      throw new Error('misaligned matrices');\n    }\n    return this.add(this.add(this.allOnes(left.rows, left.columns), this.cloneNegative(left)), right);\n  }\n\n  /**\n   * connects two matrices together by multiply\n   * @param {Matrix} left\n   * @param {Matrix} right\n   * @returns {Matrix}\n   */\n  multiply(left, right) {\n    if (left.columns !== right.rows) {\n      throw new Error('misaligned matrices');\n    }\n    let product = new Matrix(left.rows, right.columns);\n    this.allMatrices.push(product);\n    this.states.push({\n      left: left,\n      right: right,\n      product: product,\n      forwardFn: multiply,\n      backpropagationFn: multiplyB\n    });\n    return product;\n  }\n\n  /**\n   * connects two matrices together by multiplyElement\n   * @param {Matrix} left\n   * @param {Matrix} right\n   * @returns {Matrix}\n   */\n  multiplyElement(left, right) {\n    if (left.weights.length !== right.weights.length) {\n      throw new Error('misaligned matrices');\n    }\n    let product = new Matrix(left.rows, left.columns);\n    this.allMatrices.push(product);\n    this.states.push({\n      left: left,\n      right: right,\n      product: product,\n      forwardFn: multiplyElement,\n      backpropagationFn: multiplyElementB\n    });\n    return product;\n  }\n\n  /**\n   * connects a matrix to relu\n   * @param {Matrix} m\n   * @returns {Matrix}\n   */\n  relu(m) {\n    let product = new Matrix(m.rows, m.columns);\n    this.allMatrices.push(product);\n    this.states.push({\n      left: m,\n      product: product,\n      forwardFn: relu,\n      backpropagationFn: reluB\n    });\n    return product;\n  }\n\n  /**\n   * connects a matrix via a row\n   * @param {Matrix} m\n   * @returns {Matrix}\n   */\n  inputMatrixToRow(m) {\n    let self = this;\n    let product = new Matrix(m.columns, 1);\n    this.allMatrices.push(product);\n    this.states.push({\n      left: m,\n      get right () {\n        return self.inputRow;\n      },\n      product: product,\n      forwardFn: rowPluck,\n      backpropagationFn: rowPluckB\n    });\n    return product;\n  }\n\n  /**\n   * connects a matrix to sigmoid\n   * @param {Matrix} m\n   * @returns {Matrix}\n   */\n  sigmoid(m) {\n    let product = new Matrix(m.rows, m.columns);\n    this.allMatrices.push(product);\n    this.states.push({\n      left: m,\n      product: product,\n      forwardFn: sigmoid,\n      backpropagationFn: sigmoidB\n    });\n    return product;\n  }\n\n  /**\n   * connects a matrix to tanh\n   * @param {Matrix} m\n   * @returns {Matrix}\n   */\n  tanh(m) {\n    let product = new Matrix(m.rows, m.columns);\n    this.allMatrices.push(product);\n    this.states.push({\n      left: m,\n      product: product,\n      forwardFn: tanh,\n      backpropagationFn: tanhB\n    });\n    return product;\n  }\n\n  /**\n   *\n   * @param m\n   * @returns {Matrix}\n   */\n  observe(m) {\n    let iForward = 0;\n    let iBackpropagate = 0;\n    this.states.push({\n      forwardFn: function() {\n        iForward++;\n      },\n      backpropagationFn: function() {\n        iBackpropagate++;\n      }\n    });\n    return m;\n  }\n\n  /**\n   * @patam {Number} [rowIndex]\n   * @output {Matrix}\n   */\n  run(rowIndex = 0) {\n    this.inputRow = rowIndex;\n    let state;\n    for (let i = 0, max = this.states.length; i < max; i++) {\n      state = this.states[i];\n      if (!state.hasOwnProperty('forwardFn')) {\n        continue;\n      }\n      state.forwardFn(state.product, state.left, state.right);\n    }\n\n    return state.product;\n  }\n\n  /**\n   * @patam {Number} [rowIndex]\n   * @output {Matrix}\n   */\n  runBackpropagate(rowIndex = 0) {\n    this.inputRow = rowIndex;\n\n    let i = this.states.length;\n    let state;\n    while (i-- > 0) {\n      state = this.states[i];\n      if (!state.hasOwnProperty('backpropagationFn')) {\n        continue;\n      }\n      state.backpropagationFn(state.product, state.left, state.right);\n    }\n\n    return state.product;\n  }\n}\n"]}