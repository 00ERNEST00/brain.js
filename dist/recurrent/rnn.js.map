{"version":3,"sources":["../../src/recurrent/rnn.js"],"names":["defaults","isBackPropagate","inputSize","inputRange","hiddenSizes","outputSize","learningRate","decayRate","smoothEps","regc","clipval","json","RNN","options","p","hasOwnProperty","stepCache","runs","totalPerplexity","totalCost","ratioClipped","model","input","hiddenLayers","output","equations","allMatrices","fromJSON","mapModel","push","getModel","prevSize","d","length","hiddenSize","weight","transition","bias","equation","inputMatrix","size","hiddenLayer","relu","bind","add","multiply","previousResult","result","lastHiddenSize","outputConnector","getEquation","inputMatrixToRow","i","max","concat","createInputMatrix","Error","createHiddenLayers","hiddenMatrix","property","createOutputMatrix","train","runBackpropagate","step","prediction","predict","log2ppl","cost","bindEquation","ixSource","ixTarget","run","logProbabilities","probabilities","Math","log2","weights","log","recurrence","pow","stepSize","numClipped","numTot","matrixIndexes","matrixIndex","matrix","rows","columns","cache","n","mdwi","sqrt","predictionLength","_sampleI","temperature","ix","lh","q","nq","probs","outputs","layer","outputLayer","node","sizes","sum","biases","k","exp","target","data","type","constructor","name","toJSON","map","layers","states","modelAsString","JSON","stringify","matrixOrigin","m","requestedStateIndex","state","product","left","right","matrixToString","stateIndex","toInner","fnString","toString","split","shift","join","pop","fileName","fnName","replace","value","toLowerCase","statesRaw","usedFunctionNames","innerFunctionsSwitch","forwardFn","Function"],"mappings":"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","file":"rnn.js","sourcesContent":["import Matrix from './matrix';\nimport sampleI from './matrix/sample-i';\nimport maxI from './matrix/max-i';\nimport RandomMatrix from './matrix/random-matrix';\nimport softmax from './matrix/softmax';\nimport Equation from './matrix/equation';\nimport copy from './matrix/copy';\n\nconst defaults = {\n  isBackPropagate: true,\n  // hidden size should be a list\n  inputSize: 20,\n  inputRange: 20,\n  hiddenSizes:[20,20],\n  outputSize: 20,\n  learningRate: 0.01,\n  decayRate: 0.999,\n  smoothEps: 1e-8,\n  regc: 0.000001,\n  clipval: 5,\n  json: null\n};\n\nexport default class RNN {\n  constructor(options) {\n    options = options || {};\n\n    for (let p in defaults) {\n      if (defaults.hasOwnProperty(p) && p !== 'isBackPropagate') {\n        this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n      }\n    }\n\n    this.stepCache = {};\n    this.runs = 0;\n    this.totalPerplexity = null;\n    this.totalCost = null;\n    this.ratioClipped = null;\n\n    this.model = {\n      input: null,\n      hiddenLayers: [],\n      output: null,\n      equations: [],\n      allMatrices: []\n    };\n\n    if (this.json) {\n      this.fromJSON(this.json);\n    } else {\n      this.mapModel();\n    }\n  }\n\n  createHiddenLayers() {\n    let hiddenSizes = this.hiddenSizes;\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    //0 is end, so add 1 to offset\n    hiddenLayers.push(this.getModel(hiddenSizes[0], this.inputSize));\n    let prevSize = hiddenSizes[0];\n\n    for (let d = 1; d < hiddenSizes.length; d++) { // loop over depths\n      let hiddenSize = hiddenSizes[d];\n      hiddenLayers.push(this.getModel(hiddenSize, prevSize));\n      prevSize = hiddenSize;\n    }\n  }\n\n  getModel(hiddenSize, prevSize) {\n    return {\n      //wxh\n      weight: new RandomMatrix(hiddenSize, prevSize, 0.08),\n      //whh\n      transition: new RandomMatrix(hiddenSize, hiddenSize, 0.08),\n      //bhh\n      bias: new Matrix(hiddenSize, 1)\n    };\n  }\n\n  /**\n   *\n   * @param {Equation} equation\n   * @param {Matrix} inputMatrix\n   * @param {Number} size\n   * @param {Object} hiddenLayer\n   * @returns {Matrix}\n   */\n  getEquation(equation, inputMatrix, size, hiddenLayer) {\n    let relu = equation.relu.bind(equation);\n    let add = equation.add.bind(equation);\n    let multiply = equation.multiply.bind(equation);\n    let previousResult = equation.previousResult.bind(equation);\n    let result = equation.result.bind(equation);\n\n    return result(\n      relu(\n        add(\n          add(\n            multiply(\n              hiddenLayer.weight,\n              inputMatrix\n            ),\n            multiply(\n              hiddenLayer.transition,\n              previousResult(size)\n            )\n          ),\n          hiddenLayer.bias\n        )\n      )\n    );\n  }\n\n  createInputMatrix() {\n    //0 is end, so add 1 to offset\n    this.model.input = new RandomMatrix(this.inputRange + 1, this.inputSize, 0.08);\n  }\n\n  createOutputMatrix() {\n    let model = this.model;\n    let outputSize = this.outputSize;\n    let lastHiddenSize = this.hiddenSizes[this.hiddenSizes.length - 1];\n\n    //0 is end, so add 1 to offset\n    //whd\n    model.outputConnector = new RandomMatrix(outputSize + 1, lastHiddenSize, 0.08);\n    //0 is end, so add 1 to offset\n    //bd\n    model.output = new Matrix(outputSize + 1, 1);\n  }\n\n  bindEquation() {\n    let model = this.model;\n    let hiddenSizes = this.hiddenSizes;\n    let hiddenLayers = model.hiddenLayers;\n    let equation = new Equation();\n      // 0 index\n    let output = this.getEquation(equation, equation.inputMatrixToRow(model.input), hiddenSizes[0], hiddenLayers[0]);\n    // 1+ indexes\n    for (let i = 1, max = hiddenSizes.length; i < max; i++) {\n      output = this.getEquation(equation, output, hiddenSizes[i], hiddenLayers[i]);\n    }\n    equation.add(equation.multiply(model.outputConnector, output), model.output);\n    model.allMatrices = model.allMatrices.concat(equation.allMatrices);\n    model.equations.push(equation);\n  }\n\n  mapModel() {\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    let allMatrices = model.allMatrices;\n\n    this.createInputMatrix();\n    if (!model.input) throw new Error('net.model.input not set');\n    allMatrices.push(model.input);\n\n    this.createHiddenLayers();\n    if (!model.hiddenLayers.length) throw new Error('net.hiddenLayers not set');\n    for (let i = 0, max = hiddenLayers.length; i < max; i++) {\n      let hiddenMatrix = hiddenLayers[i];\n      for (let property in hiddenMatrix) {\n        if (!hiddenMatrix.hasOwnProperty(property)) continue;\n        allMatrices.push(hiddenMatrix[property]);\n      }\n    }\n\n    this.createOutputMatrix();\n    if (!model.outputConnector) throw new Error('net.model.outputConnector not set');\n    if (!model.output) throw new Error('net.model.output not set');\n\n    allMatrices.push(model.outputConnector);\n    allMatrices.push(model.output);\n  }\n\n  run(input) {\n    this.train(input);\n    this.runBackpropagate(input);\n    this.step(input);\n  }\n\n  runPredict() {\n    let prediction = this.predict();\n    this.runBackpropagate(prediction);\n    this.step(prediction);\n    return prediction;\n  }\n\n  train(input) {\n    this.runs++;\n    let model = this.model;\n    let max = input.length;\n    let log2ppl = 0;\n    let cost = 0;\n\n    let i;\n    let equation;\n    while (model.equations.length <= input.length + 1) {//first and last are zeros\n      this.bindEquation();\n    }\n    for (i = -1; i < max; i++) {\n      // start and end tokens are zeros\n      equation = model.equations[i + 1];\n\n      let ixSource = (i === -1 ? 0 : input[i] + 1); // first step: start with START token\n      let ixTarget = (i === max - 1 ? 0 : input[i + 1] + 1); // last step: end with END token\n      let output = equation.run(ixSource);\n      // set gradients into log probabilities\n      let logProbabilities = output; // interpret output as log probabilities\n      let probabilities = softmax(output); // compute the softmax probabilities\n\n      log2ppl += -Math.log2(probabilities.weights[ixTarget]); // accumulate base 2 log prob and do smoothing\n      cost += -Math.log(probabilities.weights[ixTarget]);\n\n      // write gradients into log probabilities\n      logProbabilities.recurrence = probabilities.weights;\n      logProbabilities.recurrence[ixTarget] -= 1\n    }\n\n    this.totalPerplexity = Math.pow(2, log2ppl / (max - 1));\n    this.totalCost = cost;\n  }\n\n  runBackpropagate(input) {\n    var i = input.length + 0;\n    var model = this.model;\n    var equations = model.equations;\n    while(i > 0) {\n      equations[i].runBackpropagate(input[i - 1] + 1);\n      i--;\n    }\n    equations[0].runBackpropagate(0);\n  }\n\n  step() {\n    // perform parameter update\n    let stepSize = this.learningRate;\n    let regc = this.regc;\n    let clipval = this.clipval;\n    let model = this.model;\n    let numClipped = 0;\n    let numTot = 0;\n    let allMatrices = model.allMatrices;\n    let matrixIndexes = allMatrices.length;\n    for (let matrixIndex = 0; matrixIndex < matrixIndexes; matrixIndex++) {\n      let matrix = allMatrices[matrixIndex];\n      if (!(matrixIndex in this.stepCache)) {\n        this.stepCache[matrixIndex] = new Matrix(matrix.rows, matrix.columns);\n      }\n      let cache = this.stepCache[matrixIndex];\n\n      for (let i = 0, n = matrix.weights.length; i < n; i++) {\n        // rmsprop adaptive learning rate\n        let mdwi = matrix.recurrence[i];\n        cache.weights[i] = cache.weights[i] * this.decayRate + (1 - this.decayRate) * mdwi * mdwi;\n        // gradient clip\n        if (mdwi > clipval) {\n          mdwi = clipval;\n          numClipped++;\n        }\n        if (mdwi < -clipval) {\n          mdwi = -clipval;\n          numClipped++;\n        }\n        numTot++;\n\n        // update (and regularize)\n        matrix.weights[i] = matrix.weights[i] + -stepSize * mdwi / Math.sqrt(cache.weights[i] + this.smoothEps) - regc * matrix.weights[i];\n        matrix.recurrence[i] = 0; // reset gradients for next iteration\n      }\n    }\n    this.ratioClipped = numClipped / numTot;\n  }\n\n  predict(predictionLength, _sampleI, temperature) {\n    if (typeof _sampleI === 'undefined') { _sampleI = false; }\n    if (typeof temperature === 'undefined') { temperature = 1; }\n    if (typeof predictionLength === 'undefined') { predictionLength = 100; }\n    let model = this.model;\n    let result = [];\n    let ix;\n    let equation;\n    let i = 0;\n    while (model.equations.length < predictionLength) {\n      this.bindEquation();\n    }\n    let output = new Matrix(model.output.rows, model.output.columns);\n    while (true) {\n      ix = result.length === 0 ? 0 : result[result.length - 1];\n      equation = model.equations[i];\n      copy(output, equation.run(ix));\n      let lh = output;\n      // sample predicted letter\n      let logProbabilities = lh;\n      if (temperature !== 1 && _sampleI) {\n        // scale log probabilities by temperature and renormalize\n        // if temperature is high, logprobs will go towards zero\n        // and the softmax outputs will be more diffuse. if temperature is\n        // very low, the softmax outputs will be more peaky\n        for (let q = 0, nq = logProbabilities.weights.length; q < nq; q++) {\n          logProbabilities.weights[q] /= temperature;\n        }\n      }\n\n      let probs = softmax(logProbabilities);\n\n      if (_sampleI) {\n        ix = sampleI(probs);\n      } else {\n        ix = maxI(probs);\n      }\n\n      i++;\n      if (ix === 0) {\n        // END token predicted, break out\n        break;\n      }\n      if (i >= predictionLength) {\n        // something is wrong\n        break;\n      }\n\n      result.push(ix);\n    }\n\n    return result;\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  runInput(input) {\n    this.outputs[0] = input;  // set output state of input layer\n\n    let output = null;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let weights = this.weights[layer][node];\n\n        let sum = this.biases[layer][node];\n        for (let k = 0; k < weights.length; k++) {\n          sum += weights[k] * input[k];\n        }\n        this.outputs[layer][node] = 1 / (1 + Math.exp(-sum));\n      }\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  /**\n   *\n   * @param data\n   * @param options\n   * @returns {{error: number, iterations: number}}\n   */\n  /*train(data, options) {\n    throw new Error('not yet implemented');\n    //data = this.formatData(data);\n\n    options = options || {};\n    let iterations = options.iterations || 20000;\n    let errorThresh = options.errorThresh || 0.005;\n    let log = options.log ? (typeof options.log === 'function' ? options.log : console.log) : false;\n    let logPeriod = options.logPeriod || 10;\n    let learningRate = options.learningRate || this.learningRate || 0.3;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod || 10;\n    let sizes = [];\n    let inputSize = data[0].input.length;\n    let outputSize = data[0].output.length;\n    let hiddenSizes = this.hiddenSizes;\n    if (!hiddenSizes) {\n      sizes.push(Math.max(3, Math.floor(inputSize / 2)));\n    } else {\n      hiddenSizes.forEach(function(size) {\n        sizes.push(size);\n      });\n    }\n\n    sizes.unshift(inputSize);\n    sizes.push(outputSize);\n\n    //this.initialize(sizes, options.keepNetworkIntact);\n\n    let error = 1;\n    for (let i = 0; i < iterations && error > errorThresh; i++) {\n      let sum = 0;\n      for (let j = 0; j < data.length; j++) {\n        let err = this.trainPattern(data[j].input, data[j].output, learningRate);\n        sum += err;\n      }\n      error = sum / data.length;\n\n      if (log && (i % logPeriod == 0)) {\n        log('iterations:', i, 'training error:', error);\n      }\n      if (callback && (i % callbackPeriod == 0)) {\n        callback({ error: error, iterations: i });\n      }\n    }\n\n    return {\n      error: error,\n      iterations: i\n    };\n  }*/\n\n  /**\n   *\n   * @param input\n   * @param target\n   * @param learningRate\n   */\n  trainPattern(input, target, learningRate) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltas(target) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param learningRate\n   */\n  adjustWeights(learningRate) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {*}\n   */\n  formatData(data) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    throw new Error('not yet implemented');\n  }\n\n  toJSON() {\n    let model = this.model;\n    let options = {};\n    for (let p in defaults) {\n      options[p] = this[p];\n    }\n\n    return {\n      type: this.constructor.name,\n      options: options,\n      input: model.input.toJSON(),\n      hiddenLayers: model.hiddenLayers.map(function(hiddenLayer) {\n        let layers = {};\n        for (let p in hiddenLayer) {\n          layers[p] = hiddenLayer[p].toJSON();\n        }\n        return layers;\n      }),\n      outputConnector: this.model.outputConnector.toJSON(),\n      output: this.model.output.toJSON()\n    };\n  }\n\n  fromJSON(json) {\n    this.json = json;\n    let model = this.model;\n    let options = json.options;\n    let allMatrices = model.allMatrices;\n    model.input = Matrix.fromJSON(json.input);\n    allMatrices.push(model.input);\n    model.hiddenLayers = json.hiddenLayers.map(function(hiddenLayer) {\n      let layers = {};\n      for (let p in hiddenLayer) {\n        layers[p] = Matrix.fromJSON(hiddenLayer[p]);\n        allMatrices.push(layers[p]);\n      }\n      return layers;\n    });\n    model.outputConnector = Matrix.fromJSON(json.outputConnector);\n    model.output = Matrix.fromJSON(json.output);\n    allMatrices.push(model.outputConnector, model.output);\n\n    for (let p in defaults) {\n      if (defaults.hasOwnProperty(p) && p !== 'isBackPropagate') {\n        this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n      }\n    }\n\n    this.bindEquation();\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    let model = this.model;\n    let equation = this.model.equations[0];\n    let states = equation.states;\n    let modelAsString = JSON.stringify(this.toJSON());\n\n    function matrixOrigin(m, requestedStateIndex) {\n      for (let i = 0, max = states.length; i < max; i++) {\n        let state = states[i];\n\n        if (i === requestedStateIndex) {\n          switch (m) {\n            case state.product:\n            case state.left:\n            case state.right:\n              return `new Matrix(${ m.rows }, ${ m.columns })`;\n          }\n        }\n\n        if (m === state.product) return `states[${ i }].product`;\n        if (m === state.right) return `states[${ i }].right`;\n        if (m === state.left) return `states[${ i }].left`;\n      }\n    }\n\n    function matrixToString(m, stateIndex) {\n      if (!m) return 'null';\n\n      for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {\n        let hiddenLayer = model.hiddenLayers[i];\n        for (let p in hiddenLayer) {\n          if (hiddenLayer[p] === m) {\n            return `model.hiddenLayers[${ i }].${ p }`;\n          }\n        }\n      }\n      if (m === model.input) return `model.input`;\n      if (m === model.outputConnector) return `model.outputConnector`;\n      if (m === model.output) return `model.output`;\n      return matrixOrigin(m, stateIndex);\n    }\n\n    function toInner(fnString) {\n      //crude, but should be sufficient for now\n      //function() { inner.function.string.here; }\n      fnString = fnString.toString().split('{');\n      fnString.shift();\n      // inner.function.string.here; }\n      fnString = fnString.join('{');\n      fnString = fnString.split('}');\n      fnString.pop();\n      // inner.function.string.here;\n      return fnString.join('}');\n    }\n\n    function fileName(fnName) {\n      return `src/recurrent/matrix/${ fnName.replace(/[A-Z]/g, function(value) { return '-' + value.toLowerCase(); }) }.js`;\n    }\n\n    let statesRaw = [];\n    let usedFunctionNames = {};\n    let innerFunctionsSwitch = [];\n    for (let i = 0, max = states.length; i < max; i++) {\n      let state = states[i];\n      statesRaw.push(`states[${ i }] = {\n        name: '${ state.forwardFn.name }',\n        left: ${ matrixToString(state.left, i) },\n        right: ${ matrixToString(state.right, i) },\n        product: ${ matrixToString(state.product, i) }\n      };`);\n\n      let fnName = state.forwardFn.name;\n      if (!usedFunctionNames[fnName]) {\n        usedFunctionNames[fnName] = true;\n        innerFunctionsSwitch.push(`\n        case '${ fnName }': //compiled from ${ fileName(fnName) }\n          ${ toInner(state.forwardFn.toString()) }\n          break;\n        `);\n      }\n    }\n\n    return new Function('input', `\n      var model = ${ modelAsString };\n      \n      function Matrix(rows, columns) {\n        this.rows = rows;\n        this.columns = columns;\n        this.weights = zeros(rows * columns);\n        this.recurrence = zeros(rows * columns);\n      }\n      \n      function zeros(size) {\n        if (typeof Float64Array !== 'undefined') return new Float64Array(size);\n        var array = new Array(size);\n        for (var i = 0; i < size; i++) {\n          array[i] = 0;\n        }\n        return array;\n      }\n      \n      for (var inputIndex = 0, inputMax = input.length; inputIndex < inputMax; inputIndex++) {\n        var ixSource = (inputIndex === -1 ? 0 : input[inputIndex]); // first step: start with START token\n        var ixTarget = (inputIndex === inputMax - 1 ? 0 : input[inputIndex + 1]); // last step: end with END token\n        var rowPluckIndex = inputIndex; //connect up to rowPluck\n        var states = {};\n        ${ statesRaw.join('\\n') }\n        for (var stateIndex = 0, stateMax = ${ statesRaw.length }; stateIndex < stateMax; stateIndex++) {\n          var state = states[stateIndex];\n          var product = state.product;\n          var left = state.left;\n          var right = state.right;\n          \n          switch (state.name) {\n            ${ innerFunctionsSwitch.join('\\n') }\n          }\n        }\n      }\n      \n      return state.product;\n    `);\n  }\n}\n"]}