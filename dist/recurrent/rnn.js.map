{"version":3,"sources":["../../src/recurrent/rnn.js"],"names":["RNN","options","defaults","p","hasOwnProperty","stepCache","runs","totalPerplexity","totalCost","ratioClipped","model","initialize","input","hiddenLayers","output","equations","allMatrices","equationConnections","outputMatrixIndex","json","fromJSON","mapModel","hiddenSizes","push","getModel","inputSize","prevSize","d","length","hiddenSize","weight","transition","bias","equation","inputMatrix","previousResult","hiddenLayer","relu","bind","add","multiply","inputRange","outputSize","lastHiddenSize","outputConnector","outputs","equationConnection","map","size","getEquation","inputMatrixToRow","i","max","concat","createInputMatrix","Error","createHiddenLayers","hiddenMatrix","property","createOutputMatrix","err","runInput","runBackpropagate","step","log2ppl","cost","bindEquation","inputIndex","inputMax","source","target","run","logProbabilities","probabilities","Math","log2","weights","log","recurrence","pow","stepSize","learningRate","regc","clipval","numClipped","numTot","matrixIndexes","matrixIndex","matrix","rows","columns","cache","n","mdwi","decayRate","sqrt","smoothEps","maxPredictionLength","_sampleI","temperature","slice","ix","outputIndex","q","nq","probs","value","data","Object","assign","trainDefaults","formatData","iterations","errorThresh","console","logPeriod","callback","callbackPeriod","sizes","floor","forEach","unshift","keepNetworkIntact","error","sum","j","trainPattern","type","constructor","name","toJSON","layers","states","modelAsString","JSON","stringify","matrixOrigin","m","stateIndex","state","previousConnectionIndex","left","right","product","connection","indexOf","matrixToString","toInner","fnString","toString","split","shift","join","pop","fileName","fnName","replace","toLowerCase","statesRaw","usedFunctionNames","innerFunctionsSwitch","forwardFn","Function"],"mappings":"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","file":"rnn.js","sourcesContent":["import Matrix from './matrix';\nimport RandomMatrix from './matrix/random-matrix';\nimport Equation from './matrix/equation';\nimport sampleI from './matrix/sample-i';\nimport maxI from './matrix/max-i';\nimport softmax from './matrix/softmax';\nimport copy from './matrix/copy';\nimport { randomF } from '../utilities/random';\nimport zeros from '../utilities/zeros';\n\nexport default class RNN {\n  constructor(options = {}) {\n    const defaults = RNN.defaults;\n\n    for (let p in defaults) {\n      if (!defaults.hasOwnProperty(p)) continue;\n      this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n    }\n\n    this.stepCache = {};\n    this.runs = 0;\n    this.totalPerplexity = null;\n    this.totalCost = null;\n    this.ratioClipped = null;\n    this.model = null;\n\n    this.initialize();\n  }\n\n  initialize() {\n    this.model = {\n      input: null,\n      hiddenLayers: [],\n      output: null,\n      equations: [],\n      allMatrices: [],\n      equationConnections: [],\n      outputMatrixIndex: -1\n    };\n\n    if (this.json) {\n      this.fromJSON(this.json);\n    } else {\n      this.mapModel();\n    }\n  }\n\n  createHiddenLayers() {\n    let hiddenSizes = this.hiddenSizes;\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    //0 is end, so add 1 to offset\n    hiddenLayers.push(this.getModel(hiddenSizes[0], this.inputSize));\n    let prevSize = hiddenSizes[0];\n\n    for (let d = 1; d < hiddenSizes.length; d++) { // loop over depths\n      let hiddenSize = hiddenSizes[d];\n      hiddenLayers.push(this.getModel(hiddenSize, prevSize));\n      prevSize = hiddenSize;\n    }\n  }\n\n  /**\n   *\n   * @param {Number} hiddenSize\n   * @param {Number} prevSize\n   * @returns {object}\n   */\n  getModel(hiddenSize, prevSize) {\n    return {\n      //wxh\n      weight: new RandomMatrix(hiddenSize, prevSize, 0.08),\n      //whh\n      transition: new RandomMatrix(hiddenSize, hiddenSize, 0.08),\n      //bhh\n      bias: new Matrix(hiddenSize, 1)\n    };\n  }\n\n  /**\n   *\n   * @param {Equation} equation\n   * @param {Matrix} inputMatrix\n   * @param {Matrix} previousResult\n   * @param {Object} hiddenLayer\n   * @returns {Matrix}\n   */\n  getEquation(equation, inputMatrix, previousResult, hiddenLayer) {\n    let relu = equation.relu.bind(equation);\n    let add = equation.add.bind(equation);\n    let multiply = equation.multiply.bind(equation);\n\n    return relu(\n      add(\n        add(\n          multiply(\n            hiddenLayer.weight,\n            inputMatrix\n          ),\n          multiply(\n            hiddenLayer.transition,\n            previousResult\n          )\n        ),\n        hiddenLayer.bias\n      )\n    );\n  }\n\n  createInputMatrix() {\n    //0 is end, so add 1 to offset\n    this.model.input = new RandomMatrix(this.inputRange + 1, this.inputSize, 0.08);\n  }\n\n  createOutputMatrix() {\n    let model = this.model;\n    let outputSize = this.outputSize;\n    let lastHiddenSize = this.hiddenSizes[this.hiddenSizes.length - 1];\n\n    //0 is end, so add 1 to offset\n    //whd\n    model.outputConnector = new RandomMatrix(outputSize + 1, lastHiddenSize, 0.08);\n    //0 is end, so add 1 to offset\n    //bd\n    model.output = new Matrix(outputSize + 1, 1);\n  }\n\n  bindEquation() {\n    let model = this.model;\n    let hiddenSizes = this.hiddenSizes;\n    let hiddenLayers = model.hiddenLayers;\n    let equation = new Equation();\n    let outputs = [];\n    let equationConnection = model.equationConnections.length > 0\n      ? model.equationConnections[model.equationConnections.length - 1]\n      : hiddenSizes.map((size) => new Matrix(hiddenSizes[0], 1))\n      ;\n\n      // 0 index\n    let output = this.getEquation(equation, equation.inputMatrixToRow(model.input), equationConnection[0], hiddenLayers[0]);\n    outputs.push(output);\n    // 1+ indexes\n    for (let i = 1, max = hiddenSizes.length; i < max; i++) {\n      output = this.getEquation(equation, output, equationConnection[i], hiddenLayers[i]);\n      outputs.push(output);\n    }\n\n    model.equationConnections.push(outputs);\n    equation.add(equation.multiply(model.outputConnector, output), model.output);\n    model.allMatrices = model.allMatrices.concat(equation.allMatrices);\n    model.equations.push(equation);\n  }\n\n  mapModel() {\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    let allMatrices = model.allMatrices;\n\n    this.createInputMatrix();\n    if (!model.input) throw new Error('net.model.input not set');\n    allMatrices.push(model.input);\n\n    this.createHiddenLayers();\n    if (!model.hiddenLayers.length) throw new Error('net.hiddenLayers not set');\n    for (let i = 0, max = hiddenLayers.length; i < max; i++) {\n      let hiddenMatrix = hiddenLayers[i];\n      for (let property in hiddenMatrix) {\n        if (!hiddenMatrix.hasOwnProperty(property)) continue;\n        allMatrices.push(hiddenMatrix[property]);\n      }\n    }\n\n    this.createOutputMatrix();\n    if (!model.outputConnector) throw new Error('net.model.outputConnector not set');\n    if (!model.output) throw new Error('net.model.output not set');\n\n    allMatrices.push(model.outputConnector);\n    model.outputMatrixIndex = allMatrices.length;\n    allMatrices.push(model.output);\n  }\n\n  trainPattern(input) {\n    const err = this.runInput(input);\n    this.runBackpropagate(input);\n    this.step();\n    return err;\n  }\n\n  runInput(input) {\n    this.runs++;\n    let model = this.model;\n    let max = input.length;\n    let log2ppl = 0;\n    let cost = 0;\n\n    let equation;\n    while (model.equations.length <= input.length + 1) {//first and last are zeros\n      this.bindEquation();\n    }\n    for (let inputIndex = -1, inputMax = input.length; inputIndex < inputMax; inputIndex++) {\n      // start and end tokens are zeros\n      equation = model.equations[inputIndex + 1];\n\n      let source = (inputIndex === -1 ? 0 : input[inputIndex] + 1); // first step: start with START token\n      let target = (inputIndex === max - 1 ? 0 : input[inputIndex + 1] + 1); // last step: end with END token\n      let output = equation.run(source);\n      // set gradients into log probabilities\n      let logProbabilities = output; // interpret output as log probabilities\n      let probabilities = softmax(output); // compute the softmax probabilities\n\n      log2ppl += -Math.log2(probabilities.weights[target]); // accumulate base 2 log prob and do smoothing\n      cost += -Math.log(probabilities.weights[target]);\n\n      // write gradients into log probabilities\n      logProbabilities.recurrence = probabilities.weights;\n      logProbabilities.recurrence[target] -= 1;\n    }\n\n    this.totalCost = cost;\n    return this.totalPerplexity = Math.pow(2, log2ppl / (max - 1));\n  }\n\n  runBackpropagate(input) {\n    let i = input.length + 0;\n    let model = this.model;\n    let equations = model.equations;\n    while(i > 0) {\n      equations[i].runBackpropagate(input[i - 1] + 1);\n      i--;\n    }\n    equations[0].runBackpropagate(0);\n  }\n\n  step() {\n    // perform parameter update\n    let stepSize = this.learningRate;\n    let regc = this.regc;\n    let clipval = this.clipval;\n    let model = this.model;\n    let numClipped = 0;\n    let numTot = 0;\n    let allMatrices = model.allMatrices;\n    let outputMatrixIndex = model.outputMatrixIndex;\n    let matrixIndexes = allMatrices.length;\n    for (let matrixIndex = 0; matrixIndex < matrixIndexes; matrixIndex++) {\n      let matrix = allMatrices[matrixIndex];\n      if (!(matrixIndex in this.stepCache)) {\n        this.stepCache[matrixIndex] = new Matrix(matrix.rows, matrix.columns);\n      }\n      let cache = this.stepCache[matrixIndex];\n\n      //if we are in an equation, reset the weights and recurrence to 0, to prevent exploding gradient problem\n      if (matrixIndex > outputMatrixIndex) {\n        for (let i = 0, n = matrix.weights.length; i < n; i++) {\n          matrix.weights[i] = 0;\n          matrix.recurrence[i] = 0;\n        }\n        continue;\n      }\n\n      for (let i = 0, n = matrix.weights.length; i < n; i++) {\n        // rmsprop adaptive learning rate\n        let mdwi = matrix.recurrence[i];\n        cache.weights[i] = cache.weights[i] * this.decayRate + (1 - this.decayRate) * mdwi * mdwi;\n        // gradient clip\n        if (mdwi > clipval) {\n          mdwi = clipval;\n          numClipped++;\n        }\n        if (mdwi < -clipval) {\n          mdwi = -clipval;\n          numClipped++;\n        }\n        numTot++;\n\n        // update (and regularize)\n        matrix.weights[i] = matrix.weights[i] + -stepSize * mdwi / Math.sqrt(cache.weights[i] + this.smoothEps) - regc * matrix.weights[i];\n        matrix.recurrence[i] = 0; // reset gradients for next iteration\n      }\n    }\n    this.ratioClipped = numClipped / numTot;\n  }\n\n  run(input = [], maxPredictionLength = 100, _sampleI = false, temperature = 1) {\n    let model = this.model;\n    let equation;\n    let i = 0;\n    let output = input.length > 0 ? input.slice(0) : [];\n    while (model.equations.length < maxPredictionLength) {\n      this.bindEquation();\n    }\n    while (true) {\n      let ix = output.length === 0 ? 0 : output[output.length - 1];\n      equation = model.equations[i];\n      // sample predicted letter\n      let outputIndex = equation.run(ix);\n\n      let logProbabilities = new Matrix(model.output.rows, model.output.columns);\n      copy(logProbabilities, outputIndex);\n      if (temperature !== 1 && _sampleI) {\n        // scale log probabilities by temperature and renormalize\n        // if temperature is high, logprobs will go towards zero\n        // and the softmax outputs will be more diffuse. if temperature is\n        // very low, the softmax outputs will be more peaky\n        for (let q = 0, nq = logProbabilities.weights.length; q < nq; q++) {\n          logProbabilities.weights[q] /= temperature;\n        }\n      }\n\n      let probs = softmax(logProbabilities);\n\n      if (_sampleI) {\n        ix = sampleI(probs);\n      } else {\n        ix = maxI(probs);\n      }\n\n      i++;\n      if (ix === 0) {\n        // END token predicted, break out\n        break;\n      }\n      if (i >= maxPredictionLength) {\n        // something is wrong\n        break;\n      }\n\n      output.push(ix);\n    }\n\n    return output\n      .slice(input.length)\n      .map((value) => value - 1);\n  }\n\n  /**\n   *\n   * @param data\n   * @param options\n   * @returns {{error: number, iterations: number}}\n   */\n  train(data, options = {}) {\n    options = Object.assign({}, options, RNN.trainDefaults);\n    data = this.formatData(data);\n    let iterations = options.iterations;\n    let errorThresh = options.errorThresh;\n    let log = options.log === true ? console.log : options.log;\n    let logPeriod = options.logPeriod;\n    let learningRate = options.learningRate || this.learningRate;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod;\n    let sizes = [];\n    let inputSize = data[0].input.length;\n    let outputSize = data[0].output.length;\n    let hiddenSizes = this.hiddenSizes;\n    if (!hiddenSizes) {\n      sizes.push(Math.max(3, Math.floor(inputSize / 2)));\n    } else {\n      hiddenSizes.forEach(size => {\n        sizes.push(size);\n      });\n    }\n\n    sizes.unshift(inputSize);\n    sizes.push(outputSize);\n\n    if (!options.keepNetworkIntact) {\n      this.initialize();\n    }\n\n    let error = 1;\n    let i;\n    for (i = 0; i < iterations && error > errorThresh; i++) {\n      let sum = 0;\n      for (let j = 0; j < data.length; j++) {\n        let err = this.trainPattern(data[j].input);\n        sum += err;\n      }\n      error = sum / data.length;\n\n      if (log && (i % logPeriod == 0)) {\n        log('iterations:', i, 'training error:', error);\n      }\n      if (callback && (i % callbackPeriod == 0)) {\n        callback({ error: error, iterations: i });\n      }\n    }\n\n    return {\n      error: error,\n      iterations: i\n    };\n  }\n\n  /**\n   *\n   * @param learningRate\n   */\n  adjustWeights(learningRate) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {*}\n   */\n  formatData(data) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    throw new Error('not yet implemented');\n  }\n\n  toJSON() {\n    const defaults = RNN.defaults;\n    let model = this.model;\n    let options = {};\n    for (let p in defaults) {\n      options[p] = this[p];\n    }\n\n    return {\n      type: this.constructor.name,\n      options: options,\n      input: model.input.toJSON(),\n      hiddenLayers: model.hiddenLayers.map((hiddenLayer) => {\n        let layers = {};\n        for (let p in hiddenLayer) {\n          layers[p] = hiddenLayer[p].toJSON();\n        }\n        return layers;\n      }),\n      outputConnector: this.model.outputConnector.toJSON(),\n      output: this.model.output.toJSON()\n    };\n  }\n\n  fromJSON(json) {\n    this.json = json;\n    const defaults = RNN.defaults;\n    let model = this.model;\n    let options = json.options;\n    let allMatrices = model.allMatrices;\n    model.input = Matrix.fromJSON(json.input);\n    allMatrices.push(model.input);\n    model.hiddenLayers = json.hiddenLayers.map((hiddenLayer) => {\n      let layers = {};\n      for (let p in hiddenLayer) {\n        layers[p] = Matrix.fromJSON(hiddenLayer[p]);\n        allMatrices.push(layers[p]);\n      }\n      return layers;\n    });\n    model.outputConnector = Matrix.fromJSON(json.outputConnector);\n    model.output = Matrix.fromJSON(json.output);\n    allMatrices.push(model.outputConnector);\n    model.outputMatrixIndex = allMatrices.length;\n    allMatrices.push(model.output);\n\n    for (let p in defaults) {\n      if (!defaults.hasOwnProperty(p)) continue;\n      this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n    }\n\n    this.bindEquation();\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    let model = this.model;\n    let equations = this.model.equations;\n    let equation = equations[1];\n    let states = equation.states;\n    let modelAsString = JSON.stringify(this.toJSON());\n\n    function matrixOrigin(m, stateIndex) {\n      for (let i = 0, max = states.length; i < max; i++) {\n        let state = states[i];\n\n        if (i === stateIndex) {\n          let j = previousConnectionIndex(m);\n          switch (m) {\n            case state.left:\n              if (j > -1) {\n                return `typeof prevStates[${ j }] === 'object' ? prevStates[${ j }].product : new Matrix(${ m.rows }, ${ m.columns })`;\n              }\n            case state.right:\n              if (j > -1) {\n                return `typeof prevStates[${ j }] === 'object' ? prevStates[${ j }].product : new Matrix(${ m.rows }, ${ m.columns })`;\n              }\n            case state.product:\n              return `new Matrix(${ m.rows }, ${ m.columns })`;\n            default:\n              throw Error('unknown state');\n          }\n        }\n\n        if (m === state.product) return `states[${ i }].product`;\n        if (m === state.right) return `states[${ i }].right`;\n        if (m === state.left) return `states[${ i }].left`;\n      }\n    }\n\n    function previousConnectionIndex(m) {\n      const connection = model.equationConnections[0];\n      const states = equations[0].states;\n      for (let i = 0, max = states.length; i < max; i++) {\n        if (states[i].product === m) {\n          return i;\n        }\n      }\n      return connection.indexOf(m);\n    }\n\n    function matrixToString(m, stateIndex) {\n      if (!m || !m.rows || !m.columns) return 'null';\n\n      if (m === model.input) return `model.input`;\n      if (m === model.outputConnector) return `model.outputConnector`;\n      if (m === model.output) return `model.output`;\n\n      for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {\n        let hiddenLayer = model.hiddenLayers[i];\n        for (let p in hiddenLayer) {\n          if (!hiddenLayer.hasOwnProperty(p)) continue;\n          if (hiddenLayer[p] !== m) continue;\n          return `model.hiddenLayers[${ i }].${ p }`;\n        }\n      }\n\n      return matrixOrigin(m, stateIndex);\n    }\n\n    function toInner(fnString) {\n      //crude, but should be sufficient for now\n      // function() { body }\n      fnString = fnString.toString().split('{');\n      fnString.shift();\n      // body }\n      fnString = fnString.join('{');\n      fnString = fnString.split('}');\n      fnString.pop();\n      // body\n      return fnString.join('}').split('\\n').join('\\n        ');\n    }\n\n    function fileName(fnName) {\n      return `src/recurrent/matrix/${ fnName.replace(/[A-Z]/g, function(value) { return '-' + value.toLowerCase(); }) }.js`;\n    }\n\n    let statesRaw = [];\n    let usedFunctionNames = {};\n    let innerFunctionsSwitch = [];\n    for (let i = 0, max = states.length; i < max; i++) {\n      let state = states[i];\n      statesRaw.push(`states[${ i }] = {\n      name: '${ state.forwardFn.name }',\n      left: ${ matrixToString(state.left, i) },\n      right: ${ matrixToString(state.right, i) },\n      product: ${ matrixToString(state.product, i) }\n    }`);\n\n      let fnName = state.forwardFn.name;\n      if (!usedFunctionNames[fnName]) {\n        usedFunctionNames[fnName] = true;\n        innerFunctionsSwitch.push(\n          `        case '${ fnName }': //compiled from ${ fileName(fnName) }\n          ${ toInner(state.forwardFn.toString()) }\n          break;`\n        );\n      }\n    }\n\n    return new Function('input', 'maxPredictionLength', '_sampleI', 'temperature', `\n  if (typeof input === 'undefined') input = [];\n  if (typeof maxPredictionLength === 'undefined') maxPredictionLength = 100;\n  if (typeof _sampleI === 'undefined') _sampleI = false;\n  if (typeof temperature === 'undefined') temperature = 1;\n  \n  var model = ${ modelAsString };\n  var _i = 0;\n  var result = input.slice(0);\n  var states = [];\n  var prevStates;\n  while (true) {\n    // sample predicted letter\n    var ix = result.length === 0 ? 0 : result[result.length - 1]; // first step: start with START token\n    var rowPluckIndex = ix; //connect up to rowPluck\n    prevStates = states;\n    states = [];\n    ${ statesRaw.join(';\\n    ') };\n    for (var stateIndex = 0, stateMax = ${ statesRaw.length }; stateIndex < stateMax; stateIndex++) {\n      var state = states[stateIndex];\n      var product = state.product;\n      var left = state.left;\n      var right = state.right;\n      \n      switch (state.name) {\n${ innerFunctionsSwitch.join('\\n') }\n      }\n    }\n    \n    var logProbabilities = state.product;\n    if (temperature !== 1 && _sampleI) {\n      // scale log probabilities by temperature and renormalize\n      // if temperature is high, logprobs will go towards zero\n      // and the softmax outputs will be more diffuse. if temperature is\n      // very low, the softmax outputs will be more peaky\n      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {\n        logProbabilities.weights[q] /= temperature;\n      }\n    }\n\n    var probs = softmax(logProbabilities);\n\n    if (_sampleI) {\n      ix = sampleI(probs);\n    } else {\n      ix = maxI(probs);\n    }\n    \n    _i++;\n    if (ix === 0) {\n      // END token predicted, break out\n      break;\n    }\n    if (_i >= maxPredictionLength) {\n      // something is wrong\n      break;\n    }\n\n    result.push(ix);\n  }\n\n  return result.map(function(value) { return value - 1; });\n  \n  function Matrix(rows, columns) {\n    this.rows = rows;\n    this.columns = columns;\n    this.weights = zeros(rows * columns);\n    this.recurrence = zeros(rows * columns);\n  }\n  ${ zeros.toString() }\n  ${ softmax.toString() }\n  ${ randomF.toString() }\n  ${ sampleI.toString() }\n  ${ maxI.toString() }`);\n  }\n}\n\nRNN.defaults = {\n  // hidden size should be a list\n  inputSize: 20,\n  inputRange: 20,\n  hiddenSizes:[20,20],\n  outputSize: 20,\n  learningRate: 0.01,\n  decayRate: 0.999,\n  smoothEps: 1e-8,\n  regc: 0.000001,\n  clipval: 5,\n  json: null\n};\n\nRNN.trainDefaults = {\n  iterations: 20000,\n  errorThresh: 0.005,\n  log: false,\n  logPeriod: 10,\n  learningRate: 0.3,\n  callback: null,\n  callbackPeriod: 10,\n  keepNetworkIntact: false\n};"]}