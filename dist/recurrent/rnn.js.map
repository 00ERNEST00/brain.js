{"version":3,"sources":["../../src/recurrent/rnn.js"],"names":["defaults","isBackPropagate","inputSize","inputRange","hiddenSizes","outputSize","learningRate","decayRate","smoothEps","regc","clipval","json","RNN","options","p","hasOwnProperty","stepCache","runs","logProbabilities","totalPerplexity","totalCost","model","input","inputRows","equations","hidden","output","allMatrices","hiddenLayers","fromJSON","createModel","mapModel","push","getModel","prevSize","d","length","hiddenSize","weight","transition","bias","equation","inputMatrix","size","hiddenLayer","relu","bind","add","multiply","previousResult","lastHiddenSize","outputConnector","getEquation","inputMatrixToRow","addPreviousResult","i","max","createInputMatrix","Error","createOutputMatrix","bindEquations","hiddenMatrix","property","log2ppl","cost","equationIndex","equationMax","resetPreviousResults","ixSource","ixTarget","run","copyPreviousResultsTo","probabilities","Math","log2","weights","log","recurrence","slice","runBackpropagate","step","pow","stepSize","numClipped","numTot","matrixIndexes","matrixIndex","matrix","rows","columns","cache","n","mdwi","sqrt","ratioClipped","_sampleI","temperature","predictionLength","result","ix","lh","updatePreviousResults","q","nq","probs","data","iterations","errorThresh","console","logPeriod","callback","callbackPeriod","sizes","floor","forEach","unshift","initialize","keepNetworkIntact","error","sum","j","err","trainPattern","target","type","constructor","name","toJSON","map","layers"],"mappings":"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","file":"rnn.js","sourcesContent":["import sampleI from './matrix/sample-i';\nimport maxI from './matrix/max-i';\nimport Matrix from './matrix';\nimport clone from './matrix/clone';\nimport copy from './matrix/copy';\nimport RandomMatrix from './matrix/random-matrix';\nimport softmax from './matrix/softmax';\nimport Equation from './equation';\n\nconst defaults = {\n  isBackPropagate: true,\n  // hidden size should be a list\n  inputSize: 20,\n  inputRange: 20,\n  hiddenSizes:[20,20],\n  outputSize: 20,\n  learningRate: 0.01,\n  decayRate: 0.999,\n  smoothEps: 1e-8,\n  regc: 0.000001,\n  clipval: 5,\n  json: null\n};\n\nexport default class RNN {\n  /**\n   *\n   * @param json\n   * @returns {RNN}\n   */\n  static createFromJSON(json) {\n    return new RNN({ json: json });\n  }\n\n  constructor(options) {\n    options = options || {};\n\n    for (let p in defaults) {\n      if (defaults.hasOwnProperty(p) && p !== 'isBackPropagate') {\n        this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n      }\n    }\n\n    this.stepCache = {};\n    this.runs = 0;\n    this.logProbabilities = null;\n    this.totalPerplexity = null;\n    this.totalCost = null;\n\n    this.model = {\n      input: [],\n      inputRows: [],\n      equations: [],\n      hidden: [],\n      output: null,\n      allMatrices: [],\n      hiddenLayers: []\n    };\n\n    if (this.json) {\n      this.fromJSON(this.json);\n    } else {\n      this.createModel();\n      this.mapModel();\n    }\n  }\n\n  createModel() {\n    let hiddenSizes = this.hiddenSizes;\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    //0 is end, so add 1 to offset\n    hiddenLayers.push(this.getModel(hiddenSizes[0], this.inputSize));\n    let prevSize = hiddenSizes[0];\n\n    for(let d = 1; d < hiddenSizes.length; d++) { // loop over depths\n      let hiddenSize = hiddenSizes[d];\n      hiddenLayers.push(this.getModel(hiddenSize, prevSize));\n      prevSize = hiddenSize;\n    }\n  }\n\n  getModel(hiddenSize, prevSize) {\n    return {\n      //wxh\n      weight: new RandomMatrix(hiddenSize, prevSize, 0.08),\n      //whh\n      transition: new RandomMatrix(hiddenSize, hiddenSize, 0.08),\n      //bhh\n      bias: new Matrix(hiddenSize, 1)\n    };\n  }\n\n  /**\n   *\n   * @param {Equation} equation\n   * @param {Matrix} inputMatrix\n   * @param {Number} size\n   * @param {Object} hiddenLayer\n   * @returns {Matrix}\n   */\n  getEquation(equation, inputMatrix, size, hiddenLayer) {\n    let relu = equation.relu.bind(equation);\n    let add = equation.add.bind(equation);\n    let multiply = equation.multiply.bind(equation);\n    let previousResult = equation.previousResult.bind(equation);\n\n    return relu(\n      add(\n        add(\n          multiply(\n            hiddenLayer.weight,\n            inputMatrix\n          ),\n          multiply(\n            hiddenLayer.transition,\n            previousResult(size)\n          )\n        ),\n        hiddenLayer.bias\n      )\n    );\n  }\n\n  createInputMatrix() {\n    //0 is end, so add 1 to offset\n    this.model.input = new RandomMatrix(this.inputRange + 1, this.inputSize, 0.08);\n  }\n\n  createOutputMatrix() {\n    let model = this.model;\n    let outputSize = this.outputSize;\n    let lastHiddenSize = this.hiddenSizes[this.hiddenSizes.length - 1];\n\n    //0 is end, so add 1 to offset\n    //whd\n    model.outputConnector = new RandomMatrix(outputSize + 1, lastHiddenSize, 0.08);\n    //0 is end, so add 1 to offset\n    //bd\n    model.output = new Matrix(outputSize + 1, 1);\n  }\n\n  bindEquations() {\n    let model = this.model;\n    let hiddenSizes = this.hiddenSizes;\n    let hiddenLayers = model.hiddenLayers;\n\n    let equation = new Equation();\n    model.equations.push(equation);\n    // 0 index\n    let output = this.getEquation(equation, equation.inputMatrixToRow(model.input), hiddenSizes[0], hiddenLayers[0]);\n    equation.addPreviousResult(output);\n    // 1+ indexes\n    for (let i = 1, max = hiddenSizes.length; i < max; i++) {\n      output = this.getEquation(equation, output, hiddenSizes[i], hiddenLayers[i]);\n      equation.addPreviousResult(output);\n    }\n    equation.add(equation.multiply(model.outputConnector, output), model.output);\n  }\n\n  mapModel() {\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    let allMatrices = model.allMatrices;\n\n    this.createInputMatrix();\n    if (!model.input) throw new Error('net.model.input not set');\n\n    this.createOutputMatrix();\n    if (!model.outputConnector) throw new Error('net.model.outputConnector not set');\n    if (!model.output) throw new Error('net.model.output not set');\n\n    this.bindEquations();\n    if (!model.equations.length > 0) throw new Error('net.equations not set');\n\n    allMatrices.push(model.input);\n\n    for(let i = 0, max = hiddenLayers.length; i < max; i++) {\n      let hiddenMatrix = hiddenLayers[i];\n      for (let property in hiddenMatrix) {\n        if (!hiddenMatrix.hasOwnProperty(property)) continue;\n        allMatrices.push(hiddenMatrix[property]);\n      }\n    }\n\n    allMatrices.push(model.outputConnector);\n    allMatrices.push(model.output);\n  }\n\n  run(input) {\n    this.runs++;\n    input = input || this.model.input;\n    let equations = this.model.equations;\n    let max = input.length;\n    let log2ppl = 0;\n    let cost = 0;\n\n    for (let equationIndex = 0, equationMax = equations.length; equationIndex < equationMax; equationIndex++) {\n      equations[equationIndex].resetPreviousResults();\n    }\n\n    while (equations.length <= max) {\n      this.bindEquations();\n    }\n\n    let i;\n    let output;\n    for (i = -1; i < max; i++) {\n      // start and end tokens are zeros\n      let equation = equations[i + 1];\n      let ixSource = (i === -1 ? 0 : input[i]); // first step: start with START token\n      let ixTarget = (i === max - 1 ? 0 : input[i + 1]); // last step: end with END token\n      output = equation.run(ixSource);\n      if (equations[i + 2]) {\n        equation.copyPreviousResultsTo(equations[i + 2]);\n      }\n\n      // set gradients into log probabilities\n      this.logProbabilities = output; // interpret output as log probabilities\n      let probabilities = softmax(output); // compute the softmax probabilities\n\n      log2ppl += -Math.log2(probabilities.weights[ixTarget]); // accumulate base 2 log prob and do smoothing\n      cost += -Math.log(probabilities.weights[ixTarget]);\n\n      // write gradients into log probabilities\n      this.logProbabilities.recurrence = probabilities.weights.slice(0);\n      this.logProbabilities.recurrence[ixTarget] -= 1\n    }\n\n    while (i > -1) {\n      equations[i--].runBackpropagate();\n    }\n\n    this.step();\n\n    this.totalPerplexity = Math.pow(2, log2ppl / (max - 1));\n    this.totalCost = cost;\n    return output;\n  }\n\n  step() {\n    // perform parameter update\n    let stepSize = this.learningRate;\n    let regc = this.regc;\n    let clipval = this.clipval;\n    let model = this.model;\n    let numClipped = 0;\n    let numTot = 0;\n    let allMatrices = model.allMatrices;\n    let matrixIndexes = allMatrices.length;\n    for(let matrixIndex = 0; matrixIndex < matrixIndexes; matrixIndex++) {\n      let matrix = allMatrices[matrixIndex];\n      if (!(matrixIndex in this.stepCache)) {\n        this.stepCache[matrixIndex] = new Matrix(matrix.rows, matrix.columns);\n      }\n      let cache = this.stepCache[matrixIndex];\n\n      for(let i = 0, n = matrix.weights.length; i < n; i++) {\n        // rmsprop adaptive learning rate\n        let mdwi = matrix.recurrence[i];\n        cache.weights[i] = cache.weights[i] * this.decayRate + (1 - this.decayRate) * mdwi * mdwi;\n        // gradient clip\n        if (mdwi > clipval) {\n          mdwi = clipval;\n          numClipped++;\n        }\n        if (mdwi < -clipval) {\n          mdwi = -clipval;\n          numClipped++;\n        }\n        numTot++;\n\n        // update (and regularize)\n        matrix.weights[i] += -stepSize * mdwi / Math.sqrt(cache.weights[i] + this.smoothEps) - regc * matrix.weights[i];\n        matrix.recurrence[i] = 0; // reset gradients for next iteration\n      }\n    }\n    this.ratioClipped = numClipped / numTot;\n  }\n\n  predict(_sampleI, temperature, predictionLength) {\n    if (typeof _sampleI === 'undefined') { _sampleI = true; }\n    if (typeof temperature === 'undefined') { temperature = 1; }\n    if (typeof predictionLength === 'undefined') { predictionLength = 100; }\n\n    let result = [];\n    //var prev;\n    let ix;\n    let equation = this.model.equations[0];\n    equation.resetPreviousResults();\n    while (true) {\n      ix = result.length === 0 ? 0 : result[result.length - 1];\n      let lh = equation.run(ix);\n      equation.updatePreviousResults();\n      //prev = clone(lh);\n      // sample predicted letter\n      this.logProbabilities = lh;\n      if (temperature !== 1 && _sampleI) {\n        // scale log probabilities by temperature and renormalize\n        // if temperature is high, logprobs will go towards zero\n        // and the softmax outputs will be more diffuse. if temperature is\n        // very low, the softmax outputs will be more peaky\n        for (let q = 0, nq = this.logProbabilities.weights.length; q < nq; q++) {\n          this.logProbabilities.weights[q] /= temperature;\n        }\n      }\n\n      let probs = softmax(this.logProbabilities);\n\n      if (_sampleI) {\n        ix = sampleI(probs);\n      } else {\n        ix = maxI(probs);\n      }\n\n      if (ix === 0) {\n        // END token predicted, break out\n        break;\n      }\n      if (result.length > predictionLength) {\n        // something is wrong\n        break;\n      }\n\n      result.push(ix);\n    }\n\n    return result;\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  runInput(input) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param data\n   * @param options\n   * @returns {{error: number, iterations: number}}\n   */\n  train(data, options) {\n    //data = this.formatData(data);\n\n    options = options || {};\n    let iterations = options.iterations || 20000;\n    let errorThresh = options.errorThresh || 0.005;\n    let log = options.log ? (typeof options.log === 'function' ? options.log : console.log) : false;\n    let logPeriod = options.logPeriod || 10;\n    let learningRate = options.learningRate || this.learningRate || 0.3;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod || 10;\n    let sizes = [];\n    let inputSize = data[0].input.length;\n    let outputSize = data[0].output.length;\n    let hiddenSizes = this.hiddenSizes;\n    if (!hiddenSizes) {\n      sizes.push(Math.max(3, Math.floor(inputSize / 2)));\n    } else {\n      hiddenSizes.forEach(function(size) {\n        sizes.push(size);\n      });\n    }\n\n    sizes.unshift(inputSize);\n    sizes.push(outputSize);\n\n    this.initialize(sizes, options.keepNetworkIntact);\n\n    let error = 1;\n    for (let i = 0; i < iterations && error > errorThresh; i++) {\n      let sum = 0;\n      for (let j = 0; j < data.length; j++) {\n        let err = this.trainPattern(data[j].input, data[j].output, learningRate);\n        sum += err;\n      }\n      error = sum / data.length;\n\n      if (log && (i % logPeriod == 0)) {\n        log('iterations:', i, 'training error:', error);\n      }\n      if (callback && (i % callbackPeriod == 0)) {\n        callback({ error: error, iterations: i });\n      }\n    }\n\n    return {\n      error: error,\n      iterations: i\n    };\n  }\n\n  /**\n   *\n   * @param input\n   * @param target\n   * @param learningRate\n   */\n  trainPattern(input, target, learningRate) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltas(target) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param learningRate\n   */\n  adjustWeights(learningRate) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {*}\n   */\n  formatData(data) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    throw new Error('not yet implemented');\n  }\n\n  toJSON() {\n    let model = this.model;\n    return {\n      type: this.constructor.name,\n      input: model.input.toJSON(),\n      hiddenLayers: model.hiddenLayers.map(function(hiddenLayer) {\n        let layers = {};\n        for (let p in hiddenLayer) {\n          layers[p] = hiddenLayer[p].toJSON();\n        }\n        return layers;\n      }),\n      outputConnector: this.model.outputConnector.toJSON(),\n      output: this.model.output.toJSON()\n    };\n  }\n\n  fromJSON(json) {\n    this.json = json;\n    let model = this.model;\n    let allMatrices = model.allMatrices;\n    model.input = Matrix.fromJSON(json.input);\n    allMatrices.push(model.input);\n    model.hiddenLayers = json.hiddenLayers.map(function(hiddenLayer) {\n      let layers = {};\n      for (let p in hiddenLayer) {\n        layers[p] = Matrix.fromJSON(hiddenLayer[p]);\n        allMatrices.push(layers[p]);\n      }\n      return layers;\n    });\n    model.outputConnector = Matrix.fromJSON(json.outputConnector);\n    model.output = Matrix.fromJSON(json.output);\n    allMatrices.push(model.outputConnector, model.output);\n    this.bindEquations();\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    throw new Error('not yet implemented');\n  }\n}\n"]}