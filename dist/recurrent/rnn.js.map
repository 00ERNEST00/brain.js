{"version":3,"sources":["../../src/recurrent/rnn.js"],"names":["defaults","isBackPropagate","inputSize","inputRange","hiddenSizes","outputSize","learningRate","decayRate","smoothEps","regc","clipval","json","RNN","options","p","hasOwnProperty","stepCache","runs","logProbabilities","totalPerplexity","totalCost","model","input","inputRows","equations","hidden","output","allMatrices","hiddenLayers","fromJSON","createModel","mapModel","push","getModel","prevSize","d","length","hiddenSize","weight","transition","bias","equation","inputMatrix","size","hiddenLayer","relu","bind","add","multiply","previousResult","result","lastHiddenSize","outputConnector","getEquation","inputMatrixToRow","i","max","createInputMatrix","Error","createOutputMatrix","bindEquations","hiddenMatrix","property","log2ppl","cost","equationIndex","equationMax","resetPreviousResults","ixSource","ixTarget","run","updatePreviousResults","probabilities","Math","log2","weights","log","recurrence","slice","runBackpropagate","step","pow","stepSize","numClipped","numTot","matrixIndexes","matrixIndex","matrix","rows","columns","cache","n","mdwi","sqrt","ratioClipped","_sampleI","temperature","predictionLength","ix","lh","q","nq","probs","outputs","layer","outputLayer","node","sizes","sum","biases","k","exp","data","iterations","errorThresh","console","logPeriod","callback","callbackPeriod","floor","forEach","unshift","error","j","err","trainPattern","target","type","constructor","name","toJSON","map","layers","states","modelAsString","JSON","stringify","matrixOrigin","m","requestedStateIndex","state","product","left","right","matrixToString","stateIndex","toInner","fnString","toString","split","shift","join","pop","fileName","fnName","replace","value","toLowerCase","statesRaw","usedFunctionNames","innerFunctionsSwitch","forwardFn","Function"],"mappings":"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","file":"rnn.js","sourcesContent":["import sampleI from '../matrix/sample-i';\nimport maxI from '../matrix/max-i';\nimport Matrix from '../matrix';\nimport RandomMatrix from '../matrix/random-matrix';\nimport softmax from '../matrix/softmax';\nimport Equation from '../utilities/equation';\n\nconst defaults = {\n  isBackPropagate: true,\n  // hidden size should be a list\n  inputSize: 20,\n  inputRange: 20,\n  hiddenSizes:[20,20],\n  outputSize: 20,\n  learningRate: 0.01,\n  decayRate: 0.999,\n  smoothEps: 1e-8,\n  regc: 0.000001,\n  clipval: 5,\n  json: null\n};\n\nexport default class RNN {\n  constructor(options) {\n    options = options || {};\n\n    for (let p in defaults) {\n      if (defaults.hasOwnProperty(p) && p !== 'isBackPropagate') {\n        this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n      }\n    }\n\n    this.stepCache = {};\n    this.runs = 0;\n    this.logProbabilities = null;\n    this.totalPerplexity = null;\n    this.totalCost = null;\n\n    this.model = {\n      input: [],\n      inputRows: [],\n      equations: [],\n      hidden: [],\n      output: null,\n      allMatrices: [],\n      hiddenLayers: []\n    };\n\n    if (this.json) {\n      this.fromJSON(this.json);\n    } else {\n      this.createModel();\n      this.mapModel();\n    }\n  }\n\n  createModel() {\n    let hiddenSizes = this.hiddenSizes;\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    //0 is end, so add 1 to offset\n    hiddenLayers.push(this.getModel(hiddenSizes[0], this.inputSize));\n    let prevSize = hiddenSizes[0];\n\n    for (let d = 1; d < hiddenSizes.length; d++) { // loop over depths\n      let hiddenSize = hiddenSizes[d];\n      hiddenLayers.push(this.getModel(hiddenSize, prevSize));\n      prevSize = hiddenSize;\n    }\n  }\n\n  getModel(hiddenSize, prevSize) {\n    return {\n      //wxh\n      weight: new RandomMatrix(hiddenSize, prevSize, 0.08),\n      //whh\n      transition: new RandomMatrix(hiddenSize, hiddenSize, 0.08),\n      //bhh\n      bias: new Matrix(hiddenSize, 1)\n    };\n  }\n\n  /**\n   *\n   * @param {Equation} equation\n   * @param {Matrix} inputMatrix\n   * @param {Number} size\n   * @param {Object} hiddenLayer\n   * @returns {Matrix}\n   */\n  getEquation(equation, inputMatrix, size, hiddenLayer) {\n    let relu = equation.relu.bind(equation);\n    let add = equation.add.bind(equation);\n    let multiply = equation.multiply.bind(equation);\n    let previousResult = equation.previousResult.bind(equation);\n    let result = equation.result.bind(equation);\n\n    return result(\n      relu(\n        add(\n          add(\n            multiply(\n              hiddenLayer.weight,\n              inputMatrix\n            ),\n            multiply(\n              hiddenLayer.transition,\n              previousResult(size)\n            )\n          ),\n          hiddenLayer.bias\n        )\n      )\n    );\n  }\n\n  createInputMatrix() {\n    //0 is end, so add 1 to offset\n    this.model.input = new RandomMatrix(this.inputRange + 1, this.inputSize, 0.08);\n  }\n\n  createOutputMatrix() {\n    let model = this.model;\n    let outputSize = this.outputSize;\n    let lastHiddenSize = this.hiddenSizes[this.hiddenSizes.length - 1];\n\n    //0 is end, so add 1 to offset\n    //whd\n    model.outputConnector = new RandomMatrix(outputSize + 1, lastHiddenSize, 0.08);\n    //0 is end, so add 1 to offset\n    //bd\n    model.output = new Matrix(outputSize + 1, 1);\n  }\n\n  bindEquations() {\n    let model = this.model;\n    let hiddenSizes = this.hiddenSizes;\n    let hiddenLayers = model.hiddenLayers;\n\n    let equation = new Equation();\n    model.equations.push(equation);\n    // 0 index\n    let output = this.getEquation(equation, equation.inputMatrixToRow(model.input), hiddenSizes[0], hiddenLayers[0]);\n    // 1+ indexes\n    for (let i = 1, max = hiddenSizes.length; i < max; i++) {\n      output = this.getEquation(equation, output, hiddenSizes[i], hiddenLayers[i]);\n    }\n    equation.add(equation.multiply(model.outputConnector, output), model.output);\n  }\n\n  mapModel() {\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    let allMatrices = model.allMatrices;\n\n    this.createInputMatrix();\n    if (!model.input) throw new Error('net.model.input not set');\n\n    this.createOutputMatrix();\n    if (!model.outputConnector) throw new Error('net.model.outputConnector not set');\n    if (!model.output) throw new Error('net.model.output not set');\n\n    this.bindEquations();\n    if (!model.equations.length > 0) throw new Error('net.equations not set');\n\n    allMatrices.push(model.input);\n\n    for (let i = 0, max = hiddenLayers.length; i < max; i++) {\n      let hiddenMatrix = hiddenLayers[i];\n      for (let property in hiddenMatrix) {\n        if (!hiddenMatrix.hasOwnProperty(property)) continue;\n        allMatrices.push(hiddenMatrix[property]);\n      }\n    }\n\n    allMatrices.push(model.outputConnector);\n    allMatrices.push(model.output);\n  }\n\n  run(input) {\n    this.runs++;\n    input = input || this.model.input;\n    let equations = this.model.equations;\n    let max = input.length;\n    let log2ppl = 0;\n    let cost = 0;\n\n    for (let equationIndex = 0, equationMax = equations.length; equationIndex < equationMax; equationIndex++) {\n      equations[equationIndex].resetPreviousResults();\n    }\n\n    while (equations.length <= max) {\n      this.bindEquations();\n    }\n\n    let i;\n    let output;\n    for (i = -1; i < max; i++) {\n      // start and end tokens are zeros\n      let equation = equations[i + 1];\n      let ixSource = (i === -1 ? 0 : input[i]); // first step: start with START token\n      let ixTarget = (i === max - 1 ? 0 : input[i + 1]); // last step: end with END token\n      output = equation.run(ixSource);\n      equation.updatePreviousResults();\n\n      // set gradients into log probabilities\n      this.logProbabilities = output; // interpret output as log probabilities\n      let probabilities = softmax(output); // compute the softmax probabilities\n\n      log2ppl += -Math.log2(probabilities.weights[ixTarget]); // accumulate base 2 log prob and do smoothing\n      cost += -Math.log(probabilities.weights[ixTarget]);\n\n      // write gradients into log probabilities\n      this.logProbabilities.recurrence = probabilities.weights.slice(0);\n      this.logProbabilities.recurrence[ixTarget] -= 1\n    }\n\n    while (i-- > 0) {\n      equations[i].runBackpropagate();\n    }\n\n    this.step();\n\n    this.totalPerplexity = Math.pow(2, log2ppl / (max - 1));\n    this.totalCost = cost;\n    return output;\n  }\n\n  step() {\n    // perform parameter update\n    let stepSize = this.learningRate;\n    let regc = this.regc;\n    let clipval = this.clipval;\n    let model = this.model;\n    let numClipped = 0;\n    let numTot = 0;\n    let allMatrices = model.allMatrices;\n    let matrixIndexes = allMatrices.length;\n    for (let matrixIndex = 0; matrixIndex < matrixIndexes; matrixIndex++) {\n      let matrix = allMatrices[matrixIndex];\n      if (!(matrixIndex in this.stepCache)) {\n        this.stepCache[matrixIndex] = new Matrix(matrix.rows, matrix.columns);\n      }\n      let cache = this.stepCache[matrixIndex];\n\n      for (let i = 0, n = matrix.weights.length; i < n; i++) {\n        // rmsprop adaptive learning rate\n        let mdwi = matrix.recurrence[i];\n        cache.weights[i] = cache.weights[i] * this.decayRate + (1 - this.decayRate) * mdwi * mdwi;\n        // gradient clip\n        if (mdwi > clipval) {\n          mdwi = clipval;\n          numClipped++;\n        }\n        if (mdwi < -clipval) {\n          mdwi = -clipval;\n          numClipped++;\n        }\n        numTot++;\n\n        // update (and regularize)\n        matrix.weights[i] += -stepSize * mdwi / Math.sqrt(cache.weights[i] + this.smoothEps) - regc * matrix.weights[i];\n        matrix.recurrence[i] = 0; // reset gradients for next iteration\n      }\n    }\n    this.ratioClipped = numClipped / numTot;\n  }\n\n  predict(_sampleI, temperature, predictionLength) {\n    if (typeof _sampleI === 'undefined') { _sampleI = true; }\n    if (typeof temperature === 'undefined') { temperature = 1; }\n    if (typeof predictionLength === 'undefined') { predictionLength = 100; }\n\n    let result = [];\n    //let prev;\n    let ix;\n    let equation = this.model.equations[0];\n    //equation.resetPreviousResults();\n    while (true) {\n      ix = result.length === 0 ? 0 : result[result.length - 1];\n      let lh = equation.run(ix);\n      //equation.updatePreviousResults();\n      //prev = clone(lh);\n      // sample predicted letter\n      this.logProbabilities = lh;\n      if (temperature !== 1 && _sampleI) {\n        // scale log probabilities by temperature and renormalize\n        // if temperature is high, logprobs will go towards zero\n        // and the softmax outputs will be more diffuse. if temperature is\n        // very low, the softmax outputs will be more peaky\n        for (let q = 0, nq = this.logProbabilities.weights.length; q < nq; q++) {\n          this.logProbabilities.weights[q] /= temperature;\n        }\n      }\n\n      let probs = softmax(this.logProbabilities);\n\n      if (_sampleI) {\n        ix = sampleI(probs);\n      } else {\n        ix = maxI(probs);\n      }\n\n      if (ix === 0) {\n        // END token predicted, break out\n        break;\n      }\n      if (result.length > predictionLength) {\n        // something is wrong\n        break;\n      }\n\n      result.push(ix);\n    }\n\n    return result;\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  runInput(input) {\n    this.outputs[0] = input;  // set output state of input layer\n\n    let output = null;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let weights = this.weights[layer][node];\n\n        let sum = this.biases[layer][node];\n        for (let k = 0; k < weights.length; k++) {\n          sum += weights[k] * input[k];\n        }\n        this.outputs[layer][node] = 1 / (1 + Math.exp(-sum));\n      }\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  /**\n   *\n   * @param data\n   * @param options\n   * @returns {{error: number, iterations: number}}\n   */\n  train(data, options) {\n    throw new Error('not yet implemented');\n    //data = this.formatData(data);\n\n    options = options || {};\n    let iterations = options.iterations || 20000;\n    let errorThresh = options.errorThresh || 0.005;\n    let log = options.log ? (typeof options.log === 'function' ? options.log : console.log) : false;\n    let logPeriod = options.logPeriod || 10;\n    let learningRate = options.learningRate || this.learningRate || 0.3;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod || 10;\n    let sizes = [];\n    let inputSize = data[0].input.length;\n    let outputSize = data[0].output.length;\n    let hiddenSizes = this.hiddenSizes;\n    if (!hiddenSizes) {\n      sizes.push(Math.max(3, Math.floor(inputSize / 2)));\n    } else {\n      hiddenSizes.forEach(function(size) {\n        sizes.push(size);\n      });\n    }\n\n    sizes.unshift(inputSize);\n    sizes.push(outputSize);\n\n    //this.initialize(sizes, options.keepNetworkIntact);\n\n    let error = 1;\n    for (let i = 0; i < iterations && error > errorThresh; i++) {\n      let sum = 0;\n      for (let j = 0; j < data.length; j++) {\n        let err = this.trainPattern(data[j].input, data[j].output, learningRate);\n        sum += err;\n      }\n      error = sum / data.length;\n\n      if (log && (i % logPeriod == 0)) {\n        log('iterations:', i, 'training error:', error);\n      }\n      if (callback && (i % callbackPeriod == 0)) {\n        callback({ error: error, iterations: i });\n      }\n    }\n\n    return {\n      error: error,\n      iterations: i\n    };\n  }\n\n  /**\n   *\n   * @param input\n   * @param target\n   * @param learningRate\n   */\n  trainPattern(input, target, learningRate) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltas(target) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param learningRate\n   */\n  adjustWeights(learningRate) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {*}\n   */\n  formatData(data) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    throw new Error('not yet implemented');\n  }\n\n  toJSON() {\n    let model = this.model;\n    let options = {};\n    for (let p in defaults) {\n      options[p] = this[p];\n    }\n\n    return {\n      type: this.constructor.name,\n      options: options,\n      input: model.input.toJSON(),\n      hiddenLayers: model.hiddenLayers.map(function(hiddenLayer) {\n        let layers = {};\n        for (let p in hiddenLayer) {\n          layers[p] = hiddenLayer[p].toJSON();\n        }\n        return layers;\n      }),\n      outputConnector: this.model.outputConnector.toJSON(),\n      output: this.model.output.toJSON()\n    };\n  }\n\n  fromJSON(json) {\n    this.json = json;\n    let model = this.model;\n    let options = json.options;\n    let allMatrices = model.allMatrices;\n    model.input = Matrix.fromJSON(json.input);\n    allMatrices.push(model.input);\n    model.hiddenLayers = json.hiddenLayers.map(function(hiddenLayer) {\n      let layers = {};\n      for (let p in hiddenLayer) {\n        layers[p] = Matrix.fromJSON(hiddenLayer[p]);\n        allMatrices.push(layers[p]);\n      }\n      return layers;\n    });\n    model.outputConnector = Matrix.fromJSON(json.outputConnector);\n    model.output = Matrix.fromJSON(json.output);\n    allMatrices.push(model.outputConnector, model.output);\n\n    for (let p in defaults) {\n      if (defaults.hasOwnProperty(p) && p !== 'isBackPropagate') {\n        this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n      }\n    }\n\n    this.bindEquations();\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    let model = this.model;\n    let equation = this.model.equations[0];\n    let states = equation.states;\n    let modelAsString = JSON.stringify(this.toJSON());\n\n    function matrixOrigin(m, requestedStateIndex) {\n      for (let i = 0, max = states.length; i < max; i++) {\n        let state = states[i];\n\n        if (i === requestedStateIndex) {\n          switch (m) {\n            case state.product:\n            case state.left:\n            case state.right:\n              return `new Matrix(${ m.rows }, ${ m.columns })`;\n          }\n        }\n\n        if (m === state.product) return `states[${ i }].product`;\n        if (m === state.right) return `states[${ i }].right`;\n        if (m === state.left) return `states[${ i }].left`;\n      }\n    }\n\n    function matrixToString(m, stateIndex) {\n      if (!m) return 'null';\n\n      for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {\n        let hiddenLayer = model.hiddenLayers[i];\n        for (let p in hiddenLayer) {\n          if (hiddenLayer[p] === m) {\n            return `model.hiddenLayers[${ i }].${ p }`;\n          }\n        }\n      }\n      if (m === model.input) return `model.input`;\n      if (m === model.outputConnector) return `model.outputConnector`;\n      if (m === model.output) return `model.output`;\n      return matrixOrigin(m, stateIndex);\n    }\n\n    function toInner(fnString) {\n      //crude, but should be sufficient for now\n      //function() { inner.function.string.here; }\n      fnString = fnString.toString().split('{');\n      fnString.shift();\n      // inner.function.string.here; }\n      fnString = fnString.join('{');\n      fnString = fnString.split('}');\n      fnString.pop();\n      // inner.function.string.here;\n      return fnString.join('}');\n    }\n\n    function fileName(fnName) {\n      return `src/recurrent/matrix/${ fnName.replace(/[A-Z]/g, function(value) { return '-' + value.toLowerCase(); }) }.js`;\n    }\n\n    let statesRaw = [];\n    let usedFunctionNames = {};\n    let innerFunctionsSwitch = [];\n    for (let i = 0, max = states.length; i < max; i++) {\n      let state = states[i];\n      statesRaw.push(`states[${ i }] = {\n        name: '${ state.forwardFn.name }',\n        left: ${ matrixToString(state.left, i) },\n        right: ${ matrixToString(state.right, i) },\n        product: ${ matrixToString(state.product, i) }\n      };`);\n\n      let fnName = state.forwardFn.name;\n      if (!usedFunctionNames[fnName]) {\n        usedFunctionNames[fnName] = true;\n        innerFunctionsSwitch.push(`\n        case '${ fnName }': //compiled from ${ fileName(fnName) }\n          ${ toInner(state.forwardFn.toString()) }\n          break;\n        `);\n      }\n    }\n\n    return new Function('input', `\n      var model = ${ modelAsString };\n      \n      function Matrix(rows, columns) {\n        this.rows = rows;\n        this.columns = columns;\n        this.weights = zeros(rows * columns);\n        this.recurrence = zeros(rows * columns);\n      }\n      \n      function zeros(size) {\n        if (typeof Float64Array !== 'undefined') return new Float64Array(size);\n        var array = new Array(size);\n        for (var i = 0; i < size; i++) {\n          array[i] = 0;\n        }\n        return array;\n      }\n      \n      for (var inputIndex = 0, inputMax = input.length; inputIndex < inputMax; inputIndex++) {\n        var ixSource = (inputIndex === -1 ? 0 : input[inputIndex]); // first step: start with START token\n        var ixTarget = (inputIndex === inputMax - 1 ? 0 : input[inputIndex + 1]); // last step: end with END token\n        var rowPluckIndex = inputIndex; //connect up to rowPluck\n        var states = {};\n        ${ statesRaw.join('\\n') }\n        for (var stateIndex = 0, stateMax = ${ statesRaw.length }; stateIndex < stateMax; stateIndex++) {\n          var state = states[stateIndex];\n          var product = state.product;\n          var left = state.left;\n          var right = state.right;\n          \n          switch (state.name) {\n            ${ innerFunctionsSwitch.join('\\n') }\n          }\n        }\n      }\n      \n      return state.product;\n    `);\n  }\n}\n"]}