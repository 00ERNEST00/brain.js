{"version":3,"sources":["../../src/recurrent/rnn.js"],"names":["RNN","options","defaults","p","hasOwnProperty","stepCache","runs","totalPerplexity","totalCost","ratioClipped","model","inputLookup","outputLookup","initialize","input","hiddenLayers","output","equations","allMatrices","equationConnections","outputMatrixIndex","vocab","inputSize","characters","length","inputRange","outputSize","json","fromJSON","mapModel","hiddenSizes","push","getModel","prevSize","d","hiddenSize","weight","transition","bias","equation","inputMatrix","previousResult","hiddenLayer","relu","bind","add","multiply","lastHiddenSize","outputConnector","outputs","equationConnection","map","size","getEquation","inputMatrixToRow","i","max","concat","createInputMatrix","Error","createHiddenLayers","hiddenMatrix","property","createOutputMatrix","learningRate","err","runInput","runBackpropagate","step","log2ppl","cost","bindEquation","inputIndex","inputMax","source","target","run","logProbabilities","probabilities","Math","log2","weights","log","recurrence","pow","stepSize","regc","clipval","numClipped","numTot","matrixIndexes","matrixIndex","matrix","rows","columns","cache","n","mdwi","decayRate","sqrt","smoothEps","rawInput","maxPredictionLength","isSampleI","temperature","formatDataIn","previousIndex","outputMatrix","j","probs","nextIndex","formatDataOut","slice","value","data","Object","assign","trainDefaults","iterations","errorThresh","console","logPeriod","callback","callbackPeriod","error","setupData","keepNetworkIntact","sum","trainPattern","isNaN","type","constructor","name","toJSON","layers","JSON","stringify","parse","states","jsonString","matrixOrigin","m","stateIndex","state","previousConnectionIndex","left","right","product","connection","indexOf","matrixToString","toInner","fnString","toString","split","shift","join","pop","fileName","fnName","replace","toLowerCase","statesRaw","usedFunctionNames","innerFunctionsSwitch","forwardFn","Function","toFunctionString","values","fromArrayInputOutput","result","indexTable","toIndexesInputOutput","toIndexes","toCharacters"],"mappings":"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","file":"rnn.js","sourcesContent":["import lookup from '../lookup';\nimport Matrix from './matrix';\nimport RandomMatrix from './matrix/random-matrix';\nimport Equation from './matrix/equation';\nimport sampleI from './matrix/sample-i';\nimport maxI from './matrix/max-i';\nimport softmax from './matrix/softmax';\nimport copy from './matrix/copy';\nimport { randomF } from '../utilities/random';\nimport zeros from '../utilities/zeros';\nimport Vocab from '../utilities/vocab';\n\nexport default class RNN {\n  constructor(options = {}) {\n    const defaults = RNN.defaults;\n\n    for (let p in defaults) {\n      if (!defaults.hasOwnProperty(p)) continue;\n      this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n    }\n\n    this.stepCache = {};\n    this.runs = 0;\n    this.totalPerplexity = null;\n    this.totalCost = null;\n    this.ratioClipped = null;\n    this.model = null;\n\n    this.inputLookup = null;\n    this.outputLookup = null;\n    this.initialize();\n  }\n\n  initialize() {\n    this.model = {\n      input: null,\n      hiddenLayers: [],\n      output: null,\n      equations: [],\n      allMatrices: [],\n      equationConnections: [],\n      outputMatrixIndex: -1\n    };\n\n    if (this.vocab !== null) {\n      this.inputSize = this.vocab.characters.length;\n      this.inputRange = this.vocab.characters.length;\n      this.outputSize = this.vocab.characters.length;\n    }\n\n    if (this.json) {\n      this.fromJSON(this.json);\n    } else {\n      this.mapModel();\n    }\n  }\n\n  createHiddenLayers() {\n    let hiddenSizes = this.hiddenSizes;\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    //0 is end, so add 1 to offset\n    hiddenLayers.push(this.getModel(hiddenSizes[0], this.inputSize));\n    let prevSize = hiddenSizes[0];\n\n    for (let d = 1; d < hiddenSizes.length; d++) { // loop over depths\n      let hiddenSize = hiddenSizes[d];\n      hiddenLayers.push(this.getModel(hiddenSize, prevSize));\n      prevSize = hiddenSize;\n    }\n  }\n\n  /**\n   *\n   * @param {Number} hiddenSize\n   * @param {Number} prevSize\n   * @returns {object}\n   */\n  getModel(hiddenSize, prevSize) {\n    return {\n      //wxh\n      weight: new RandomMatrix(hiddenSize, prevSize, 0.08),\n      //whh\n      transition: new RandomMatrix(hiddenSize, hiddenSize, 0.08),\n      //bhh\n      bias: new Matrix(hiddenSize, 1)\n    };\n  }\n\n  /**\n   *\n   * @param {Equation} equation\n   * @param {Matrix} inputMatrix\n   * @param {Matrix} previousResult\n   * @param {Object} hiddenLayer\n   * @returns {Matrix}\n   */\n  getEquation(equation, inputMatrix, previousResult, hiddenLayer) {\n    let relu = equation.relu.bind(equation);\n    let add = equation.add.bind(equation);\n    let multiply = equation.multiply.bind(equation);\n\n    return relu(\n      add(\n        add(\n          multiply(\n            hiddenLayer.weight,\n            inputMatrix\n          ),\n          multiply(\n            hiddenLayer.transition,\n            previousResult\n          )\n        ),\n        hiddenLayer.bias\n      )\n    );\n  }\n\n  createInputMatrix() {\n    //0 is end, so add 1 to offset\n    this.model.input = new RandomMatrix(this.inputRange + 1, this.inputSize, 0.08);\n  }\n\n  createOutputMatrix() {\n    let model = this.model;\n    let outputSize = this.outputSize;\n    let lastHiddenSize = this.hiddenSizes[this.hiddenSizes.length - 1];\n\n    //0 is end, so add 1 to offset\n    //whd\n    model.outputConnector = new RandomMatrix(outputSize + 1, lastHiddenSize, 0.08);\n    //0 is end, so add 1 to offset\n    //bd\n    model.output = new Matrix(outputSize + 1, 1);\n  }\n\n  bindEquation() {\n    let model = this.model;\n    let hiddenSizes = this.hiddenSizes;\n    let hiddenLayers = model.hiddenLayers;\n    let equation = new Equation();\n    let outputs = [];\n    let equationConnection = model.equationConnections.length > 0\n      ? model.equationConnections[model.equationConnections.length - 1]\n      : hiddenSizes.map((size) => new Matrix(hiddenSizes[0], 1))\n      ;\n\n      // 0 index\n    let output = this.getEquation(equation, equation.inputMatrixToRow(model.input), equationConnection[0], hiddenLayers[0]);\n    outputs.push(output);\n    // 1+ indices\n    for (let i = 1, max = hiddenSizes.length; i < max; i++) {\n      output = this.getEquation(equation, output, equationConnection[i], hiddenLayers[i]);\n      outputs.push(output);\n    }\n\n    model.equationConnections.push(outputs);\n    equation.add(equation.multiply(model.outputConnector, output), model.output);\n    model.allMatrices = model.allMatrices.concat(equation.allMatrices);\n    model.equations.push(equation);\n  }\n\n  mapModel() {\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    let allMatrices = model.allMatrices;\n\n    this.createInputMatrix();\n    if (!model.input) throw new Error('net.model.input not set');\n    allMatrices.push(model.input);\n\n    this.createHiddenLayers();\n    if (!model.hiddenLayers.length) throw new Error('net.hiddenLayers not set');\n    for (let i = 0, max = hiddenLayers.length; i < max; i++) {\n      let hiddenMatrix = hiddenLayers[i];\n      for (let property in hiddenMatrix) {\n        if (!hiddenMatrix.hasOwnProperty(property)) continue;\n        allMatrices.push(hiddenMatrix[property]);\n      }\n    }\n\n    this.createOutputMatrix();\n    if (!model.outputConnector) throw new Error('net.model.outputConnector not set');\n    if (!model.output) throw new Error('net.model.output not set');\n\n    allMatrices.push(model.outputConnector);\n    model.outputMatrixIndex = allMatrices.length;\n    allMatrices.push(model.output);\n  }\n\n  /**\n   *\n   * @param {Number[]} input\n   * @param {Number} [learningRate]\n   * @returns {*}\n   */\n  trainPattern(input, learningRate = null) {\n    const err = this.runInput(input);\n    this.runBackpropagate(input);\n    this.step(learningRate);\n    return err;\n  }\n\n  /**\n   *\n   * @param {Number[]} input\n   * @returns {number}\n   */\n  runInput(input) {\n    this.runs++;\n    let model = this.model;\n    let max = input.length;\n    let log2ppl = 0;\n    let cost = 0;\n\n    let equation;\n    while (model.equations.length <= input.length + 1) {//first and last are zeros\n      this.bindEquation();\n    }\n    for (let inputIndex = -1, inputMax = input.length; inputIndex < inputMax; inputIndex++) {\n      // start and end tokens are zeros\n      equation = model.equations[inputIndex + 1];\n\n      let source = (inputIndex === -1 ? 0 : input[inputIndex] + 1); // first step: start with START token\n      let target = (inputIndex === max - 1 ? 0 : input[inputIndex + 1] + 1); // last step: end with END token\n      let output = equation.run(source);\n      // set gradients into log probabilities\n      let logProbabilities = output; // interpret output as log probabilities\n      let probabilities = softmax(output); // compute the softmax probabilities\n\n      log2ppl += -Math.log2(probabilities.weights[target]); // accumulate base 2 log prob and do smoothing\n      cost += -Math.log(probabilities.weights[target]);\n\n      // write gradients into log probabilities\n      logProbabilities.recurrence = probabilities.weights;\n      logProbabilities.recurrence[target] -= 1;\n    }\n\n    this.totalCost = cost;\n    return this.totalPerplexity = Math.pow(2, log2ppl / (max - 1));\n  }\n\n  /**\n   * @param {Number[]} input\n   */\n  runBackpropagate(input) {\n    let i = input.length;\n    let model = this.model;\n    let equations = model.equations;\n    while(i > 0) {\n      equations[i].runBackpropagate(input[i - 1] + 1);\n      i--;\n    }\n    equations[0].runBackpropagate(0);\n  }\n\n  /**\n   *\n   * @param {Number} [learningRate]\n   */\n  step(learningRate = null) {\n    // perform parameter update\n    //TODO: still not sure if this is ready for learningRate\n    let stepSize = this.learningRate;\n    let regc = this.regc;\n    let clipval = this.clipval;\n    let model = this.model;\n    let numClipped = 0;\n    let numTot = 0;\n    let allMatrices = model.allMatrices;\n    let outputMatrixIndex = model.outputMatrixIndex;\n    let matrixIndexes = allMatrices.length;\n    for (let matrixIndex = 0; matrixIndex < matrixIndexes; matrixIndex++) {\n      let matrix = allMatrices[matrixIndex];\n      if (!(matrixIndex in this.stepCache)) {\n        this.stepCache[matrixIndex] = new Matrix(matrix.rows, matrix.columns);\n      }\n      let cache = this.stepCache[matrixIndex];\n\n      //if we are in an equation, reset the weights and recurrence to 0, to prevent exploding gradient problem\n      if (matrixIndex > outputMatrixIndex) {\n        for (let i = 0, n = matrix.weights.length; i < n; i++) {\n          matrix.weights[i] = 0;\n          matrix.recurrence[i] = 0;\n        }\n        continue;\n      }\n\n      for (let i = 0, n = matrix.weights.length; i < n; i++) {\n        // rmsprop adaptive learning rate\n        let mdwi = matrix.recurrence[i];\n        cache.weights[i] = cache.weights[i] * this.decayRate + (1 - this.decayRate) * mdwi * mdwi;\n        // gradient clip\n        if (mdwi > clipval) {\n          mdwi = clipval;\n          numClipped++;\n        }\n        if (mdwi < -clipval) {\n          mdwi = -clipval;\n          numClipped++;\n        }\n        numTot++;\n\n        // update (and regularize)\n        matrix.weights[i] = matrix.weights[i] + -stepSize * mdwi / Math.sqrt(cache.weights[i] + this.smoothEps) - regc * matrix.weights[i];\n        matrix.recurrence[i] = 0; // reset gradients for next iteration\n      }\n    }\n    this.ratioClipped = numClipped / numTot;\n  }\n\n  /**\n   *\n   * @param {Number[]|*} [rawInput]\n   * @param {Number} [maxPredictionLength]\n   * @param {Boolean} [isSampleI]\n   * @param {Number} temperature\n   * @returns {*}\n   */\n  run(rawInput = [], maxPredictionLength = 100, isSampleI = false, temperature = 1) {\n    const input = this.formatDataIn(rawInput);\n    const model = this.model;\n    const output = [];\n    let i = 0;\n    while (model.equations.length < maxPredictionLength) {\n      this.bindEquation();\n    }\n    while (true) {\n      let previousIndex = (i === 0\n        ? 0\n        : i < input.length\n          ? input[i - 1] + 1\n          : output[i - 1])\n          ;\n      let equation = model.equations[i];\n      // sample predicted letter\n      let outputMatrix = equation.run(previousIndex);\n      let logProbabilities = new Matrix(model.output.rows, model.output.columns);\n      copy(logProbabilities, outputMatrix);\n      if (temperature !== 1 && isSampleI) {\n        /**\n         * scale log probabilities by temperature and re-normalize\n         * if temperature is high, logProbabilities will go towards zero\n         * and the softmax outputs will be more diffuse. if temperature is\n         * very low, the softmax outputs will be more peaky\n         */\n        for (let j = 0, max = logProbabilities.weights.length; j < max; j++) {\n          logProbabilities.weights[j] /= temperature;\n        }\n      }\n\n      let probs = softmax(logProbabilities);\n      let nextIndex = (isSampleI ? sampleI(probs) : maxI(probs));\n\n      i++;\n      if (nextIndex === 0) {\n        // END token predicted, break out\n        break;\n      }\n      if (i >= maxPredictionLength) {\n        // something is wrong\n        break;\n      }\n\n      output.push(nextIndex);\n    }\n\n    /**\n     * we slice the input length here, not because output contains it, but it will be erroneous as we are sending the\n     * network what is contained in input, so the data is essentially guessed by the network what could be next, till it\n     * locks in on a value.\n     * Kind of like this, values are from input:\n     * 0 -> 4 (or in English: \"beginning on input\" -> \"I have no idea? I'll guess what they want next!\")\n     * 2 -> 2 (oh how interesting, I've narrowed down values...)\n     * 1 -> 9 (oh how interesting, I've now know what the values are...)\n     * then the output looks like: [4, 2, 9,...]\n     * so we then remove the erroneous data to get our true output\n     */\n    return this.formatDataOut(\n      input,\n      output\n        .slice(input.length)\n        .map(value => value - 1)\n    );\n  }\n\n  /**\n   *\n   * @param {Object[]} data a collection of objects: `{input: 'string', output: 'string'}`\n   * @param {Object} [options]\n   * @returns {{error: number, iterations: number}}\n   */\n  train(data, options = {}) {\n    options = Object.assign({}, RNN.trainDefaults, options);\n    let iterations = options.iterations;\n    let errorThresh = options.errorThresh;\n    let log = options.log === true ? console.log : options.log;\n    let logPeriod = options.logPeriod;\n    let learningRate = options.learningRate || this.learningRate;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod;\n    let error = 1;\n    let i;\n\n    if (this.hasOwnProperty('setupData')) {\n      data = this.setupData(data);\n    }\n    if (!options.keepNetworkIntact) {\n      this.initialize();\n    }\n\n    for (i = 0; i < iterations && error > errorThresh; i++) {\n      let sum = 0;\n      for (let j = 0; j < data.length; j++) {\n        let err = this.trainPattern(data[j], learningRate);\n        sum += err;\n      }\n      error = sum / data.length;\n\n      if (isNaN(error)) throw new Error('network error rate is unexpected NaN, check network configurations and try again');\n      if (log && (i % logPeriod == 0)) {\n        log('iterations:', i, 'training error:', error);\n      }\n      if (callback && (i % callbackPeriod == 0)) {\n        callback({ error: error, iterations: i });\n      }\n    }\n\n    return {\n      error: error,\n      iterations: i\n    };\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @returns {Object}\n   */\n  toJSON() {\n    const defaults = RNN.defaults;\n    let model = this.model;\n    let options = {};\n    for (let p in defaults) {\n      options[p] = this[p];\n    }\n\n    return {\n      type: this.constructor.name,\n      options: options,\n      input: model.input.toJSON(),\n      hiddenLayers: model.hiddenLayers.map((hiddenLayer) => {\n        let layers = {};\n        for (let p in hiddenLayer) {\n          layers[p] = hiddenLayer[p].toJSON();\n        }\n        return layers;\n      }),\n      outputConnector: this.model.outputConnector.toJSON(),\n      output: this.model.output.toJSON()\n    };\n  }\n\n  toJSONString() {\n    return JSON.stringify(this.toJSON());\n  }\n\n  fromJSON(json) {\n    this.json = json;\n    const defaults = RNN.defaults;\n    let model = this.model;\n    let options = json.options;\n    let allMatrices = model.allMatrices;\n    model.input = Matrix.fromJSON(json.input);\n    allMatrices.push(model.input);\n    model.hiddenLayers = json.hiddenLayers.map((hiddenLayer) => {\n      let layers = {};\n      for (let p in hiddenLayer) {\n        layers[p] = Matrix.fromJSON(hiddenLayer[p]);\n        allMatrices.push(layers[p]);\n      }\n      return layers;\n    });\n    model.outputConnector = Matrix.fromJSON(json.outputConnector);\n    model.output = Matrix.fromJSON(json.output);\n    allMatrices.push(model.outputConnector);\n    model.outputMatrixIndex = allMatrices.length;\n    allMatrices.push(model.output);\n\n    for (let p in defaults) {\n      if (!defaults.hasOwnProperty(p)) continue;\n      this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n    }\n\n    if (options.hasOwnProperty('vocab') && options.vocab !== null) {\n      this.vocab = Vocab.fromJSON(options.vocab);\n      delete options.vocab;\n    }\n\n    this.bindEquation();\n  }\n\n  fromJSONString(json) {\n    return this.fromJSON(JSON.parse(json));\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    let model = this.model;\n    let equations = this.model.equations;\n    let equation = equations[1];\n    let states = equation.states;\n    let jsonString = JSON.stringify(this.toJSON());\n\n    function matrixOrigin(m, stateIndex) {\n      for (let i = 0, max = states.length; i < max; i++) {\n        let state = states[i];\n\n        if (i === stateIndex) {\n          let j = previousConnectionIndex(m);\n          switch (m) {\n            case state.left:\n              if (j > -1) {\n                return `typeof prevStates[${ j }] === 'object' ? prevStates[${ j }].product : new Matrix(${ m.rows }, ${ m.columns })`;\n              }\n            case state.right:\n              if (j > -1) {\n                return `typeof prevStates[${ j }] === 'object' ? prevStates[${ j }].product : new Matrix(${ m.rows }, ${ m.columns })`;\n              }\n            case state.product:\n              return `new Matrix(${ m.rows }, ${ m.columns })`;\n            default:\n              throw Error('unknown state');\n          }\n        }\n\n        if (m === state.product) return `states[${ i }].product`;\n        if (m === state.right) return `states[${ i }].right`;\n        if (m === state.left) return `states[${ i }].left`;\n      }\n    }\n\n    function previousConnectionIndex(m) {\n      const connection = model.equationConnections[0];\n      const states = equations[0].states;\n      for (let i = 0, max = states.length; i < max; i++) {\n        if (states[i].product === m) {\n          return i;\n        }\n      }\n      return connection.indexOf(m);\n    }\n\n    function matrixToString(m, stateIndex) {\n      if (!m || !m.rows || !m.columns) return 'null';\n\n      if (m === model.input) return `json.input`;\n      if (m === model.outputConnector) return `json.outputConnector`;\n      if (m === model.output) return `json.output`;\n\n      for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {\n        let hiddenLayer = model.hiddenLayers[i];\n        for (let p in hiddenLayer) {\n          if (!hiddenLayer.hasOwnProperty(p)) continue;\n          if (hiddenLayer[p] !== m) continue;\n          return `json.hiddenLayers[${ i }].${ p }`;\n        }\n      }\n\n      return matrixOrigin(m, stateIndex);\n    }\n\n    function toInner(fnString) {\n      // crude, but should be sufficient for now\n      // function() { body }\n      fnString = fnString.toString().split('{');\n      fnString.shift();\n      // body }\n      fnString = fnString.join('{');\n      fnString = fnString.split('}');\n      fnString.pop();\n      // body\n      return fnString.join('}').split('\\n').join('\\n        ');\n    }\n\n    function fileName(fnName) {\n      return `src/recurrent/matrix/${ fnName.replace(/[A-Z]/g, function(value) { return '-' + value.toLowerCase(); }) }.js`;\n    }\n\n    let statesRaw = [];\n    let usedFunctionNames = {};\n    let innerFunctionsSwitch = [];\n    for (let i = 0, max = states.length; i < max; i++) {\n      let state = states[i];\n      statesRaw.push(`states[${ i }] = {\n      name: '${ state.forwardFn.name }',\n      left: ${ matrixToString(state.left, i) },\n      right: ${ matrixToString(state.right, i) },\n      product: ${ matrixToString(state.product, i) }\n    }`);\n\n      let fnName = state.forwardFn.name;\n      if (!usedFunctionNames[fnName]) {\n        usedFunctionNames[fnName] = true;\n        innerFunctionsSwitch.push(\n          `        case '${ fnName }': //compiled from ${ fileName(fnName) }\n          ${ toInner(state.forwardFn.toString()) }\n          break;`\n        );\n      }\n    }\n\n    return new Function('input', 'maxPredictionLength', 'isSampleI', 'temperature', `\n  if (typeof input === 'undefined') input = [];\n  if (typeof maxPredictionLength === 'undefined') maxPredictionLength = 100;\n  if (typeof isSampleI === 'undefined') isSampleI = false;\n  if (typeof temperature === 'undefined') temperature = 1;\n  \n  ${\n      (this.vocab !== null && typeof this.formatDataIn === 'function')\n        ? 'input = formatDataIn(input);' \n        : ''\n    }\n        \n  var json = ${ jsonString };\n  var _i = 0;\n  var output = [];\n  var states = [];\n  var prevStates;\n  while (true) {\n    var previousIndex = (_i === 0\n        ? 0\n        : _i < input.length\n          ? input[_i - 1] + 1\n          : output[_i - 1])\n          ;\n    var rowPluckIndex = previousIndex;\n    prevStates = states;\n    states = [];\n    ${ statesRaw.join(';\\n    ') };\n    for (var stateIndex = 0, stateMax = ${ statesRaw.length }; stateIndex < stateMax; stateIndex++) {\n      var state = states[stateIndex];\n      var product = state.product;\n      var left = state.left;\n      var right = state.right;\n      \n      switch (state.name) {\n${ innerFunctionsSwitch.join('\\n') }\n      }\n    }\n    \n    var logProbabilities = state.product;\n    if (temperature !== 1 && isSampleI) {\n      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {\n        logProbabilities.weights[q] /= temperature;\n      }\n    }\n\n    var probs = softmax(logProbabilities);\n    var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);\n    \n    _i++;\n    if (nextIndex === 0) {\n      break;\n    }\n    if (_i >= maxPredictionLength) {\n      break;\n    }\n\n    output.push(nextIndex);\n  }\n  ${ (this.vocab !== null && typeof this.formatDataOut === 'function') \n      ? 'return formatDataOut(output.slice(input.length).map(function(value) { return value - 1; }))'\n      : 'return output.slice(input.length).map(function(value) { return value - 1; })' };\n  \n  function Matrix(rows, columns) {\n    this.rows = rows;\n    this.columns = columns;\n    this.weights = zeros(rows * columns);\n    this.recurrence = zeros(rows * columns);\n  }\n  ${ this.vocab !== null && typeof this.formatDataIn === 'function'\n      ? `function formatDataIn(input, output) { ${ toInner(this.formatDataIn.toString()).replace('this.vocab', 'json.options.vocab') } }`\n      : '' }\n  ${ this.vocab !== null && typeof this.formatDataOut === 'function'\n        ? `function formatDataOut(output) { ${ toInner(this.formatDataIn.toString()).replace('this.vocab', 'json.options.vocab') } }` \n        : '' }\n  ${ (this.vocab !== null) ? this.vocab.toFunctionString('json.options.vocab') : '' }\n  ${ zeros.toString() }\n  ${ softmax.toString().replace('_2.default', 'Matrix') }\n  ${ randomF.toString() }\n  ${ sampleI.toString() }\n  ${ maxI.toString() }`)\n  }\n}\n\nRNN.defaults = {\n  inputSize: 20,\n  inputRange: 20,\n  hiddenSizes:[20,20],\n  outputSize: 20,\n  learningRate: 0.01,\n  decayRate: 0.999,\n  smoothEps: 1e-8,\n  regc: 0.000001,\n  clipval: 5,\n  json: null,\n  setupData: function(data) {\n    if (!data[0].hasOwnProperty('input') || !data[0].hasOwnProperty('output')) {\n      return data;\n    }\n    let values = [];\n    for (let i = 0; i < data.length; i++) {\n      values = values.concat(data[i].input, data[i].output);\n    }\n    this.vocab = Vocab.fromArrayInputOutput(values);\n    const result = [];\n    for (let i = 0, max = data.length; i < max; i++) {\n      result.push(this.formatDataIn(data[i].input, data[i].output));\n    }\n    return result;\n  },\n  formatDataIn: function(input, output = null) {\n    if (this.vocab !== null) {\n      if (this.vocab.indexTable.hasOwnProperty('stop-input')) {\n        return this.vocab.toIndexesInputOutput(input, output);\n      } else {\n        return this.vocab.toIndexes(input);\n      }\n    }\n    return input;\n  },\n  formatDataOut: function(input, output) {\n    if (this.vocab !== null) {\n      return this.vocab\n        .toCharacters(output)\n        .join('');\n    }\n    return output;\n  },\n  vocab: null\n};\n\nRNN.trainDefaults = {\n  iterations: 20000,\n  errorThresh: 0.005,\n  log: false,\n  logPeriod: 10,\n  learningRate: 0.3,\n  callback: null,\n  callbackPeriod: 10,\n  keepNetworkIntact: false\n};"]}