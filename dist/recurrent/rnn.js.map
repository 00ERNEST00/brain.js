{"version":3,"sources":["../../src/recurrent/rnn.js"],"names":["defaults","isBackPropagate","inputSize","inputRange","hiddenSizes","outputSize","learningRate","decayRate","smoothEps","regc","clipval","json","RNN","options","p","hasOwnProperty","stepCache","runs","totalPerplexity","totalCost","ratioClipped","model","input","hiddenLayers","output","equations","allMatrices","outputMatrixIndex","equationConnections","fromJSON","mapModel","push","getModel","prevSize","d","length","hiddenSize","weight","transition","bias","equation","inputMatrix","previousResult","hiddenLayer","relu","bind","add","multiply","lastHiddenSize","outputConnector","outputs","equationConnection","map","size","getEquation","inputMatrixToRow","i","max","concat","createInputMatrix","Error","createHiddenLayers","hiddenMatrix","property","createOutputMatrix","train","runBackpropagate","step","prediction","predict","log2ppl","cost","bindEquation","source","target","run","logProbabilities","probabilities","Math","log2","weights","log","recurrence","pow","stepSize","numClipped","numTot","matrixIndexes","matrixIndex","matrix","rows","columns","cache","n","mdwi","sqrt","maxPredictionLength","_sampleI","temperature","result","ix","q","nq","probs","value","layer","outputLayer","node","sizes","sum","biases","k","exp","data","type","constructor","name","toJSON","layers","states","modelAsString","JSON","stringify","matrixOrigin","m","requestedStateIndex","state","product","left","right","matrixToString","stateIndex","toInner","fnString","toString","split","shift","join","pop","fileName","fnName","replace","toLowerCase","statesRaw","usedFunctionNames","innerFunctionsSwitch","forwardFn","Function"],"mappings":"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","file":"rnn.js","sourcesContent":["import Matrix from './matrix';\nimport sampleI from './matrix/sample-i';\nimport maxI from './matrix/max-i';\nimport RandomMatrix from './matrix/random-matrix';\nimport softmax from './matrix/softmax';\nimport Equation from './matrix/equation';\nimport copy from './matrix/copy';\n\nconst defaults = {\n  isBackPropagate: true,\n  // hidden size should be a list\n  inputSize: 20,\n  inputRange: 20,\n  hiddenSizes:[20,20],\n  outputSize: 20,\n  learningRate: 0.01,\n  decayRate: 0.999,\n  smoothEps: 1e-8,\n  regc: 0.000001,\n  clipval: 5,\n  json: null\n};\n\nexport default class RNN {\n  constructor(options) {\n    options = options || {};\n\n    for (let p in defaults) {\n      if (defaults.hasOwnProperty(p) && p !== 'isBackPropagate') {\n        this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n      }\n    }\n\n    this.stepCache = {};\n    this.runs = 0;\n    this.totalPerplexity = null;\n    this.totalCost = null;\n    this.ratioClipped = null;\n\n    this.model = {\n      input: null,\n      hiddenLayers: [],\n      output: null,\n      equations: [],\n      allMatrices: [],\n      outputMatrixIndex: -1,\n      equationConnections: []\n    };\n\n    if (this.json) {\n      this.fromJSON(this.json);\n    } else {\n      this.mapModel();\n    }\n  }\n\n  createHiddenLayers() {\n    let hiddenSizes = this.hiddenSizes;\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    //0 is end, so add 1 to offset\n    hiddenLayers.push(this.getModel(hiddenSizes[0], this.inputSize));\n    let prevSize = hiddenSizes[0];\n\n    for (let d = 1; d < hiddenSizes.length; d++) { // loop over depths\n      let hiddenSize = hiddenSizes[d];\n      hiddenLayers.push(this.getModel(hiddenSize, prevSize));\n      prevSize = hiddenSize;\n    }\n  }\n\n  getModel(hiddenSize, prevSize) {\n    return {\n      //wxh\n      weight: new RandomMatrix(hiddenSize, prevSize, 0.08),\n      //whh\n      transition: new RandomMatrix(hiddenSize, hiddenSize, 0.08),\n      //bhh\n      bias: new Matrix(hiddenSize, 1)\n    };\n  }\n\n  /**\n   *\n   * @param {Equation} equation\n   * @param {Matrix} inputMatrix\n   * @param {Matrix} previousResult\n   * @param {Object} hiddenLayer\n   * @returns {Matrix}\n   */\n  getEquation(equation, inputMatrix, previousResult, hiddenLayer) {\n    let relu = equation.relu.bind(equation);\n    let add = equation.add.bind(equation);\n    let multiply = equation.multiply.bind(equation);\n\n    return relu(\n      add(\n        add(\n          multiply(\n            hiddenLayer.weight,\n            inputMatrix\n          ),\n          multiply(\n            hiddenLayer.transition,\n            previousResult\n          )\n        ),\n        hiddenLayer.bias\n      )\n    );\n  }\n\n  createInputMatrix() {\n    //0 is end, so add 1 to offset\n    this.model.input = new RandomMatrix(this.inputRange + 1, this.inputSize, 0.08);\n  }\n\n  createOutputMatrix() {\n    let model = this.model;\n    let outputSize = this.outputSize;\n    let lastHiddenSize = this.hiddenSizes[this.hiddenSizes.length - 1];\n\n    //0 is end, so add 1 to offset\n    //whd\n    model.outputConnector = new RandomMatrix(outputSize + 1, lastHiddenSize, 0.08);\n    //0 is end, so add 1 to offset\n    //bd\n    model.output = new Matrix(outputSize + 1, 1);\n  }\n\n  bindEquation() {\n    let model = this.model;\n    let hiddenSizes = this.hiddenSizes;\n    let hiddenLayers = model.hiddenLayers;\n    let equation = new Equation();\n    let outputs = [];\n    let equationConnection = model.equationConnections.length > 0\n      ? model.equationConnections[model.equationConnections.length - 1]\n      : hiddenSizes.map((size) => new Matrix(hiddenSizes[0], 1))\n      ;\n\n      // 0 index\n    let output = this.getEquation(equation, equation.inputMatrixToRow(model.input), equationConnection[0], hiddenLayers[0]);\n    outputs.push(output);\n    // 1+ indexes\n    for (let i = 1, max = hiddenSizes.length; i < max; i++) {\n      output = this.getEquation(equation, output, equationConnection[i], hiddenLayers[i]);\n      outputs.push(output);\n    }\n\n    model.equationConnections.push(outputs);\n    equation.add(equation.multiply(model.outputConnector, output), model.output);\n    model.allMatrices = model.allMatrices.concat(equation.allMatrices);\n    model.equations.push(equation);\n  }\n\n  mapModel() {\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    let allMatrices = model.allMatrices;\n\n    this.createInputMatrix();\n    if (!model.input) throw new Error('net.model.input not set');\n    allMatrices.push(model.input);\n\n    this.createHiddenLayers();\n    if (!model.hiddenLayers.length) throw new Error('net.hiddenLayers not set');\n    for (let i = 0, max = hiddenLayers.length; i < max; i++) {\n      let hiddenMatrix = hiddenLayers[i];\n      for (let property in hiddenMatrix) {\n        if (!hiddenMatrix.hasOwnProperty(property)) continue;\n        allMatrices.push(hiddenMatrix[property]);\n      }\n    }\n\n    this.createOutputMatrix();\n    if (!model.outputConnector) throw new Error('net.model.outputConnector not set');\n    if (!model.output) throw new Error('net.model.output not set');\n\n    allMatrices.push(model.outputConnector);\n    model.outputMatrixIndex = allMatrices.length;\n    allMatrices.push(model.output);\n  }\n\n  run(input) {\n    this.train(input);\n    this.runBackpropagate(input);\n    this.step();\n  }\n\n  runPredict() {\n    let prediction = this.predict();\n    this.runBackpropagate(prediction);\n    this.step();\n    return prediction;\n  }\n\n  train(input) {\n    this.runs++;\n    let model = this.model;\n    let max = input.length;\n    let log2ppl = 0;\n    let cost = 0;\n\n    let i;\n    let equation;\n    while (model.equations.length <= input.length + 1) {//first and last are zeros\n      this.bindEquation();\n    }\n    for (i = -1; i < max; i++) {\n      // start and end tokens are zeros\n      equation = model.equations[i + 1];\n\n      let source = (i === -1 ? 0 : input[i] + 1); // first step: start with START token\n      let target = (i === max - 1 ? 0 : input[i + 1] + 1); // last step: end with END token\n      let output = equation.run(source);\n      // set gradients into log probabilities\n      let logProbabilities = output; // interpret output as log probabilities\n      let probabilities = softmax(output); // compute the softmax probabilities\n\n      log2ppl += -Math.log2(probabilities.weights[target]); // accumulate base 2 log prob and do smoothing\n      cost += -Math.log(probabilities.weights[target]);\n\n      // write gradients into log probabilities\n      logProbabilities.recurrence = probabilities.weights;\n      logProbabilities.recurrence[target] -= 1;\n    }\n\n    this.totalPerplexity = Math.pow(2, log2ppl / (max - 1));\n    this.totalCost = cost;\n  }\n\n  runBackpropagate(input) {\n    var i = input.length + 0;\n    var model = this.model;\n    var equations = model.equations;\n    while(i > 0) {\n      equations[i].runBackpropagate(input[i - 1] + 1);\n      i--;\n    }\n    equations[0].runBackpropagate(0);\n  }\n\n  step() {\n    // perform parameter update\n    let stepSize = this.learningRate;\n    let regc = this.regc;\n    let clipval = this.clipval;\n    let model = this.model;\n    let numClipped = 0;\n    let numTot = 0;\n    let allMatrices = model.allMatrices;\n    let matrixIndexes = allMatrices.length;\n    for (let matrixIndex = 0; matrixIndex < matrixIndexes; matrixIndex++) {\n      let matrix = allMatrices[matrixIndex];\n      if (!(matrixIndex in this.stepCache)) {\n        this.stepCache[matrixIndex] = new Matrix(matrix.rows, matrix.columns);\n      }\n      let cache = this.stepCache[matrixIndex];\n\n      //if we are in an equation, reset the weights and recurrence to 0, to prevent exploding gradient problem\n      if (matrixIndex > model.outputMatrixIndex) {\n        for (let i = 0, n = matrix.weights.length; i < n; i++) {\n          matrix.weights[i] = 0;\n          matrix.recurrence[i] = 0;\n        }\n        continue;\n      }\n\n      for (let i = 0, n = matrix.weights.length; i < n; i++) {\n        // rmsprop adaptive learning rate\n        let mdwi = matrix.recurrence[i];\n        cache.weights[i] = cache.weights[i] * this.decayRate + (1 - this.decayRate) * mdwi * mdwi;\n        // gradient clip\n        if (mdwi > clipval) {\n          mdwi = clipval;\n          numClipped++;\n        }\n        if (mdwi < -clipval) {\n          mdwi = -clipval;\n          numClipped++;\n        }\n        numTot++;\n\n        // update (and regularize)\n        matrix.weights[i] = matrix.weights[i] + -stepSize * mdwi / Math.sqrt(cache.weights[i] + this.smoothEps) - regc * matrix.weights[i];\n        matrix.recurrence[i] = 0; // reset gradients for next iteration\n      }\n    }\n    this.ratioClipped = numClipped / numTot;\n  }\n\n  predict(maxPredictionLength = 100, _sampleI = false, temperature = 1) {\n    let model = this.model;\n    let result = [];\n    let equation;\n    let i = 0;\n    while (model.equations.length < maxPredictionLength) {\n      this.bindEquation();\n    }\n    while (true) {\n      let ix = result.length === 0 ? 0 : result[result.length - 1];\n      equation = model.equations[i];\n      // sample predicted letter\n      let output = equation.run(ix);\n\n      let logProbabilities = new Matrix(model.output.rows, model.output.columns);\n      copy(logProbabilities, output);\n      if (temperature !== 1 && _sampleI) {\n        // scale log probabilities by temperature and renormalize\n        // if temperature is high, logprobs will go towards zero\n        // and the softmax outputs will be more diffuse. if temperature is\n        // very low, the softmax outputs will be more peaky\n        for (let q = 0, nq = logProbabilities.weights.length; q < nq; q++) {\n          logProbabilities.weights[q] /= temperature;\n        }\n      }\n\n      let probs = softmax(logProbabilities);\n\n      if (_sampleI) {\n        ix = sampleI(probs);\n      } else {\n        ix = maxI(probs);\n      }\n\n      i++;\n      if (ix === 0) {\n        // END token predicted, break out\n        break;\n      }\n      if (i >= maxPredictionLength) {\n        // something is wrong\n        break;\n      }\n\n      result.push(ix);\n    }\n\n    return result.map((value) => value - 1);\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  runInput(input) {\n    this.outputs[0] = input;  // set output state of input layer\n\n    let output = null;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let weights = this.weights[layer][node];\n\n        let sum = this.biases[layer][node];\n        for (let k = 0; k < weights.length; k++) {\n          sum += weights[k] * input[k];\n        }\n        this.outputs[layer][node] = 1 / (1 + Math.exp(-sum));\n      }\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  /**\n   *\n   * @param data\n   * @param options\n   * @returns {{error: number, iterations: number}}\n   */\n  /*train(data, options) {\n    throw new Error('not yet implemented');\n    //data = this.formatData(data);\n\n    options = options || {};\n    let iterations = options.iterations || 20000;\n    let errorThresh = options.errorThresh || 0.005;\n    let log = options.log ? (typeof options.log === 'function' ? options.log : console.log) : false;\n    let logPeriod = options.logPeriod || 10;\n    let learningRate = options.learningRate || this.learningRate || 0.3;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod || 10;\n    let sizes = [];\n    let inputSize = data[0].input.length;\n    let outputSize = data[0].output.length;\n    let hiddenSizes = this.hiddenSizes;\n    if (!hiddenSizes) {\n      sizes.push(Math.max(3, Math.floor(inputSize / 2)));\n    } else {\n      hiddenSizes.forEach(function(size) {\n        sizes.push(size);\n      });\n    }\n\n    sizes.unshift(inputSize);\n    sizes.push(outputSize);\n\n    //this.initialize(sizes, options.keepNetworkIntact);\n\n    let error = 1;\n    for (let i = 0; i < iterations && error > errorThresh; i++) {\n      let sum = 0;\n      for (let j = 0; j < data.length; j++) {\n        let err = this.trainPattern(data[j].input, data[j].output, learningRate);\n        sum += err;\n      }\n      error = sum / data.length;\n\n      if (log && (i % logPeriod == 0)) {\n        log('iterations:', i, 'training error:', error);\n      }\n      if (callback && (i % callbackPeriod == 0)) {\n        callback({ error: error, iterations: i });\n      }\n    }\n\n    return {\n      error: error,\n      iterations: i\n    };\n  }*/\n\n  /**\n   *\n   * @param input\n   * @param target\n   * @param learningRate\n   */\n  trainPattern(input, target, learningRate) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltas(target) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param learningRate\n   */\n  adjustWeights(learningRate) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {*}\n   */\n  formatData(data) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    throw new Error('not yet implemented');\n  }\n\n  toJSON() {\n    let model = this.model;\n    let options = {};\n    for (let p in defaults) {\n      options[p] = this[p];\n    }\n\n    return {\n      type: this.constructor.name,\n      options: options,\n      input: model.input.toJSON(),\n      hiddenLayers: model.hiddenLayers.map(function(hiddenLayer) {\n        let layers = {};\n        for (let p in hiddenLayer) {\n          layers[p] = hiddenLayer[p].toJSON();\n        }\n        return layers;\n      }),\n      outputConnector: this.model.outputConnector.toJSON(),\n      output: this.model.output.toJSON()\n    };\n  }\n\n  fromJSON(json) {\n    this.json = json;\n    let model = this.model;\n    let options = json.options;\n    let allMatrices = model.allMatrices;\n    model.input = Matrix.fromJSON(json.input);\n    allMatrices.push(model.input);\n    model.hiddenLayers = json.hiddenLayers.map(function(hiddenLayer) {\n      let layers = {};\n      for (let p in hiddenLayer) {\n        layers[p] = Matrix.fromJSON(hiddenLayer[p]);\n        allMatrices.push(layers[p]);\n      }\n      return layers;\n    });\n    model.outputConnector = Matrix.fromJSON(json.outputConnector);\n    model.output = Matrix.fromJSON(json.output);\n    allMatrices.push(model.outputConnector, model.output);\n\n    for (let p in defaults) {\n      if (defaults.hasOwnProperty(p) && p !== 'isBackPropagate') {\n        this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n      }\n    }\n\n    this.bindEquation();\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    let model = this.model;\n    let equation = this.model.equations[0];\n    let states = equation.states;\n    let modelAsString = JSON.stringify(this.toJSON());\n\n    function matrixOrigin(m, requestedStateIndex) {\n      for (let i = 0, max = states.length; i < max; i++) {\n        let state = states[i];\n\n        if (i === requestedStateIndex) {\n          switch (m) {\n            case state.product:\n            case state.left:\n            case state.right:\n              return `new Matrix(${ m.rows }, ${ m.columns })`;\n          }\n        }\n\n        if (m === state.product) return `states[${ i }].product`;\n        if (m === state.right) return `states[${ i }].right`;\n        if (m === state.left) return `states[${ i }].left`;\n      }\n    }\n\n    function matrixToString(m, stateIndex) {\n      if (!m) return 'null';\n\n      for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {\n        let hiddenLayer = model.hiddenLayers[i];\n        for (let p in hiddenLayer) {\n          if (hiddenLayer[p] === m) {\n            return `model.hiddenLayers[${ i }].${ p }`;\n          }\n        }\n      }\n      if (m === model.input) return `model.input`;\n      if (m === model.outputConnector) return `model.outputConnector`;\n      if (m === model.output) return `model.output`;\n      return matrixOrigin(m, stateIndex);\n    }\n\n    function toInner(fnString) {\n      //crude, but should be sufficient for now\n      //function() { inner.function.string.here; }\n      fnString = fnString.toString().split('{');\n      fnString.shift();\n      // inner.function.string.here; }\n      fnString = fnString.join('{');\n      fnString = fnString.split('}');\n      fnString.pop();\n      // inner.function.string.here;\n      return fnString.join('}');\n    }\n\n    function fileName(fnName) {\n      return `src/recurrent/matrix/${ fnName.replace(/[A-Z]/g, function(value) { return '-' + value.toLowerCase(); }) }.js`;\n    }\n\n    let statesRaw = [];\n    let usedFunctionNames = {};\n    let innerFunctionsSwitch = [];\n    for (let i = 0, max = states.length; i < max; i++) {\n      let state = states[i];\n      statesRaw.push(`states[${ i }] = {\n        name: '${ state.forwardFn.name }',\n        left: ${ matrixToString(state.left, i) },\n        right: ${ matrixToString(state.right, i) },\n        product: ${ matrixToString(state.product, i) }\n      };`);\n\n      let fnName = state.forwardFn.name;\n      if (!usedFunctionNames[fnName]) {\n        usedFunctionNames[fnName] = true;\n        innerFunctionsSwitch.push(`\n        case '${ fnName }': //compiled from ${ fileName(fnName) }\n          ${ toInner(state.forwardFn.toString()) }\n          break;\n        `);\n      }\n    }\n\n    return new Function('input', `\n      var model = ${ modelAsString };\n      \n      function Matrix(rows, columns) {\n        this.rows = rows;\n        this.columns = columns;\n        this.weights = zeros(rows * columns);\n        this.recurrence = zeros(rows * columns);\n      }\n      \n      function zeros(size) {\n        if (typeof Float64Array !== 'undefined') return new Float64Array(size);\n        var array = new Array(size);\n        for (var i = 0; i < size; i++) {\n          array[i] = 0;\n        }\n        return array;\n      }\n      \n      for (var inputIndex = 0, inputMax = input.length; inputIndex < inputMax; inputIndex++) {\n        var ixSource = (inputIndex === -1 ? 0 : input[inputIndex]); // first step: start with START token\n        var ixTarget = (inputIndex === inputMax - 1 ? 0 : input[inputIndex + 1]); // last step: end with END token\n        var rowPluckIndex = inputIndex; //connect up to rowPluck\n        var states = {};\n        ${ statesRaw.join('\\n') }\n        for (var stateIndex = 0, stateMax = ${ statesRaw.length }; stateIndex < stateMax; stateIndex++) {\n          var state = states[stateIndex];\n          var product = state.product;\n          var left = state.left;\n          var right = state.right;\n          \n          switch (state.name) {\n            ${ innerFunctionsSwitch.join('\\n') }\n          }\n        }\n      }\n      \n      return state.product;\n    `);\n  }\n}\n"]}