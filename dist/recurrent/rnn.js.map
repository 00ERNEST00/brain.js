{"version":3,"sources":["../../src/recurrent/rnn.js"],"names":["defaults","isBackPropagate","inputSize","inputRange","hiddenSizes","outputSize","learningRate","decayRate","smoothEps","regc","clipval","json","RNN","options","p","hasOwnProperty","stepCache","runs","logProbabilities","totalPerplexity","totalCost","model","input","inputRows","equations","hidden","output","allMatrices","hiddenLayers","fromJSON","createModel","mapModel","push","getModel","prevSize","d","length","hiddenSize","weight","transition","bias","equation","inputMatrix","size","hiddenLayer","relu","bind","add","multiply","previousResult","result","lastHiddenSize","outputConnector","getEquation","inputMatrixToRow","i","max","bindEquation","createInputMatrix","Error","createOutputMatrix","createEquations","hiddenMatrix","property","train","runBackpropagate","step","log2ppl","cost","ixSource","ixTarget","run","updatePreviousResults","probabilities","Math","log2","weights","log","recurrence","slice","pow","stepSize","numClipped","numTot","matrixIndexes","matrixIndex","matrix","rows","columns","cache","n","mdwi","sqrt","ratioClipped","_sampleI","temperature","predictionLength","ix","lh","q","nq","probs","outputs","layer","outputLayer","node","sizes","sum","biases","k","exp","target","data","type","constructor","name","toJSON","map","layers","states","modelAsString","JSON","stringify","matrixOrigin","m","requestedStateIndex","state","product","left","right","matrixToString","stateIndex","toInner","fnString","toString","split","shift","join","pop","fileName","fnName","replace","value","toLowerCase","statesRaw","usedFunctionNames","innerFunctionsSwitch","forwardFn","Function"],"mappings":"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","file":"rnn.js","sourcesContent":["import sampleI from '../matrix/sample-i';\nimport maxI from '../matrix/max-i';\nimport Matrix from '../matrix';\nimport RandomMatrix from '../matrix/random-matrix';\nimport softmax from '../matrix/softmax';\nimport Equation from '../matrix/equation';\n\nconst defaults = {\n  isBackPropagate: true,\n  // hidden size should be a list\n  inputSize: 20,\n  inputRange: 20,\n  hiddenSizes:[20,20],\n  outputSize: 20,\n  learningRate: 0.01,\n  decayRate: 0.999,\n  smoothEps: 1e-8,\n  regc: 0.000001,\n  clipval: 5,\n  json: null\n};\n\nexport default class RNN {\n  constructor(options) {\n    options = options || {};\n\n    for (let p in defaults) {\n      if (defaults.hasOwnProperty(p) && p !== 'isBackPropagate') {\n        this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n      }\n    }\n\n    this.stepCache = {};\n    this.runs = 0;\n    this.logProbabilities = null;\n    this.totalPerplexity = null;\n    this.totalCost = null;\n\n    this.model = {\n      input: [],\n      inputRows: [],\n      equations: [],\n      hidden: [],\n      output: null,\n      allMatrices: [],\n      hiddenLayers: []\n    };\n\n    if (this.json) {\n      this.fromJSON(this.json);\n    } else {\n      this.createModel();\n      this.mapModel();\n    }\n  }\n\n  createModel() {\n    let hiddenSizes = this.hiddenSizes;\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    //0 is end, so add 1 to offset\n    hiddenLayers.push(this.getModel(hiddenSizes[0], this.inputSize));\n    let prevSize = hiddenSizes[0];\n\n    for (let d = 1; d < hiddenSizes.length; d++) { // loop over depths\n      let hiddenSize = hiddenSizes[d];\n      hiddenLayers.push(this.getModel(hiddenSize, prevSize));\n      prevSize = hiddenSize;\n    }\n  }\n\n  getModel(hiddenSize, prevSize) {\n    return {\n      //wxh\n      weight: new RandomMatrix(hiddenSize, prevSize, 0.08),\n      //whh\n      transition: new RandomMatrix(hiddenSize, hiddenSize, 0.08),\n      //bhh\n      bias: new Matrix(hiddenSize, 1)\n    };\n  }\n\n  /**\n   *\n   * @param {Equation} equation\n   * @param {Matrix} inputMatrix\n   * @param {Number} size\n   * @param {Object} hiddenLayer\n   * @returns {Matrix}\n   */\n  getEquation(equation, inputMatrix, size, hiddenLayer) {\n    let relu = equation.relu.bind(equation);\n    let add = equation.add.bind(equation);\n    let multiply = equation.multiply.bind(equation);\n    let previousResult = equation.previousResult.bind(equation);\n    let result = equation.result.bind(equation);\n\n    return result(\n      relu(\n        add(\n          add(\n            multiply(\n              hiddenLayer.weight,\n              inputMatrix\n            ),\n            multiply(\n              hiddenLayer.transition,\n              previousResult(size)\n            )\n          ),\n          hiddenLayer.bias\n        )\n      )\n    );\n  }\n\n  createInputMatrix() {\n    //0 is end, so add 1 to offset\n    this.model.input = new RandomMatrix(this.inputRange + 1, this.inputSize, 0.08);\n  }\n\n  createOutputMatrix() {\n    let model = this.model;\n    let outputSize = this.outputSize;\n    let lastHiddenSize = this.hiddenSizes[this.hiddenSizes.length - 1];\n\n    //0 is end, so add 1 to offset\n    //whd\n    model.outputConnector = new RandomMatrix(outputSize + 1, lastHiddenSize, 0.08);\n    //0 is end, so add 1 to offset\n    //bd\n    model.output = new Matrix(outputSize + 1, 1);\n  }\n\n  bindEquation() {\n    let model = this.model;\n    let hiddenSizes = this.hiddenSizes;\n    let hiddenLayers = model.hiddenLayers;\n    let equation = new Equation();\n      // 0 index\n    let output = this.getEquation(equation, equation.inputMatrixToRow(model.input), hiddenSizes[0], hiddenLayers[0]);\n    // 1+ indexes\n    for (let i = 1, max = hiddenSizes.length; i < max; i++) {\n      output = this.getEquation(equation, output, hiddenSizes[i], hiddenLayers[i]);\n    }\n    equation.add(equation.multiply(model.outputConnector, output), model.output);\n    model.equations.push(equation);\n  }\n\n  createEquations() {\n    for (var i = 0, max = this.inputSize; i <= max; i++) {\n      this.bindEquation();\n    }\n  }\n\n  mapModel() {\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    let allMatrices = model.allMatrices;\n\n    this.createInputMatrix();\n    if (!model.input) throw new Error('net.model.input not set');\n\n    this.createOutputMatrix();\n    if (!model.outputConnector) throw new Error('net.model.outputConnector not set');\n    if (!model.output) throw new Error('net.model.output not set');\n\n    this.createEquations();\n    if (!model.equations.length) throw new Error('net.equation not set');\n\n    allMatrices.push(model.input);\n\n    for (let i = 0, max = hiddenLayers.length; i < max; i++) {\n      let hiddenMatrix = hiddenLayers[i];\n      for (let property in hiddenMatrix) {\n        if (!hiddenMatrix.hasOwnProperty(property)) continue;\n        allMatrices.push(hiddenMatrix[property]);\n      }\n    }\n\n    allMatrices.push(model.outputConnector);\n    allMatrices.push(model.output);\n  }\n\n  run(input) {\n    this.train(input);\n    this.runBackpropagate(input);\n    this.step();\n  }\n\n  train(input) {\n    this.runs++;\n    let model = this.model;\n    input = input || model.input;\n    let max = input.length;\n    let log2ppl = 0;\n    let cost = 0;\n\n    let i;\n    let output;\n    let equation;\n    for (i = -1; i < max; i++) {\n      // start and end tokens are zeros\n      equation = model.equations[i + 1];\n      let ixSource = (i === -1 ? 0 : input[i]); // first step: start with START token\n      let ixTarget = (i === max - 1 ? 0 : input[i + 1]); // last step: end with END token\n      output = equation.run(ixSource);\n      equation.updatePreviousResults();\n\n      // set gradients into log probabilities\n      this.logProbabilities = output; // interpret output as log probabilities\n      let probabilities = softmax(output); // compute the softmax probabilities\n\n      log2ppl += -Math.log2(probabilities.weights[ixTarget]); // accumulate base 2 log prob and do smoothing\n      cost += -Math.log(probabilities.weights[ixTarget]);\n\n      // write gradients into log probabilities\n      this.logProbabilities.recurrence = probabilities.weights.slice(0);\n      this.logProbabilities.recurrence[ixTarget] -= 1\n    }\n\n    this.totalPerplexity = Math.pow(2, log2ppl / (max - 1));\n    this.totalCost = cost;\n    return output;\n  }\n\n  runBackpropagate(input) {\n    //equation.runBackpropagate(0);\n    var i = input.length;\n    var model = this.model;\n    var equations = model.equations;\n    while(i--) {\n      equations[i].runBackpropagate(input[i]);\n    }\n    //equation.runBackpropagate(0);\n  }\n\n  step() {\n    // perform parameter update\n    let stepSize = this.learningRate;\n    let regc = this.regc;\n    let clipval = this.clipval;\n    let model = this.model;\n    let numClipped = 0;\n    let numTot = 0;\n    let allMatrices = model.allMatrices;\n    let matrixIndexes = allMatrices.length;\n    for (let matrixIndex = 0; matrixIndex < matrixIndexes; matrixIndex++) {\n      let matrix = allMatrices[matrixIndex];\n      if (!(matrixIndex in this.stepCache)) {\n        this.stepCache[matrixIndex] = new Matrix(matrix.rows, matrix.columns);\n      }\n      let cache = this.stepCache[matrixIndex];\n\n      for (let i = 0, n = matrix.weights.length; i < n; i++) {\n        // rmsprop adaptive learning rate\n        let mdwi = matrix.recurrence[i];\n        cache.weights[i] = cache.weights[i] * this.decayRate + (1 - this.decayRate) * mdwi * mdwi;\n        // gradient clip\n        if (mdwi > clipval) {\n          mdwi = clipval;\n          numClipped++;\n        }\n        if (mdwi < -clipval) {\n          mdwi = -clipval;\n          numClipped++;\n        }\n        numTot++;\n\n        // update (and regularize)\n        matrix.weights[i] += -stepSize * mdwi / Math.sqrt(cache.weights[i] + this.smoothEps) - regc * matrix.weights[i];\n        matrix.recurrence[i] = 0; // reset gradients for next iteration\n      }\n    }\n    this.ratioClipped = numClipped / numTot;\n  }\n\n  predict(_sampleI, temperature, predictionLength) {\n    if (typeof _sampleI === 'undefined') { _sampleI = true; }\n    if (typeof temperature === 'undefined') { temperature = 1; }\n    if (typeof predictionLength === 'undefined') { predictionLength = 100; }\n\n    let result = [];\n    //let prev;\n    let ix;\n    let equation;\n    //equation.resetPreviousResults();\n    while (true) {\n      ix = result.length === 0 ? 0 : result[result.length - 1];\n      equation = this.model.equations[result.length - 1];\n      let lh = equation.run(ix);\n      //equation.updatePreviousResults();\n      //prev = clone(lh);\n      // sample predicted letter\n      this.logProbabilities = lh;\n      if (temperature !== 1 && _sampleI) {\n        // scale log probabilities by temperature and renormalize\n        // if temperature is high, logprobs will go towards zero\n        // and the softmax outputs will be more diffuse. if temperature is\n        // very low, the softmax outputs will be more peaky\n        for (let q = 0, nq = this.logProbabilities.weights.length; q < nq; q++) {\n          this.logProbabilities.weights[q] /= temperature;\n        }\n      }\n\n      let probs = softmax(this.logProbabilities);\n\n      if (_sampleI) {\n        ix = sampleI(probs);\n      } else {\n        ix = maxI(probs);\n      }\n\n      if (ix === 0) {\n        // END token predicted, break out\n        break;\n      }\n      if (result.length > predictionLength) {\n        // something is wrong\n        break;\n      }\n\n      result.push(ix);\n    }\n\n    return result;\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  runInput(input) {\n    this.outputs[0] = input;  // set output state of input layer\n\n    let output = null;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let weights = this.weights[layer][node];\n\n        let sum = this.biases[layer][node];\n        for (let k = 0; k < weights.length; k++) {\n          sum += weights[k] * input[k];\n        }\n        this.outputs[layer][node] = 1 / (1 + Math.exp(-sum));\n      }\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  /**\n   *\n   * @param data\n   * @param options\n   * @returns {{error: number, iterations: number}}\n   */\n  /*train(data, options) {\n    throw new Error('not yet implemented');\n    //data = this.formatData(data);\n\n    options = options || {};\n    let iterations = options.iterations || 20000;\n    let errorThresh = options.errorThresh || 0.005;\n    let log = options.log ? (typeof options.log === 'function' ? options.log : console.log) : false;\n    let logPeriod = options.logPeriod || 10;\n    let learningRate = options.learningRate || this.learningRate || 0.3;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod || 10;\n    let sizes = [];\n    let inputSize = data[0].input.length;\n    let outputSize = data[0].output.length;\n    let hiddenSizes = this.hiddenSizes;\n    if (!hiddenSizes) {\n      sizes.push(Math.max(3, Math.floor(inputSize / 2)));\n    } else {\n      hiddenSizes.forEach(function(size) {\n        sizes.push(size);\n      });\n    }\n\n    sizes.unshift(inputSize);\n    sizes.push(outputSize);\n\n    //this.initialize(sizes, options.keepNetworkIntact);\n\n    let error = 1;\n    for (let i = 0; i < iterations && error > errorThresh; i++) {\n      let sum = 0;\n      for (let j = 0; j < data.length; j++) {\n        let err = this.trainPattern(data[j].input, data[j].output, learningRate);\n        sum += err;\n      }\n      error = sum / data.length;\n\n      if (log && (i % logPeriod == 0)) {\n        log('iterations:', i, 'training error:', error);\n      }\n      if (callback && (i % callbackPeriod == 0)) {\n        callback({ error: error, iterations: i });\n      }\n    }\n\n    return {\n      error: error,\n      iterations: i\n    };\n  }*/\n\n  /**\n   *\n   * @param input\n   * @param target\n   * @param learningRate\n   */\n  trainPattern(input, target, learningRate) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltas(target) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param learningRate\n   */\n  adjustWeights(learningRate) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {*}\n   */\n  formatData(data) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    throw new Error('not yet implemented');\n  }\n\n  toJSON() {\n    let model = this.model;\n    let options = {};\n    for (let p in defaults) {\n      options[p] = this[p];\n    }\n\n    return {\n      type: this.constructor.name,\n      options: options,\n      input: model.input.toJSON(),\n      hiddenLayers: model.hiddenLayers.map(function(hiddenLayer) {\n        let layers = {};\n        for (let p in hiddenLayer) {\n          layers[p] = hiddenLayer[p].toJSON();\n        }\n        return layers;\n      }),\n      outputConnector: this.model.outputConnector.toJSON(),\n      output: this.model.output.toJSON()\n    };\n  }\n\n  fromJSON(json) {\n    this.json = json;\n    let model = this.model;\n    let options = json.options;\n    let allMatrices = model.allMatrices;\n    model.input = Matrix.fromJSON(json.input);\n    allMatrices.push(model.input);\n    model.hiddenLayers = json.hiddenLayers.map(function(hiddenLayer) {\n      let layers = {};\n      for (let p in hiddenLayer) {\n        layers[p] = Matrix.fromJSON(hiddenLayer[p]);\n        allMatrices.push(layers[p]);\n      }\n      return layers;\n    });\n    model.outputConnector = Matrix.fromJSON(json.outputConnector);\n    model.output = Matrix.fromJSON(json.output);\n    allMatrices.push(model.outputConnector, model.output);\n\n    for (let p in defaults) {\n      if (defaults.hasOwnProperty(p) && p !== 'isBackPropagate') {\n        this[p] = options.hasOwnProperty(p) ? options[p] : defaults[p];\n      }\n    }\n\n    this.bindEquation();\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    let model = this.model;\n    let equation = this.model.equations[0];\n    let states = equation.states;\n    let modelAsString = JSON.stringify(this.toJSON());\n\n    function matrixOrigin(m, requestedStateIndex) {\n      for (let i = 0, max = states.length; i < max; i++) {\n        let state = states[i];\n\n        if (i === requestedStateIndex) {\n          switch (m) {\n            case state.product:\n            case state.left:\n            case state.right:\n              return `new Matrix(${ m.rows }, ${ m.columns })`;\n          }\n        }\n\n        if (m === state.product) return `states[${ i }].product`;\n        if (m === state.right) return `states[${ i }].right`;\n        if (m === state.left) return `states[${ i }].left`;\n      }\n    }\n\n    function matrixToString(m, stateIndex) {\n      if (!m) return 'null';\n\n      for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {\n        let hiddenLayer = model.hiddenLayers[i];\n        for (let p in hiddenLayer) {\n          if (hiddenLayer[p] === m) {\n            return `model.hiddenLayers[${ i }].${ p }`;\n          }\n        }\n      }\n      if (m === model.input) return `model.input`;\n      if (m === model.outputConnector) return `model.outputConnector`;\n      if (m === model.output) return `model.output`;\n      return matrixOrigin(m, stateIndex);\n    }\n\n    function toInner(fnString) {\n      //crude, but should be sufficient for now\n      //function() { inner.function.string.here; }\n      fnString = fnString.toString().split('{');\n      fnString.shift();\n      // inner.function.string.here; }\n      fnString = fnString.join('{');\n      fnString = fnString.split('}');\n      fnString.pop();\n      // inner.function.string.here;\n      return fnString.join('}');\n    }\n\n    function fileName(fnName) {\n      return `src/recurrent/matrix/${ fnName.replace(/[A-Z]/g, function(value) { return '-' + value.toLowerCase(); }) }.js`;\n    }\n\n    let statesRaw = [];\n    let usedFunctionNames = {};\n    let innerFunctionsSwitch = [];\n    for (let i = 0, max = states.length; i < max; i++) {\n      let state = states[i];\n      statesRaw.push(`states[${ i }] = {\n        name: '${ state.forwardFn.name }',\n        left: ${ matrixToString(state.left, i) },\n        right: ${ matrixToString(state.right, i) },\n        product: ${ matrixToString(state.product, i) }\n      };`);\n\n      let fnName = state.forwardFn.name;\n      if (!usedFunctionNames[fnName]) {\n        usedFunctionNames[fnName] = true;\n        innerFunctionsSwitch.push(`\n        case '${ fnName }': //compiled from ${ fileName(fnName) }\n          ${ toInner(state.forwardFn.toString()) }\n          break;\n        `);\n      }\n    }\n\n    return new Function('input', `\n      var model = ${ modelAsString };\n      \n      function Matrix(rows, columns) {\n        this.rows = rows;\n        this.columns = columns;\n        this.weights = zeros(rows * columns);\n        this.recurrence = zeros(rows * columns);\n      }\n      \n      function zeros(size) {\n        if (typeof Float64Array !== 'undefined') return new Float64Array(size);\n        var array = new Array(size);\n        for (var i = 0; i < size; i++) {\n          array[i] = 0;\n        }\n        return array;\n      }\n      \n      for (var inputIndex = 0, inputMax = input.length; inputIndex < inputMax; inputIndex++) {\n        var ixSource = (inputIndex === -1 ? 0 : input[inputIndex]); // first step: start with START token\n        var ixTarget = (inputIndex === inputMax - 1 ? 0 : input[inputIndex + 1]); // last step: end with END token\n        var rowPluckIndex = inputIndex; //connect up to rowPluck\n        var states = {};\n        ${ statesRaw.join('\\n') }\n        for (var stateIndex = 0, stateMax = ${ statesRaw.length }; stateIndex < stateMax; stateIndex++) {\n          var state = states[stateIndex];\n          var product = state.product;\n          var left = state.left;\n          var right = state.right;\n          \n          switch (state.name) {\n            ${ innerFunctionsSwitch.join('\\n') }\n          }\n        }\n      }\n      \n      return state.product;\n    `);\n  }\n}\n"]}