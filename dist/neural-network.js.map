{"version":3,"sources":["../src/neural-network.js"],"names":["NeuralNetwork","iterations","errorThresh","log","logPeriod","learningRate","callback","callbackPeriod","trainTimeMs","Infinity","momentum","binaryThresh","hiddenLayers","activation","options","Object","assign","constructor","defaults","hiddenSizes","sizes","outputLayer","biases","weights","outputs","deltas","changes","errors","prototype","hasOwnProperty","runInput","calculateDeltas","data","inputSize","input","length","outputSize","output","push","Math","max","floor","forEach","size","unshift","layer","Array","node","prevSize","setActivation","runInputSigmoid","calculateDeltasSigmoid","runInputRelu","calculateDeltasRelu","runInputLeakyRelu","calculateDeltasLeakyRelu","runInputTanh","calculateDeltasTanh","Error","inputLookup","toArray","outputLookup","toHash","sum","k","exp","tanh","_options","trainDefaults","formatData","console","endTime","Date","now","res","error","initialize","i","trainPattern","JSON","parse","stringify","cb","items","thaw","delay","each","stop","done","tick","target","adjustWeights","incoming","delta","change","isArray","tmp","datum","Float32Array","buildLookup","map","value","array","isBinary","falsePos","falseNeg","truePos","trueNeg","misclasses","actual","expected","indexOf","misclass","stats","total","precision","recall","accuracy","layers","nodes","keys","j","bias","index","json","lookupFromHash","nodeHandle","layerNumber","nodeKey","result","w","join","toJSON","layersAsMath","key","Function","opts","neuralNetwork","trainStream"],"mappings":"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","file":"neural-network.js","sourcesContent":["import lookup from './lookup';\nimport TrainStream from './train-stream';\nimport max from './utilities/max';\nimport mse from './utilities/mse';\nimport randos from './utilities/randos';\nimport range from './utilities/range';\nimport toArray from './utilities/to-array';\nimport zeros from './utilities/zeros';\nimport Thaw from 'thaw.js';\n\n/**\n * @param {object} options\n * @constructor\n */\nexport default class NeuralNetwork {\n  static get trainDefaults() {\n    return {\n      iterations: 20000,\n      errorThresh: 0.005,\n      log: false,\n      logPeriod: 10,\n      learningRate: 0.3,\n      callback: null,\n      callbackPeriod: 10,\n      trainTimeMs: -Infinity\n    };\n  }\n\n  static get defaults() {\n    return {\n      learningRate: 0.3,\n      momentum: 0.1,\n      binaryThresh: 0.5,\n      hiddenLayers: null,\n      activation: 'sigmoid'\n    };\n  }\n\n  constructor(options = {}) {\n    Object.assign(this, this.constructor.defaults, options);\n    this.hiddenSizes = options.hiddenLayers;\n\n    this.sizes = null;\n    this.outputLayer = null;\n    this.biases = null; // weights for bias nodes\n    this.weights = null;\n    this.outputs = null;\n\n    // state for training\n    this.deltas = null;\n    this.changes = null; // for momentum\n    this.errors = null;\n\n    if (!this.constructor.prototype.hasOwnProperty('runInput')) {\n      this.runInput = null;\n    }\n    if (!this.constructor.prototype.hasOwnProperty('calculateDeltas')) {\n      this.calculateDeltas = null;\n    }\n  }\n\n  /**\n   *\n   * @param {Number[]} sizes\n   */\n  initialize(data) {\n    let sizes = [];\n    let inputSize = data[0].input.length;\n    let outputSize = data[0].output.length;\n    let hiddenSizes = this.hiddenSizes;\n    if (!hiddenSizes) {\n      sizes.push(Math.max(3, Math.floor(inputSize / 2)));\n    } else {\n      hiddenSizes.forEach(size => {\n        sizes.push(size);\n      });\n    }\n\n    sizes.unshift(inputSize);\n    sizes.push(outputSize);\n\n    this.sizes = sizes;\n    this.outputLayer = this.sizes.length - 1;\n    this.biases = []; // weights for bias nodes\n    this.weights = [];\n    this.outputs = [];\n\n    // state for training\n    this.deltas = [];\n    this.changes = []; // for momentum\n    this.errors = [];\n\n    for (let layer = 0; layer <= this.outputLayer; layer++) {\n      let size = this.sizes[layer];\n      this.deltas[layer] = zeros(size);\n      this.errors[layer] = zeros(size);\n      this.outputs[layer] = zeros(size);\n\n      if (layer > 0) {\n        this.biases[layer] = randos(size);\n        this.weights[layer] = new Array(size);\n        this.changes[layer] = new Array(size);\n\n        for (let node = 0; node < size; node++) {\n          let prevSize = this.sizes[layer - 1];\n          this.weights[layer][node] = randos(prevSize);\n          this.changes[layer][node] = zeros(prevSize);\n        }\n      }\n    }\n\n    this.setActivation();\n  }\n\n  setActivation() {\n    switch (this.activation) {\n      case 'sigmoid':\n        this.runInput = this.runInput || this.runInputSigmoid;\n        this.calculateDeltas = this.calculateDeltas || this.calculateDeltasSigmoid;\n        break;\n      case 'relu':\n        this.runInput = this.runInput || this.runInputRelu;\n        this.calculateDeltas = this.calculateDeltas || this.calculateDeltasRelu;\n        break;\n      case 'leaky-relu':\n        this.runInput = this.runInput || this.runInputLeakyRelu;\n        this.calculateDeltas = this.calculateDeltas || this.calculateDeltasLeakyRelu;\n        break;\n      case 'tanh':\n        this.runInput = this.runInput || this.runInputTanh;\n        this.calculateDeltas = this.calculateDeltas || this.calculateDeltasTanh;\n        break;\n      default:\n        throw new Error('unknown activation ' + this.activation);\n    }\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  run(input) {\n    if (this.inputLookup) {\n      input = lookup.toArray(this.inputLookup, input);\n    }\n\n    let output = [...this.runInput(input)];\n\n    if (this.outputLookup) {\n      output = lookup.toHash(this.outputLookup, output);\n    }\n    return output;\n  }\n\n  /**\n   * trains via sigmoid\n   * @param input\n   * @returns {*}\n   */\n  runInputSigmoid(input) {\n    this.outputs[0] = input;  // set output state of input layer\n\n    let output = null;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let weights = this.weights[layer][node];\n\n        let sum = this.biases[layer][node];\n        for (let k = 0; k < weights.length; k++) {\n          sum += weights[k] * input[k];\n        }\n        //sigmoid\n        this.outputs[layer][node] = 1 / (1 + Math.exp(-sum));\n      }\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  runInputRelu(input) {\n    this.outputs[0] = input;  // set output state of input layer\n\n    let output = null;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let weights = this.weights[layer][node];\n\n        let sum = this.biases[layer][node];\n        for (let k = 0; k < weights.length; k++) {\n          sum += weights[k] * input[k];\n        }\n        //relu\n        this.outputs[layer][node] = (sum < 0 ? 0 : sum);\n      }\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  runInputLeakyRelu(input) {\n    this.outputs[0] = input;  // set output state of input layer\n\n    let output = null;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let weights = this.weights[layer][node];\n\n        let sum = this.biases[layer][node];\n        for (let k = 0; k < weights.length; k++) {\n          sum += weights[k] * input[k];\n        }\n        //leaky relu\n        this.outputs[layer][node] = (sum < 0 ? 0 : 0.01 * sum);\n      }\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  runInputTanh(input) {\n    this.outputs[0] = input;  // set output state of input layer\n\n    let output = null;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let weights = this.weights[layer][node];\n\n        let sum = this.biases[layer][node];\n        for (let k = 0; k < weights.length; k++) {\n          sum += weights[k] * input[k];\n        }\n        //tanh\n        this.outputs[layer][node] = Math.tanh(sum);\n      }\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  /**\n   *\n   * @param data\n   * @param _options\n   * @returns {{error: number, iterations: number}}\n   */\n  train (data, _options = {}) {\n    const options = Object.assign({}, this.constructor.trainDefaults, _options);\n    data = this.formatData(data);\n    let iterations = options.iterations;\n    let errorThresh = options.errorThresh;\n    let log = options.log === true ? console.log : options.log;\n    let logPeriod = options.logPeriod;\n    let learningRate = _options.learningRate || this.learningRate || options.learningRate;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod;\n    let endTime = Date.now() + options.trainTimeMs;\n    var res = {\n      error: 1,\n      iterations: 0\n    };\n\n    if (this.sizes === null) {\n      this.initialize(data);\n    }\n\n    while (res.iterations < iterations && res.error > errorThresh && Date.now () > endTime) {\n      res.iterations++;\n      let sum = 0;\n      for (var i = 0; i < data.length; ++i) {\n        sum += this.trainPattern (data[i].input, data[i].output, learningRate);\n      }\n\n      res.error = sum / data.length;\n\n      if (log && (res.iterations % logPeriod === 0)) {\n        log('iterations:', res.iterations, 'training error:', res.error);\n      }\n\n      if (callback && (res.iterations % callbackPeriod === 0)) {\n        // JSON.parse/stringify to clone the object so the callback doesn't have side effects to training\n        callback (JSON.parse (JSON.stringify (res)));\n      }\n    }\n    return res;\n  }\n\n  /**\n   *\n   * @param data\n   * @param _options\n   * @param cb\n   * @returns {{error: number, iterations: number}}\n   */\n  trainAsync (data, _options = {}, cb = function() {}) {\n    if (typeof _options === \"function\") {\n      cb = _options;\n      _options = {};\n    }\n    const options = Object.assign({}, this.constructor.trainDefaults, _options);\n    data = this.formatData(data);\n    let iterations = options.iterations;\n    let errorThresh = options.errorThresh;\n    let log = options.log === true ? console.log : options.log;\n    let logPeriod = options.logPeriod;\n    let learningRate = _options.learningRate || this.learningRate || options.learningRate;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod;\n    let endTime = Date.now() + options.trainTimeMs;\n    let res = {\n      error: 1,\n      iterations: 0\n    };\n\n    if (this.sizes === null) {\n      this.initialize (data);\n    }\n\n    const items = new Array(iterations);\n    const thaw  = new Thaw (items, {\n      delay: true,\n      each: () => {\n        res.iterations++;\n        let sum = 0;\n        for (var i = 0; i < data.length; ++i) {\n          sum += this.trainPattern (data[i].input, data[i].output, learningRate);\n        }\n\n        res.error = sum / data.length;\n\n        if (log && (res.iterations % logPeriod === 0)) {\n          log(`iterations: ${res.iterations} training error: ${res.error}`);\n        }\n\n        if (callback && (res.iterations % callbackPeriod === 0)) {\n          // JSON.parse/stringify to clone the object so the callback doesn't have side effects to training\n          callback(JSON.parse(JSON.stringify(res)));\n        }\n\n        if (res.error < errorThresh || (endTime > 0 && Date.now () > endTime)) {\n          thaw.stop();\n        }\n      },\n      done: () => {\n        if (cb && typeof cb === \"function\") {\n          cb (res);\n        }\n      }\n    });\n\n    thaw.tick();\n  }\n\n  /**\n   *\n   * @param input\n   * @param target\n   * @param learningRate\n   */\n  trainPattern (input, target, learningRate) {\n    learningRate = learningRate || this.learningRate;\n\n    // forward propagate\n    this.runInput(input);\n\n    // back propagate\n    this.calculateDeltas(target);\n    this.adjustWeights(learningRate);\n\n    let error = mse(this.errors[this.outputLayer]);\n    return error;\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltasSigmoid(target) {\n    for (let layer = this.outputLayer; layer >= 0; layer--) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let output = this.outputs[layer][node];\n\n        let error = 0;\n        if (layer === this.outputLayer) {\n          error = target[node] - output;\n        }\n        else {\n          let deltas = this.deltas[layer + 1];\n          for (let k = 0; k < deltas.length; k++) {\n            error += deltas[k] * this.weights[layer + 1][k][node];\n          }\n        }\n        this.errors[layer][node] = error;\n        this.deltas[layer][node] = error * output * (1 - output);\n      }\n    }\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltasRelu(target) {\n    for (let layer = this.outputLayer; layer >= 0; layer--) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let output = this.outputs[layer][node];\n\n        let error = 0;\n        if (layer === this.outputLayer) {\n          error = target[node] - output;\n        }\n        else {\n          let deltas = this.deltas[layer + 1];\n          for (let k = 0; k < deltas.length; k++) {\n            error += deltas[k] * this.weights[layer + 1][k][node];\n          }\n        }\n        this.errors[layer][node] = error;\n        this.deltas[layer][node] = output > 0 ? error : 0;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltasLeakyRelu(target) {\n    for (let layer = this.outputLayer; layer >= 0; layer--) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let output = this.outputs[layer][node];\n\n        let error = 0;\n        if (layer === this.outputLayer) {\n          error = target[node] - output;\n        }\n        else {\n          let deltas = this.deltas[layer + 1];\n          for (let k = 0; k < deltas.length; k++) {\n            error += deltas[k] * this.weights[layer + 1][k][node];\n          }\n        }\n        this.errors[layer][node] = error;\n        this.deltas[layer][node] = output > 0 ? error : 0.01 * error;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltasTanh(target) {\n    for (let layer = this.outputLayer; layer >= 0; layer--) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let output = this.outputs[layer][node];\n\n        let error = 0;\n        if (layer === this.outputLayer) {\n          error = target[node] - output;\n        }\n        else {\n          let deltas = this.deltas[layer + 1];\n          for (let k = 0; k < deltas.length; k++) {\n            error += deltas[k] * this.weights[layer + 1][k][node];\n          }\n        }\n        this.errors[layer][node] = error;\n        this.deltas[layer][node] = (1 - output * output) * error;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param learningRate\n   */\n  adjustWeights(learningRate) {\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      let incoming = this.outputs[layer - 1];\n\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let delta = this.deltas[layer][node];\n\n        for (let k = 0; k < incoming.length; k++) {\n          let change = this.changes[layer][node][k];\n\n          change = (learningRate * delta * incoming[k])\n            + (this.momentum * change);\n\n          this.changes[layer][node][k] = change;\n          this.weights[layer][node][k] += change;\n        }\n        this.biases[layer][node] += learningRate * delta;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {*}\n   */\n  formatData(data) {\n    if (!Array.isArray(data)) { // turn stream datum into array\n      let tmp = [];\n      tmp.push(data);\n      data = tmp;\n    }\n    // turn sparse hash input into arrays with 0s as filler\n    let datum = data[0].input;\n    if (!Array.isArray(datum) && !(datum instanceof Float32Array)) {\n      if (!this.inputLookup) {\n        this.inputLookup = lookup.buildLookup(data.map(value => value['input']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.inputLookup, datum.input);\n        return Object.assign({}, datum, { input: array });\n      }, this);\n    }\n\n    if (!Array.isArray(data[0].output)) {\n      if (!this.outputLookup) {\n        this.outputLookup = lookup.buildLookup(data.map(value => value['output']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.outputLookup, datum.output);\n        return Object.assign({}, datum, { output: array });\n      }, this);\n    }\n    return data;\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    data = this.formatData(data);\n\n    // for binary classification problems with one output node\n    let isBinary = data[0].output.length === 1;\n    let falsePos = 0;\n    let falseNeg = 0;\n    let truePos = 0;\n    let trueNeg = 0;\n\n    // for classification problems\n    let misclasses = [];\n\n    // run each pattern through the trained network and collect\n    // error and misclassification statistics\n    let sum = 0;\n    for (let i = 0; i < data.length; i++) {\n      let output = this.runInput(data[i].input);\n      let target = data[i].output;\n\n      let actual, expected;\n      if (isBinary) {\n        actual = output[0] > this.binaryThresh ? 1 : 0;\n        expected = target[0];\n      }\n      else {\n        actual = output.indexOf(max(output));\n        expected = target.indexOf(max(target));\n      }\n\n      if (actual !== expected) {\n        let misclass = data[i];\n        Object.assign(misclass, {\n          actual: actual,\n          expected: expected\n        });\n        misclasses.push(misclass);\n      }\n\n      if (isBinary) {\n        if (actual === 0 && expected === 0) {\n          trueNeg++;\n        } else if (actual === 1 && expected === 1) {\n          truePos++;\n        } else if (actual === 0 && expected === 1) {\n          falseNeg++;\n        } else if (actual === 1 && expected === 0) {\n          falsePos++;\n        }\n      }\n\n      let errors = output.map((value, i) => {\n        return target[i] - value;\n      });\n      sum += mse(errors);\n    }\n    let error = sum / data.length;\n\n    let stats = {\n      error: error,\n      misclasses: misclasses\n    };\n\n    if (isBinary) {\n      Object.assign(stats, {\n        trueNeg: trueNeg,\n        truePos: truePos,\n        falseNeg: falseNeg,\n        falsePos: falsePos,\n        total: data.length,\n        precision: truePos / (truePos + falsePos),\n        recall: truePos / (truePos + falseNeg),\n        accuracy: (trueNeg + truePos) / data.length\n      });\n    }\n    return stats;\n  }\n\n  /**\n   *\n   * @returns\n   *  {\n   *    layers: [\n   *      {\n   *        x: {},\n   *        y: {}\n   *      },\n   *      {\n   *        '0': {\n   *          bias: -0.98771313,\n   *          weights: {\n   *            x: 0.8374838,\n   *            y: 1.245858\n   *          },\n   *        '1': {\n   *          bias: 3.48192004,\n   *          weights: {\n   *            x: 1.7825821,\n   *            y: -2.67899\n   *          }\n   *        }\n   *      },\n   *      {\n   *        f: {\n   *          bias: 0.27205739,\n   *          weights: {\n   *            '0': 1.3161821,\n   *            '1': 2.00436\n   *          }\n   *        }\n   *      }\n   *    ]\n   *  }\n   */\n  toJSON() {\n    let layers = [];\n    for (let layer = 0; layer <= this.outputLayer; layer++) {\n      layers[layer] = {};\n\n      let nodes;\n      // turn any internal arrays back into hashes for readable json\n      if (layer === 0 && this.inputLookup) {\n        nodes = Object.keys(this.inputLookup);\n      }\n      else if (layer === this.outputLayer && this.outputLookup) {\n        nodes = Object.keys(this.outputLookup);\n      }\n      else {\n        nodes = range(0, this.sizes[layer]);\n      }\n\n      for (let j = 0; j < nodes.length; j++) {\n        let node = nodes[j];\n        layers[layer][node] = {};\n\n        if (layer > 0) {\n          layers[layer][node].bias = this.biases[layer][j];\n          layers[layer][node].weights = {};\n          for (let k in layers[layer - 1]) {\n            let index = k;\n            if (layer === 1 && this.inputLookup) {\n              index = this.inputLookup[k];\n            }\n            layers[layer][node].weights[k] = this.weights[layer][j][index];\n          }\n        }\n      }\n    }\n    return {\n      sizes: this.sizes,\n      layers,\n      outputLookup:!!this.outputLookup,\n      inputLookup:!!this.inputLookup,\n      activation: this.activation\n    };\n  }\n\n  /**\n   *\n   * @param json\n   * @returns {NeuralNetwork}\n   */\n  fromJSON(json) {\n    this.initialize(json.sizes);\n\n    for (let i = 0; i <= this.outputLayer; i++) {\n      let layer = json.layers[i];\n      if (i === 0 && (!layer[0] || json.inputLookup)) {\n        this.inputLookup = lookup.lookupFromHash(layer);\n      }\n      else if (i === this.outputLayer && (!layer[0] || json.outputLookup)) {\n        this.outputLookup = lookup.lookupFromHash(layer);\n      }\n      if (layer > 0) {\n        const nodes = Object.keys(layer);\n        this.sizes[i] = nodes.length;\n        for (let j in nodes) {\n          const node = nodes[j];\n          this.biases[i] = layer[node].bias;\n          this.weights[i][j] = toArray(layer[node].weights);\n        }\n      }\n    }\n\n    this.setActivation();\n    return this;\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    const activation = this.activation;\n    function nodeHandle(layers, layerNumber, nodeKey) {\n      if (layerNumber === 0) {\n        return (typeof nodeKey === 'string'\n          ? `input['${nodeKey}']`\n          : `input[${nodeKey}]`);\n      }\n\n      const layer = layers[layerNumber];\n      const node = layer[nodeKey];\n      let result = [node.bias];\n      for (let w in node.weights) {\n        if (node.weights[w] < 0) {\n          result.push(`${node.weights[w]}*(${nodeHandle(layers, layerNumber - 1, w)})`);\n        } else {\n          result.push(`+${node.weights[w]}*(${nodeHandle(layers, layerNumber - 1, w)})`);\n        }\n      }\n\n      switch (activation) {\n        case 'sigmoid':\n          return `1/(1+1/Math.exp(${result.join('')}))`;\n        case 'relu':\n          return `var sum = ${result.join('')};(sum < 0 ? 0 : sum);`;\n        case 'leaky-relu':\n          return `var sum = ${result.join('')};(sum < 0 ? 0 : 0.01 * sum);`;\n        case 'tanh':\n          return `Math.tanh(${result.join('')});`;\n        default:\n          throw new Error('unknown activation type ' + activation);\n      }\n    }\n\n    const layers = this.toJSON().layers;\n    const layersAsMath = [];\n    let result;\n    for (let i in layers[layers.length - 1]) {\n      layersAsMath.push(nodeHandle(layers, layers.length - 1, i));\n    }\n    if (this.outputLookup) {\n      result = `{${\n        Object.keys(this.outputLookup)\n          .map((key, i) => `'${key}':${layersAsMath[i]}`)\n      }}`;\n    } else {\n      result = `[${layersAsMath.join(',')}]`;\n    }\n    return new Function('input', `return ${result}`);\n  }\n\n  /**\n   * This will create a TrainStream (WriteStream) for us to send the training data to.\n   * @param opts training options\n   * @returns {TrainStream|*}\n   */\n  createTrainStream(opts) {\n    opts = opts || {};\n    opts.neuralNetwork = this;\n    this.setActivation();\n    this.trainStream = new TrainStream(opts);\n    return this.trainStream;\n  }\n}"]}