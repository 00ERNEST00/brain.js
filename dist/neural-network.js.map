{"version":3,"sources":["../src/neural-network.js"],"names":["NeuralNetwork","options","Object","assign","defaults","hiddenSizes","hiddenLayers","sizes","outputLayer","biases","weights","outputs","deltas","changes","errors","runInput","calculateDeltas","length","layer","size","Array","node","prevSize","setActivation","activation","runInputSigmoid","calculateDeltasSigmoid","runInputRelu","calculateDeltasRelu","runInputLeakyRelu","calculateDeltasLeakyRelu","runInputTanh","calculateDeltasTanh","Error","input","inputLookup","toArray","output","outputLookup","toHash","sum","k","Math","exp","tanh","data","_options","trainDefaults","formatData","iterations","errorThresh","log","console","logPeriod","learningRate","callback","callbackPeriod","reinforce","inputSize","outputSize","push","max","floor","forEach","unshift","initialize","error","i","j","err","trainPattern","target","adjustWeights","incoming","delta","change","momentum","constructor","tmp","datum","Float64Array","buildLookup","map","value","array","isBinary","falsePos","falseNeg","truePos","trueNeg","misclasses","actual","expected","binaryThresh","indexOf","misclass","stats","total","precision","recall","accuracy","layers","nodes","keys","bias","index","json","lookupFromHash","nodeHandle","layerNumber","nodeKey","result","w","join","toJSON","layersAsMath","key","Function","opts","neuralNetwork","trainStream"],"mappings":"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","file":"neural-network.js","sourcesContent":["import lookup from './lookup';\nimport TrainStream from './train-stream';\nimport max from './utilities/max';\nimport mse from './utilities/mse';\nimport randos from './utilities/randos';\nimport range from './utilities/range';\nimport toArray from './utilities/to-array';\nimport zeros from './utilities/zeros';\n\n/**\n *\n * @param {object} options\n * @constructor\n */\nexport default class NeuralNetwork {\n  constructor(options = {}) {\n    Object.assign(this, NeuralNetwork.defaults, options);\n    this.hiddenSizes = options.hiddenLayers;\n\n    this.sizes = null;\n    this.outputLayer = null;\n    this.biases = null; // weights for bias nodes\n    this.weights = null;\n    this.outputs = null;\n\n    // state for training\n    this.deltas = null;\n    this.changes = null; // for momentum\n    this.errors = null;\n    this.runInput = null;\n    this.calculateDeltas = null;\n  }\n\n  /**\n   *\n   * @param {} sizes\n   */\n  initialize(sizes) {\n    this.sizes = sizes;\n    this.outputLayer = this.sizes.length - 1;\n    this.biases = []; // weights for bias nodes\n    this.weights = [];\n    this.outputs = [];\n\n    // state for training\n    this.deltas = [];\n    this.changes = []; // for momentum\n    this.errors = [];\n\n    for (let layer = 0; layer <= this.outputLayer; layer++) {\n      let size = this.sizes[layer];\n      this.deltas[layer] = zeros(size);\n      this.errors[layer] = zeros(size);\n      this.outputs[layer] = zeros(size);\n\n\n      if (layer > 0) {\n        this.biases[layer] = randos(size);\n        this.weights[layer] = new Array(size);\n        this.changes[layer] = new Array(size);\n\n        for (let node = 0; node < size; node++) {\n          let prevSize = this.sizes[layer - 1];\n          this.weights[layer][node] = randos(prevSize);\n          this.changes[layer][node] = zeros(prevSize);\n        }\n      }\n    }\n\n    this.setActivation();\n  }\n\n  setActivation() {\n    switch (this.activation) {\n      case 'sigmoid':\n        this.runInput = this.runInput || this.runInputSigmoid;\n        this.calculateDeltas = this.calculateDeltas || this.calculateDeltasSigmoid;\n        break;\n      case 'relu':\n        this.runInput = this.runInput || this.runInputRelu;\n        this.calculateDeltas = this.calculateDeltas || this.calculateDeltasRelu;\n        break;\n      case 'leaky-relu':\n        this.runInput = this.runInput || this.runInputLeakyRelu;\n        this.calculateDeltas = this.calculateDeltas || this.calculateDeltasLeakyRelu;\n        break;\n      case 'tanh':\n        this.runInput = this.runInput || this.runInputTanh;\n        this.calculateDeltas = this.calculateDeltas || this.calculateDeltasTanh;\n        break;\n      default:\n        throw new Error('unknown activation ' + this.activation);\n    }\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  run(input) {\n    if (this.inputLookup) {\n      input = lookup.toArray(this.inputLookup, input);\n    }\n\n    let output = this.runInput(input);\n\n    if (this.outputLookup) {\n      output = lookup.toHash(this.outputLookup, output);\n    }\n    return output;\n  }\n\n  /**\n   * trains via sigmoid\n   * @param input\n   * @returns {*}\n   */\n  runInputSigmoid(input) {\n    this.outputs[0] = input;  // set output state of input layer\n\n    let output = null;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let weights = this.weights[layer][node];\n\n        let sum = this.biases[layer][node];\n        for (let k = 0; k < weights.length; k++) {\n          sum += weights[k] * input[k];\n        }\n        //sigmoid\n        this.outputs[layer][node] = 1 / (1 + Math.exp(-sum));\n      }\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  runInputRelu(input) {\n    this.outputs[0] = input;  // set output state of input layer\n\n    let output = null;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let weights = this.weights[layer][node];\n\n        let sum = this.biases[layer][node];\n        for (let k = 0; k < weights.length; k++) {\n          sum += weights[k] * input[k];\n        }\n        //relu\n        this.outputs[layer][node] = (sum < 0 ? 0 : sum);\n      }\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  runInputLeakyRelu(input) {\n    this.outputs[0] = input;  // set output state of input layer\n\n    let output = null;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let weights = this.weights[layer][node];\n\n        let sum = this.biases[layer][node];\n        for (let k = 0; k < weights.length; k++) {\n          sum += weights[k] * input[k];\n        }\n        //leaky relu\n        this.outputs[layer][node] = (sum < 0 ? 0 : 0.01 * sum);\n      }\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  runInputTanh(input) {\n    this.outputs[0] = input;  // set output state of input layer\n\n    let output = null;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let weights = this.weights[layer][node];\n\n        let sum = this.biases[layer][node];\n        for (let k = 0; k < weights.length; k++) {\n          sum += weights[k] * input[k];\n        }\n        //tanh\n        this.outputs[layer][node] = Math.tanh(sum);\n      }\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  /**\n   *\n   * @param data\n   * @param _options\n   * @returns {{error: number, iterations: number}}\n   */\n  train(data, _options = {}) {\n    const options = Object.assign({}, NeuralNetwork.trainDefaults, _options);\n    data = this.formatData(data);\n    let iterations = options.iterations;\n    let errorThresh = options.errorThresh;\n    let log = options.log === true ? console.log : options.log;\n    let logPeriod = options.logPeriod;\n    let learningRate = _options.learningRate || this.learningRate || options.learningRate;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod;\n    if (!options.reinforce) {\n      let sizes = [];\n      let inputSize = data[0].input.length;\n      let outputSize = data[0].output.length;\n      let hiddenSizes = this.hiddenSizes;\n      if (!hiddenSizes) {\n        sizes.push(Math.max(3, Math.floor(inputSize / 2)));\n      } else {\n        hiddenSizes.forEach(size => {\n          sizes.push(size);\n        });\n      }\n\n      sizes.unshift(inputSize);\n      sizes.push(outputSize);\n\n      this.initialize(sizes);\n    }\n\n    let error = 1;\n    let i;\n    for (i = 0; i < iterations && error > errorThresh; i++) {\n      let sum = 0;\n      for (let j = 0; j < data.length; j++) {\n        let err = this.trainPattern(data[j].input, data[j].output, learningRate);\n        sum += err;\n      }\n      error = sum / data.length;\n\n      if (log && (i % logPeriod === 0)) {\n        log('iterations:', i, 'training error:', error);\n      }\n      if (callback && (i % callbackPeriod === 0)) {\n        callback({ error: error, iterations: i });\n      }\n    }\n\n    return {\n      error: error,\n      iterations: i\n    };\n  }\n\n  /**\n   *\n   * @param input\n   * @param target\n   * @param learningRate\n   */\n  trainPattern(input, target, learningRate) {\n    learningRate = learningRate || this.learningRate;\n\n    // forward propagate\n    this.runInput(input);\n\n    // back propagate\n    this.calculateDeltas(target);\n    this.adjustWeights(learningRate);\n\n    let error = mse(this.errors[this.outputLayer]);\n    return error;\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltasSigmoid(target) {\n    for (let layer = this.outputLayer; layer >= 0; layer--) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let output = this.outputs[layer][node];\n\n        let error = 0;\n        if (layer === this.outputLayer) {\n          error = target[node] - output;\n        }\n        else {\n          let deltas = this.deltas[layer + 1];\n          for (let k = 0; k < deltas.length; k++) {\n            error += deltas[k] * this.weights[layer + 1][k][node];\n          }\n        }\n        this.errors[layer][node] = error;\n        this.deltas[layer][node] = error * output * (1 - output);\n      }\n    }\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltasRelu(target) {\n    for (let layer = this.outputLayer; layer >= 0; layer--) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let output = this.outputs[layer][node];\n\n        let error = 0;\n        if (layer == this.outputLayer) {\n          error = target[node] - output;\n        }\n        else {\n          let deltas = this.deltas[layer + 1];\n          for (let k = 0; k < deltas.length; k++) {\n            error += deltas[k] * this.weights[layer + 1][k][node];\n          }\n        }\n        this.errors[layer][node] = error;\n        this.deltas[layer][node] = output > 0 ? error : 0;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltasLeakyRelu(target) {\n    for (let layer = this.outputLayer; layer >= 0; layer--) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let output = this.outputs[layer][node];\n\n        let error = 0;\n        if (layer == this.outputLayer) {\n          error = target[node] - output;\n        }\n        else {\n          let deltas = this.deltas[layer + 1];\n          for (let k = 0; k < deltas.length; k++) {\n            error += deltas[k] * this.weights[layer + 1][k][node];\n          }\n        }\n        this.errors[layer][node] = error;\n        this.deltas[layer][node] = output > 0 ? error : 0.01 * error;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltasTanh(target) {\n    for (let layer = this.outputLayer; layer >= 0; layer--) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let output = this.outputs[layer][node];\n\n        let error = 0;\n        if (layer == this.outputLayer) {\n          error = target[node] - output;\n        }\n        else {\n          let deltas = this.deltas[layer + 1];\n          for (let k = 0; k < deltas.length; k++) {\n            error += deltas[k] * this.weights[layer + 1][k][node];\n          }\n        }\n        this.errors[layer][node] = error;\n        this.deltas[layer][node] = (1 - output * output) * error;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param learningRate\n   */\n  adjustWeights(learningRate) {\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      let incoming = this.outputs[layer - 1];\n\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let delta = this.deltas[layer][node];\n\n        for (let k = 0; k < incoming.length; k++) {\n          let change = this.changes[layer][node][k];\n\n          change = (learningRate * delta * incoming[k])\n            + (this.momentum * change);\n\n          this.changes[layer][node][k] = change;\n          this.weights[layer][node][k] += change;\n        }\n        this.biases[layer][node] += learningRate * delta;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {*}\n   */\n  formatData(data) {\n    if (data.constructor !== Array) { // turn stream datum into array\n      let tmp = [];\n      tmp.push(data);\n      data = tmp;\n    }\n    // turn sparse hash input into arrays with 0s as filler\n    let datum = data[0].input;\n    if (datum.constructor !== Array && !(datum instanceof Float64Array)) {\n      if (!this.inputLookup) {\n        this.inputLookup = lookup.buildLookup(data.map(value => value['input']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.inputLookup, datum.input);\n        return Object.assign({}, datum, { input: array });\n      }, this);\n    }\n\n    if (data[0].output.constructor !== Array) {\n      if (!this.outputLookup) {\n        this.outputLookup = lookup.buildLookup(data.map(value => value['output']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.outputLookup, datum.output);\n        return Object.assign({}, datum, { output: array });\n      }, this);\n    }\n    return data;\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    data = this.formatData(data);\n\n    // for binary classification problems with one output node\n    let isBinary = data[0].output.length === 1;\n    let falsePos = 0;\n    let falseNeg = 0;\n    let truePos = 0;\n    let trueNeg = 0;\n\n    // for classification problems\n    let misclasses = [];\n\n    // run each pattern through the trained network and collect\n    // error and misclassification statistics\n    let sum = 0;\n    for (let i = 0; i < data.length; i++) {\n      let output = this.runInput(data[i].input);\n      let target = data[i].output;\n\n      let actual, expected;\n      if (isBinary) {\n        actual = output[0] > this.binaryThresh ? 1 : 0;\n        expected = target[0];\n      }\n      else {\n        actual = output.indexOf(max(output));\n        expected = target.indexOf(max(target));\n      }\n\n      if (actual !== expected) {\n        let misclass = data[i];\n        Object.assign(misclass, {\n          actual: actual,\n          expected: expected\n        });\n        misclasses.push(misclass);\n      }\n\n      if (isBinary) {\n        if (actual === 0 && expected === 0) {\n          trueNeg++;\n        } else if (actual === 1 && expected === 1) {\n          truePos++;\n        } else if (actual === 0 && expected === 1) {\n          falseNeg++;\n        } else if (actual === 1 && expected === 0) {\n          falsePos++;\n        }\n      }\n\n      let errors = output.map((value, i) => {\n        return target[i] - value;\n      });\n      sum += mse(errors);\n    }\n    let error = sum / data.length;\n\n    let stats = {\n      error: error,\n      misclasses: misclasses\n    };\n\n    if (isBinary) {\n      Object.assign(stats, {\n        trueNeg: trueNeg,\n        truePos: truePos,\n        falseNeg: falseNeg,\n        falsePos: falsePos,\n        total: data.length,\n        precision: truePos / (truePos + falsePos),\n        recall: truePos / (truePos + falseNeg),\n        accuracy: (trueNeg + truePos) / data.length\n      });\n    }\n    return stats;\n  }\n\n  /**\n   *\n   * @returns\n   *  {\n   *    layers: [\n   *      {\n   *        x: {},\n   *        y: {}\n   *      },\n   *      {\n   *        '0': {\n   *          bias: -0.98771313,\n   *          weights: {\n   *            x: 0.8374838,\n   *            y: 1.245858\n   *          },\n   *        '1': {\n   *          bias: 3.48192004,\n   *          weights: {\n   *            x: 1.7825821,\n   *            y: -2.67899\n   *          }\n   *        }\n   *      },\n   *      {\n   *        f: {\n   *          bias: 0.27205739,\n   *          weights: {\n   *            '0': 1.3161821,\n   *            '1': 2.00436\n   *          }\n   *        }\n   *      }\n   *    ]\n   *  }\n   */\n  toJSON() {\n    let layers = [];\n    for (let layer = 0; layer <= this.outputLayer; layer++) {\n      layers[layer] = {};\n\n      let nodes;\n      // turn any internal arrays back into hashes for readable json\n      if (layer === 0 && this.inputLookup) {\n        nodes = Object.keys(this.inputLookup);\n      }\n      else if (layer === this.outputLayer && this.outputLookup) {\n        nodes = Object.keys(this.outputLookup);\n      }\n      else {\n        nodes = range(0, this.sizes[layer]);\n      }\n\n      for (let j = 0; j < nodes.length; j++) {\n        let node = nodes[j];\n        layers[layer][node] = {};\n\n        if (layer > 0) {\n          layers[layer][node].bias = this.biases[layer][j];\n          layers[layer][node].weights = {};\n          for (let k in layers[layer - 1]) {\n            let index = k;\n            if (layer === 1 && this.inputLookup) {\n              index = this.inputLookup[k];\n            }\n            layers[layer][node].weights[k] = this.weights[layer][j][index];\n          }\n        }\n      }\n    }\n    return { layers: layers, outputLookup:!!this.outputLookup, inputLookup:!!this.inputLookup, activation: this.activation };\n  }\n\n  /**\n   *\n   * @param json\n   * @returns {NeuralNetwork}\n   */\n  fromJSON(json) {\n    let size = json.layers.length;\n    this.outputLayer = size - 1;\n\n    this.sizes = new Array(size);\n    this.weights = new Array(size);\n    this.biases = new Array(size);\n    this.outputs = new Array(size);\n\n    for (let i = 0; i <= this.outputLayer; i++) {\n      let layer = json.layers[i];\n      if (i === 0 && (!layer[0] || json.inputLookup)) {\n        this.inputLookup = lookup.lookupFromHash(layer);\n      }\n      else if (i === this.outputLayer && (!layer[0] || json.outputLookup)) {\n        this.outputLookup = lookup.lookupFromHash(layer);\n      }\n\n      let nodes = Object.keys(layer);\n      this.sizes[i] = nodes.length;\n      this.weights[i] = [];\n      this.biases[i] = [];\n      this.outputs[i] = [];\n\n      for (let j in nodes) {\n        let node = nodes[j];\n        this.biases[i][j] = layer[node].bias;\n        this.weights[i][j] = toArray(layer[node].weights);\n      }\n    }\n\n    this.setActivation();\n    return this;\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    const activation = this.activation;\n    function nodeHandle(layers, layerNumber, nodeKey) {\n      if (layerNumber === 0) {\n        return (typeof nodeKey === 'string'\n          ? `input['${nodeKey}']`\n          : `input[${nodeKey}]`);\n      }\n\n      const layer = layers[layerNumber];\n      const node = layer[nodeKey];\n      let result = [node.bias];\n      for (let w in node.weights) {\n        if (node.weights[w] < 0) {\n          result.push(`${node.weights[w]}*(${nodeHandle(layers, layerNumber - 1, w)})`);\n        } else {\n          result.push(`+${node.weights[w]}*(${nodeHandle(layers, layerNumber - 1, w)})`);\n        }\n      }\n\n      switch (activation) {\n        case 'sigmoid':\n          return `1/(1+1/Math.exp(${result.join('')}))`;\n        case 'relu':\n          return `var sum = ${result.join('')};(sum < 0 ? 0 : sum);`;\n        case 'leaky-relu':\n          return `var sum = ${result.join('')};(sum < 0 ? 0 : 0.01 * sum);`;\n        case 'tanh':\n          return `Math.tanh(${result.join('')});`;\n        default:\n          throw new Error('unknown activation type ' + activation);\n      }\n    }\n\n    const layers = this.toJSON().layers;\n    const layersAsMath = [];\n    let result;\n    for (let i in layers[layers.length - 1]) {\n      layersAsMath.push(nodeHandle(layers, layers.length - 1, i));\n    }\n    if (this.outputLookup) {\n      result = `{${\n        Object.keys(this.outputLookup)\n          .map((key, i) => `'${key}':${layersAsMath[i]}`)\n      }}`;\n    } else {\n      result = `[${layersAsMath.join(',')}]`;\n    }\n    return new Function('input', `return ${result}`);\n  }\n\n  /**\n   * This will create a TrainStream (WriteStream) for us to send the training data to.\n   * @param opts training options\n   * @returns {TrainStream|*}\n   */\n  createTrainStream(opts) {\n    opts = opts || {};\n    opts.neuralNetwork = this;\n    this.setActivation();\n    this.trainStream = new TrainStream(opts);\n    return this.trainStream;\n  }\n}\n\nNeuralNetwork.trainDefaults = {\n  iterations: 20000,\n  errorThresh: 0.005,\n  log: false,\n  logPeriod: 10,\n  learningRate: 0.3,\n  callback: null,\n  callbackPeriod: 10,\n  reinforce: false\n};\n\nNeuralNetwork.defaults = {\n  learningRate: 0.3,\n  momentum: 0.1,\n  binaryThresh: 0.5,\n  hiddenLayers: null,\n  activation: 'sigmoid'\n};"]}