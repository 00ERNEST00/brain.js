{"version":3,"sources":["../../src/utilities/vocab.js"],"names":["Vocab","values","maxThreshold","indexTable","characterTable","characters","tempCharactersTable","vocabIndex","vocabLength","length","toString","characterIndex","charactersLength","character","push","phrase","result","i","max","index","indexes"],"mappings":";;;;;;;;;;AAAA;;;;;;IAMqBA,K;AACnB,iBAAYC,MAAZ,EAAoBC,YAApB,EAAkC;AAAA;;AAChCA,mBAAeA,gBAAgB,CAA/B;AACA,SAAKD,MAAL,GAAcA,MAAd;AACA;AACA;AACA,SAAKE,UAAL,GAAkB,EAAlB;AACA,SAAKC,cAAL,GAAsB,EAAtB;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,QAAIC,sBAAsB,EAA1B;AACA,SAAK,IAAIC,aAAa,CAAjB,EAAoBC,cAAcP,OAAOQ,MAA9C,EAAsDF,aAAaC,WAAnE,EAAgFD,YAAhF,EAA8F;AAC5F,UAAIF,aAAaJ,OAAOM,UAAP,EAAmBG,QAAnB,EAAjB;AACA,WAAK,IAAIC,iBAAiB,CAArB,EAAwBC,oBAAmBP,WAAWI,MAA3D,EAAmEE,iBAAiBC,iBAApF,EAAsGD,gBAAtG,EAAwH;AACtH,YAAIE,YAAYR,WAAWM,cAAX,CAAhB;AACA,YAAIE,aAAaP,mBAAjB,EAAsC;AACtCA,4BAAoBO,SAApB,IAAiC,IAAjC;AACA,aAAKR,UAAL,CAAgBS,IAAhB,CAAqBD,SAArB;AACD;AACF;;AAED;;AAEA;AACA;AACA;AACA,QAAID,mBAAmB,KAAKP,UAAL,CAAgBI,MAAvC;AACA,SAAI,IAAIE,kBAAiB,CAAzB,EAA4BA,kBAAiBC,gBAA7C,EAA+DD,iBAA/D,EAAiF;AAC/E,UAAIE,aAAY,KAAKR,UAAL,CAAgBM,eAAhB,CAAhB;AACA,UAAGA,mBAAkBT,YAArB,EAAmC;AACjC;AACA,aAAKC,UAAL,CAAgBU,UAAhB,IAA6BF,kBAAiB,CAA9C;AACA,aAAKP,cAAL,CAAoBO,kBAAiB,CAArC,IAA0CE,UAA1C;AACD;AACF;AACF;;;;8BAESE,M,EAAQb,Y,EAAc;AAC9BA,qBAAeA,gBAAgB,CAA/B;AACA,UAAIc,SAAS,EAAb;AACA,UAAIb,aAAa,KAAKA,UAAtB;;AAEA,WAAK,IAAIc,IAAI,CAAR,EAAWC,MAAMH,OAAON,MAA7B,EAAqCQ,IAAIC,GAAzC,EAA8CD,GAA9C,EAAmD;AACjD,YAAIJ,YAAYE,OAAOE,CAAP,CAAhB;AACA,YAAIE,QAAQhB,WAAWU,SAAX,CAAZ;AACA,YAAIM,QAAQjB,YAAZ,EAA0B;AAC1Bc,eAAOF,IAAP,CAAYK,KAAZ;AACD;;AAED,aAAOH,MAAP;AACD;;;iCAEYI,O,EAASlB,Y,EAAc;AAClCA,qBAAeA,gBAAgB,CAA/B;AACA,UAAIc,SAAS,EAAb;AACA,UAAIZ,iBAAiB,KAAKA,cAA1B;;AAEA,WAAK,IAAIa,IAAI,CAAR,EAAWC,MAAME,QAAQX,MAA9B,EAAsCQ,IAAIC,GAA1C,EAA+CD,GAA/C,EAAoD;AAClD,YAAIE,QAAQC,QAAQH,CAAR,CAAZ;AACA,YAAIE,QAAQjB,YAAZ,EAA0B;AAC1B,YAAIW,YAAYT,eAAee,KAAf,CAAhB;AACAH,eAAOF,IAAP,CAAYD,SAAZ;AACD;;AAED,aAAOG,MAAP;AACD;;;;;;kBAhEkBhB,K","file":"vocab.js","sourcesContent":["/**\n *\n * @param {String[]|Number[]} values\n * @param maxThreshold\n * @constructor\n */\nexport default class Vocab {\n  constructor(values, maxThreshold) {\n    maxThreshold = maxThreshold || 0;\n    this.values = values;\n    // go over all characters and keep track of all unique ones seen\n    // count up all characters\n    this.indexTable = {};\n    this.characterTable = {};\n    this.characters = [];\n    let tempCharactersTable = {};\n    for (let vocabIndex = 0, vocabLength = values.length; vocabIndex < vocabLength; vocabIndex++) {\n      var characters = values[vocabIndex].toString();\n      for (let characterIndex = 0, charactersLength = characters.length; characterIndex < charactersLength; characterIndex++) {\n        let character = characters[characterIndex];\n        if (character in tempCharactersTable) continue;\n        tempCharactersTable[character] = true;\n        this.characters.push(character);\n      }\n    }\n\n    // filter by count threshold and create pointers\n\n    // NOTE: start at one because we will have START and END tokens!\n    // that is, START token will be index 0 in model letter vectors\n    // and END token will be index 0 in the next character softmax\n    let charactersLength = this.characters.length;\n    for(let characterIndex = 0; characterIndex < charactersLength; characterIndex++) {\n      let character = this.characters[characterIndex];\n      if(characterIndex >= maxThreshold) {\n        // add character to vocab\n        this.indexTable[character] = characterIndex + 1;\n        this.characterTable[characterIndex + 1] = character;\n      }\n    }\n  }\n\n  toIndexes(phrase, maxThreshold) {\n    maxThreshold = maxThreshold || 0;\n    let result = [];\n    let indexTable = this.indexTable;\n\n    for (let i = 0, max = phrase.length; i < max; i++) {\n      let character = phrase[i];\n      let index = indexTable[character];\n      if (index < maxThreshold) continue;\n      result.push(index);\n    }\n\n    return result;\n  }\n\n  toCharacters(indexes, maxThreshold) {\n    maxThreshold = maxThreshold || 0;\n    let result = [];\n    let characterTable = this.characterTable;\n\n    for (let i = 0, max = indexes.length; i < max; i++) {\n      let index = indexes[i];\n      if (index < maxThreshold) continue;\n      let character = characterTable[index];\n      result.push(character);\n    }\n\n    return result;\n  }\n}\n"]}