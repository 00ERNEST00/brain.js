{"version":3,"sources":["../../src/utilities/vocab.js"],"names":["Vocab","values","maxThreshold","indexTable","characterTable","characters","tempCharactersTable","vocabIndex","vocabLength","length","toString","characterIndex","charactersLength","character","push","phrase","result","i","max","index","indexes","toCharacters","join","String","fromCharCode","string","prototype","concat","Set"],"mappings":"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","file":"vocab.js","sourcesContent":["/**\n *\n * @param {String[]|Number[]} values\n * @param maxThreshold\n * @constructor\n */\nexport default class Vocab {\n  constructor(values, maxThreshold = 0) {\n    this.values = values;\n    // go over all characters and keep track of all unique ones seen\n    // count up all characters\n    this.indexTable = {};\n    this.characterTable = {};\n    this.characters = [];\n    let tempCharactersTable = {};\n    for (let vocabIndex = 0, vocabLength = values.length; vocabIndex < vocabLength; vocabIndex++) {\n      var characters = values[vocabIndex].toString();\n      for (let characterIndex = 0, charactersLength = characters.length; characterIndex < charactersLength; characterIndex++) {\n        let character = characters[characterIndex];\n        if (character in tempCharactersTable) continue;\n        tempCharactersTable[character] = true;\n        this.characters.push(character);\n      }\n    }\n\n    // filter by count threshold and create pointers\n\n    // NOTE: start at one because we will have START and END tokens!\n    // that is, START token will be index 0 in model letter vectors\n    // and END token will be index 0 in the next character softmax\n    let charactersLength = this.characters.length;\n    for(let characterIndex = 0; characterIndex < charactersLength; characterIndex++) {\n      let character = this.characters[characterIndex];\n      if(characterIndex >= maxThreshold) {\n        // add character to vocab\n        this.indexTable[character] = characterIndex;\n        this.characterTable[characterIndex] = character;\n      }\n    }\n  }\n\n  toIndexes(phrase, maxThreshold = 0) {\n    let result = [];\n    let indexTable = this.indexTable;\n\n    for (let i = 0, max = phrase.length; i < max; i++) {\n      let character = phrase[i];\n      let index = indexTable[character];\n      if (index < maxThreshold) continue;\n      result.push(index);\n    }\n\n    return result;\n  }\n\n  toCharacters(indexes, maxThreshold = 0) {\n    let result = [];\n    let characterTable = this.characterTable;\n\n    for (let i = 0, max = indexes.length; i < max; i++) {\n      let index = indexes[i];\n      if (index < maxThreshold) continue;\n      let character = characterTable[index];\n      result.push(character);\n    }\n\n    return result;\n  }\n\n  toString(indexes, maxThreshold) {\n    return this.toCharacters(indexes, maxThreshold).join('');\n  }\n\n  static allPrintable(maxThreshold) {\n    const values = [];\n    for(let i = 32; i <= 126; i++) {\n      values.push(String.fromCharCode(i));\n    }\n    return new Vocab(values, maxThreshold);\n  }\n\n  static fromString(string, maxThreshold) {\n    const values = String.prototype.concat(...new Set(string));\n    return new Vocab(values, maxThreshold);\n  }\n}\n"]}