{"version":3,"sources":["../src/feed-forward.js"],"names":["praxis","FeedForward","options","Object","assign","constructor","defaults","layers","_inputLayer","_outputLayer","inputLayer","length","push","previousLayer","i","hiddenLayers","hiddenLayer","outputLayer","connectNestedLayers","offset","layer","indexOf","splice","connectLayers","validate","setupKernels","hasOwnProperty","input","inputLookup","toArray","output","runInput","outputLookup","toHash","predict","outputs","target","compare","nextLayer","data","_options","trainDefaults","formatData","iterations","errorThresh","log","console","logPeriod","learningRate","callback","callbackPeriod","reinforce","initialize","error","sum","j","err","trainPattern","calculateDeltas","adjustWeights","errors","learn","Array","tmp","datum","Float64Array","buildLookup","map","value","array","isBinary","falsePos","falseNeg","truePos","trueNeg","misclasses","actual","expected","binaryThresh","misclass","mse","stats","total","precision","recall","accuracy","jsonLayers","jsonLayer","jsonKeys","keys","keyIndex","key","type","name","inputLayerIndex","inputLayers","inputLayerIndexes","json","Error","opts","getLayer","net","momentum","momentumRootMeanSquaredPropagation"],"mappings":"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","file":"feed-forward.js","sourcesContent":["import lookup from './lookup';\nimport TrainStream from './train-stream';\nimport max from './utilities/max';\nimport mse2d from './utilities/mse-2d';\nimport layerFromJSON from './utilities/layer-from-json';\nimport traverseLayersFrom from './utilities/traverse-layers-from';\nimport * as praxis from './praxis';\n\n/**\n *\n * @param {object} options\n * @constructor\n */\nexport default class FeedForward {\n  constructor(options = {}) {\n    Object.assign(this, this.constructor.defaults, options);\n    this.layers = null;\n    this._inputLayer = null;\n    this._outputLayer = null;\n  }\n\n  connectLayers() {\n    this.layers = [];\n    const inputLayer = this.inputLayer(null, this.layers.length);\n    this._inputLayer = inputLayer;\n    this.layers.push(inputLayer);\n    let previousLayer = inputLayer;\n    for (let i = 0; i < this.hiddenLayers.length; i++) {\n      const hiddenLayer = this.hiddenLayers[i](previousLayer, this.layers.length);\n      this.layers.push(hiddenLayer);\n      previousLayer = hiddenLayer;\n    }\n    this._outputLayer = this.outputLayer(previousLayer, this.layers.length);\n    this.layers.push(this._outputLayer);\n\n    this.connectNestedLayers();\n  }\n\n  connectNestedLayers() {\n    for (let i = 0; i < this.layers.length; i++) {\n      let offset = 0;\n      traverseLayersFrom(this.layers[i], (layer) => {\n        if (this.layers.indexOf(layer) === -1) {\n          this.layers.splice(i + offset, 0, layer);\n          offset++;\n        }\n      });\n    }\n  }\n\n  initialize() {\n    this.connectLayers();\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      layer.validate(this.layers[i - 1], this.layers[i + 1]);\n      layer.setupKernels();\n      if (layer.hasOwnProperty('praxis') && layer.praxis === null) {\n        layer.praxis = this.praxis(layer);\n      }\n    }\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  run(input) {\n    if (this.inputLookup) {\n      input = lookup.toArray(this.inputLookup, input);\n    }\n\n    let output = this.runInput(input);\n\n    if (this.outputLookup) {\n      output = lookup.toHash(this.outputLookup, output);\n    }\n    return output;\n  }\n\n  runInput(input) {\n    this.layers[0].predict(input);\n    for (let i = 1; i < this.layers.length; i++) {\n      this.layers[i].predict();\n    }\n    return this.layers[this.layers.length - 1].outputs;\n  }\n\n  calculateDeltas(target) {\n    this._outputLayer.compare(target);\n    for (let i = this.layers.length - 2; i > -1; i--) {\n      const previousLayer = this.layers[i - 1];\n      const nextLayer = this.layers[i + 1];\n      this.layers[i].compare(previousLayer, nextLayer);\n    }\n  }\n\n  /**\n   *\n   * @param data\n   * @param _options\n   * @returns {{error: number, iterations: number}}\n   */\n  train(data, _options = {}) {\n    const options = Object.assign({}, FeedForward.trainDefaults, _options);\n    data = this.formatData(data);\n    let iterations = options.iterations;\n    let errorThresh = options.errorThresh;\n    let log = options.log === true ? console.log : options.log;\n    let logPeriod = options.logPeriod;\n    let learningRate = _options.learningRate || this.learningRate || options.learningRate;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod;\n    if (!options.reinforce) {\n      this.initialize();\n    }\n\n    let error = 1;\n    let i;\n    for (i = 0; i < iterations && error > errorThresh; i++) {\n      let sum = 0;\n      for (let j = 0; j < data.length; j++) {\n        let err = this.trainPattern(data[j].input, data[j].output, learningRate);\n        sum += err;\n      }\n      error = sum / data.length;\n\n      if (log && (i % logPeriod === 0)) {\n        log('iterations:', i, 'training error:', error);\n      }\n      if (i % callbackPeriod === 0) console.log(error);\n      if (callback && (i % callbackPeriod === 0)) {\n        callback({ error: error, iterations: i });\n      }\n    }\n\n    return {\n      error: error,\n      iterations: i\n    };\n  }\n\n  /**\n   *\n   * @param input\n   * @param target\n   * @param [learningRate]\n   */\n  trainPattern(input, target, learningRate) {\n    learningRate = learningRate || this.learningRate;\n\n    // forward propagate\n    this.runInput(input);\n\n    // back propagate\n    this.calculateDeltas(target);\n    this.adjustWeights(learningRate);\n\n    let error = mse2d(this._outputLayer.errors.hasOwnProperty('toArray') ? this._outputLayer.errors.toArray() : this._outputLayer.errors);\n    return error;\n  }\n\n  /**\n   *\n   * @param learningRate\n   */\n  adjustWeights(learningRate) {\n    for (let i = 0; i < this.layers.length; i++) {\n      this.layers[i].learn(learningRate);\n    }\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {*}\n   */\n  formatData(data) {\n    if (data.constructor !== Array) { // turn stream datum into array\n      let tmp = [];\n      tmp.push(data);\n      data = tmp;\n    }\n    // turn sparse hash input into arrays with 0s as filler\n    let datum = data[0].input;\n    if (datum.constructor !== Array && !(datum instanceof Float64Array)) {\n      if (!this.inputLookup) {\n        this.inputLookup = lookup.buildLookup(data.map(value => value['input']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.inputLookup, datum.input);\n        return Object.assign({}, datum, { input: array });\n      }, this);\n    }\n\n    if (data[0].output.constructor !== Array) {\n      if (!this.outputLookup) {\n        this.outputLookup = lookup.buildLookup(data.map(value => value['output']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.outputLookup, datum.output);\n        return Object.assign({}, datum, { output: array });\n      }, this);\n    }\n    return data;\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    data = this.formatData(data);\n\n    // for binary classification problems with one output node\n    let isBinary = data[0].output.length === 1;\n    let falsePos = 0;\n    let falseNeg = 0;\n    let truePos = 0;\n    let trueNeg = 0;\n\n    // for classification problems\n    let misclasses = [];\n\n    // run each pattern through the trained network and collect\n    // error and misclassification statistics\n    let sum = 0;\n    for (let i = 0; i < data.length; i++) {\n      let output = this.runInput(data[i].input);\n      let target = data[i].output;\n\n      let actual, expected;\n      if (isBinary) {\n        actual = output[0] > this.binaryThresh ? 1 : 0;\n        expected = target[0];\n      }\n      else {\n        actual = output.indexOf(max(output));\n        expected = target.indexOf(max(target));\n      }\n\n      if (actual !== expected) {\n        let misclass = data[i];\n        Object.assign(misclass, {\n          actual: actual,\n          expected: expected\n        });\n        misclasses.push(misclass);\n      }\n\n      if (isBinary) {\n        if (actual === 0 && expected === 0) {\n          trueNeg++;\n        } else if (actual === 1 && expected === 1) {\n          truePos++;\n        } else if (actual === 0 && expected === 1) {\n          falseNeg++;\n        } else if (actual === 1 && expected === 0) {\n          falsePos++;\n        }\n      }\n\n      let errors = output.map((value, i) => {\n        return target[i] - value;\n      });\n      sum += mse(errors);\n    }\n    let error = sum / data.length;\n\n    let stats = {\n      error: error,\n      misclasses: misclasses\n    };\n\n    if (isBinary) {\n      Object.assign(stats, {\n        trueNeg: trueNeg,\n        truePos: truePos,\n        falseNeg: falseNeg,\n        falsePos: falsePos,\n        total: data.length,\n        precision: truePos / (truePos + falsePos),\n        recall: truePos / (truePos + falseNeg),\n        accuracy: (trueNeg + truePos) / data.length\n      });\n    }\n    return stats;\n  }\n\n  /**\n   *\n   */\n  toJSON() {\n    const jsonLayers = [];\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      const jsonLayer = {};\n      const jsonKeys = Object.keys(layer.constructor.defaults);\n      for (let keyIndex = 0; keyIndex < jsonKeys.length; keyIndex++) {\n        const key = jsonKeys[keyIndex];\n        jsonLayer[key] = layer[key];\n      }\n      jsonLayer.type = layer.constructor.name;\n      if (layer.inputLayer) {\n        jsonLayer.inputLayerIndex = this.layers.indexOf(layer.inputLayer);\n      } else if (layer.inputLayers) {\n        jsonLayer.inputLayerIndexes = layer.inputLayers.map((inputLayer) => this.layers.indexOf(inputLayer));\n      }\n      jsonLayers.push(jsonLayer);\n    }\n    const json = {\n      layers: jsonLayers\n    };\n    return json;\n  }\n\n  /**\n   *\n   * @param json\n   * @param [getLayer]\n   * @returns {FeedForward}\n   */\n  static fromJSON(json, getLayer) {\n    const jsonLayers = json.layers;\n    const layers = [];\n    const inputLayer = layerFromJSON(jsonLayers[0]) || getLayer(jsonLayers[0]);\n    layers.push(inputLayer);\n    for (let i = 1; i < jsonLayers.length; i++) {\n      const jsonLayer = jsonLayers[i];\n      if (jsonLayer.hasOwnProperty('inputLayerIndex')) {\n        const inputLayer = layers[jsonLayer.inputLayerIndex];\n        layers.push(layerFromJSON(jsonLayer, inputLayer) || getLayer(jsonLayer, inputLayer));\n      } else if (jsonLayer.hasOwnProperty('inputLayerIndexes')) {\n        const inputLayers = jsonLayer.inputLayerIndexes.map((inputLayerIndex) => layers[inputLayerIndex]);\n        layers.push(layerFromJSON(jsonLayer, inputLayers) || getLayer(jsonLayer, inputLayers));\n      }\n    }\n\n    const net = new FeedForward(json);\n    net.layers = layers;\n    return net;\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   * This will create a TrainStream (WriteStream) for us to send the training data to.\n   * @param opts training options\n   * @returns {TrainStream|*}\n   */\n  createTrainStream(opts) {\n    throw new Error('not yet implemented');\n  }\n}\n\nFeedForward.trainDefaults = {\n  iterations: 20000,\n  errorThresh: 0.005,\n  log: false,\n  logPeriod: 10,\n  learningRate: 0.3,\n  callback: null,\n  callbackPeriod: 10,\n  reinforce: false\n};\n\nFeedForward.defaults = {\n  learningRate: 0.3,\n  momentum: 0.1,\n  binaryThresh: 0.5,\n  hiddenLayers: null,\n  inputLayer: null,\n  outputLayer: null,\n  praxis: (layer) => praxis.momentumRootMeanSquaredPropagation(layer)\n};"]}