{"version":3,"sources":["../src/feed-forward.js"],"names":["FeedForward","options","Object","assign","defaults","layers","inputLayer","length","push","previousLayer","i","hiddenLayers","hiddenLayer","outputLayer","connectNestedLayers","layer","hasOwnProperty","indexOf","nestedLayer","splice","connectLayers","setupKernels","input","inputLookup","toArray","output","runInput","outputLookup","toHash","predict","outputs","nextLayer","compare","data","_options","trainDefaults","formatData","iterations","errorThresh","log","console","logPeriod","learningRate","callback","callbackPeriod","reinforce","initialize","error","sum","j","err","trainPattern","target","calculateDeltas","adjustWeights","errors","learn","constructor","Array","tmp","datum","Float64Array","buildLookup","map","value","array","isBinary","falsePos","falseNeg","truePos","trueNeg","misclasses","actual","expected","binaryThresh","misclass","stats","total","precision","recall","accuracy","jsonLayers","jsonLayer","jsonKeys","keys","keyIndex","key","type","name","inputLayerIndex","inputLayers","inputLayerIndexes","json","Error","opts","getLayer","net","momentum"],"mappings":"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","file":"feed-forward.js","sourcesContent":["import lookup from './lookup';\nimport TrainStream from './train-stream';\nimport max from './utilities/max';\nimport mse from './utilities/mse';\nimport layerFromJSON from './utilities/layer-from-json';\n\n/**\n *\n * @param {object} options\n * @constructor\n */\nexport default class FeedForward {\n  constructor(options = {}) {\n    Object.assign(this, FeedForward.defaults, options);\n    this.layers = null;\n  }\n\n  connectLayers() {\n    this.layers = [];\n    const inputLayer = this.inputLayer(null, this.layers.length);\n    this.layers.push(inputLayer);\n    let previousLayer = inputLayer;\n    for (let i = 0; i < this.hiddenLayers.length; i++) {\n      const hiddenLayer = this.hiddenLayers[i](previousLayer, this.layers.length);\n      this.layers.push(hiddenLayer);\n      previousLayer = hiddenLayer;\n    }\n    this.layers.push(this.outputLayer(previousLayer, this.layers.length));\n\n    this.connectNestedLayers();\n  }\n\n  connectNestedLayers() {\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      if (\n        layer.hasOwnProperty('inputLayer')\n        && this.layers.indexOf(layer.inputLayer) !== -1) continue;\n      let nestedLayer = layer;\n      while (nestedLayer = nestedLayer.inputLayer) {\n        if (this.layers.indexOf(nestedLayer) !== -1) continue;\n        this.layers.splice(i, 0, nestedLayer);\n      }\n    }\n  }\n\n  initialize() {\n    this.connectLayers();\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      layer.setupKernels();\n    }\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  run(input) {\n    if (this.inputLookup) {\n      input = lookup.toArray(this.inputLookup, input);\n    }\n\n    let output = this.runInput(input);\n\n    if (this.outputLookup) {\n      output = lookup.toHash(this.outputLookup, output);\n    }\n    return output;\n  }\n\n  runInput(input) {\n    this.layers[0].predict(input);\n    for (let i = 1; i < this.layers.length; i++) {\n      this.layers[i].predict();\n    }\n    return this.layers[this.layers.length - 1].outputs;\n  }\n\n  calculateDeltas() {\n    for (let i = this.layers.length - 1; i > -1; i--) {\n      const previousLayer = this.layers[i - 1];\n      const nextLayer = this.layers[i + 1];\n      this.layers[i].compare(previousLayer, nextLayer);\n    }\n  }\n\n  /**\n   *\n   * @param data\n   * @param _options\n   * @returns {{error: number, iterations: number}}\n   */\n  train(data, _options = {}) {\n    const options = Object.assign({}, FeedForward.trainDefaults, _options);\n    data = this.formatData(data);\n    let iterations = options.iterations;\n    let errorThresh = options.errorThresh;\n    let log = options.log === true ? console.log : options.log;\n    let logPeriod = options.logPeriod;\n    let learningRate = _options.learningRate || this.learningRate || options.learningRate;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod;\n    if (!options.reinforce) {\n      this.initialize();\n    }\n\n    let error = 1;\n    let i;\n    for (i = 0; i < iterations && error > errorThresh; i++) {\n      let sum = 0;\n      for (let j = 0; j < data.length; j++) {\n        let err = this.trainPattern(data[j].input, data[j].output, learningRate);\n        sum += err;\n      }\n      error = sum / data.length;\n\n      if (log && (i % logPeriod === 0)) {\n        log('iterations:', i, 'training error:', error);\n      }\n      if (callback && (i % callbackPeriod === 0)) {\n        callback({ error: error, iterations: i });\n      }\n    }\n\n    return {\n      error: error,\n      iterations: i\n    };\n  }\n\n  /**\n   *\n   * @param input\n   * @param target\n   * @param learningRate\n   */\n  trainPattern(input, target, learningRate) {\n    learningRate = learningRate || this.learningRate;\n\n    // forward propagate\n    this.runInput(input);\n\n    // back propagate\n    this.calculateDeltas(target);\n    this.adjustWeights(learningRate);\n\n    let error = mse(this.outputLayer.errors.toArray());\n    return error;\n  }\n\n  /**\n   *\n   * @param learningRate\n   */\n  adjustWeights(learningRate) {\n    for (let i = 0; i < this.layers.length; i++) {\n      this.layers[i].learn(learningRate);\n    }\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {*}\n   */\n  formatData(data) {\n    if (data.constructor !== Array) { // turn stream datum into array\n      let tmp = [];\n      tmp.push(data);\n      data = tmp;\n    }\n    // turn sparse hash input into arrays with 0s as filler\n    let datum = data[0].input;\n    if (datum.constructor !== Array && !(datum instanceof Float64Array)) {\n      if (!this.inputLookup) {\n        this.inputLookup = lookup.buildLookup(data.map(value => value['input']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.inputLookup, datum.input);\n        return Object.assign({}, datum, { input: array });\n      }, this);\n    }\n\n    if (data[0].output.constructor !== Array) {\n      if (!this.outputLookup) {\n        this.outputLookup = lookup.buildLookup(data.map(value => value['output']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.outputLookup, datum.output);\n        return Object.assign({}, datum, { output: array });\n      }, this);\n    }\n    return data;\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    data = this.formatData(data);\n\n    // for binary classification problems with one output node\n    let isBinary = data[0].output.length === 1;\n    let falsePos = 0;\n    let falseNeg = 0;\n    let truePos = 0;\n    let trueNeg = 0;\n\n    // for classification problems\n    let misclasses = [];\n\n    // run each pattern through the trained network and collect\n    // error and misclassification statistics\n    let sum = 0;\n    for (let i = 0; i < data.length; i++) {\n      let output = this.runInput(data[i].input);\n      let target = data[i].output;\n\n      let actual, expected;\n      if (isBinary) {\n        actual = output[0] > this.binaryThresh ? 1 : 0;\n        expected = target[0];\n      }\n      else {\n        actual = output.indexOf(max(output));\n        expected = target.indexOf(max(target));\n      }\n\n      if (actual !== expected) {\n        let misclass = data[i];\n        Object.assign(misclass, {\n          actual: actual,\n          expected: expected\n        });\n        misclasses.push(misclass);\n      }\n\n      if (isBinary) {\n        if (actual === 0 && expected === 0) {\n          trueNeg++;\n        } else if (actual === 1 && expected === 1) {\n          truePos++;\n        } else if (actual === 0 && expected === 1) {\n          falseNeg++;\n        } else if (actual === 1 && expected === 0) {\n          falsePos++;\n        }\n      }\n\n      let errors = output.map((value, i) => {\n        return target[i] - value;\n      });\n      sum += mse(errors);\n    }\n    let error = sum / data.length;\n\n    let stats = {\n      error: error,\n      misclasses: misclasses\n    };\n\n    if (isBinary) {\n      Object.assign(stats, {\n        trueNeg: trueNeg,\n        truePos: truePos,\n        falseNeg: falseNeg,\n        falsePos: falsePos,\n        total: data.length,\n        precision: truePos / (truePos + falsePos),\n        recall: truePos / (truePos + falseNeg),\n        accuracy: (trueNeg + truePos) / data.length\n      });\n    }\n    return stats;\n  }\n\n  /**\n   *\n   */\n  toJSON() {\n    const jsonLayers = [];\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      const jsonLayer = {};\n      const jsonKeys = Object.keys(layer.constructor.defaults);\n      for (let keyIndex = 0; keyIndex < jsonKeys.length; keyIndex++) {\n        const key = jsonKeys[keyIndex];\n        jsonLayer[key] = layer[key];\n      }\n      jsonLayer.type = layer.constructor.name;\n      if (layer.inputLayer) {\n        jsonLayer.inputLayerIndex = this.layers.indexOf(layer.inputLayer);\n      } else if (layer.inputLayers) {\n        jsonLayer.inputLayerIndexes = layer.inputLayers.map((inputLayer) => this.layers.indexOf(inputLayer));\n      }\n      jsonLayers.push(jsonLayer);\n    }\n    const json = {\n      layers: jsonLayers\n    };\n    return json;\n  }\n\n  /**\n   *\n   * @param json\n   * @param [getLayer]\n   * @returns {FeedForward}\n   */\n  static fromJSON(json, getLayer) {\n    const jsonLayers = json.layers;\n    const layers = [];\n    const inputLayer = layerFromJSON(jsonLayers[0]) || getLayer(jsonLayers[0]);\n    layers.push(inputLayer);\n    for (let i = 1; i < jsonLayers.length; i++) {\n      const jsonLayer = jsonLayers[i];\n      if (jsonLayer.hasOwnProperty('inputLayerIndex')) {\n        const inputLayer = layers[jsonLayer.inputLayerIndex];\n        layers.push(layerFromJSON(jsonLayer, inputLayer) || getLayer(jsonLayer, inputLayer));\n      } else if (jsonLayer.hasOwnProperty('inputLayerIndexes')) {\n        const inputLayers = jsonLayer.inputLayerIndexes.map((inputLayerIndex) => layers[inputLayerIndex]);\n        layers.push(layerFromJSON(jsonLayer, inputLayers) || getLayer(jsonLayer, inputLayers));\n      }\n    }\n\n    const net = new FeedForward(json);\n    net.layers = layers;\n    return net;\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   * This will create a TrainStream (WriteStream) for us to send the training data to.\n   * @param opts training options\n   * @returns {TrainStream|*}\n   */\n  createTrainStream(opts) {\n    throw new Error('not yet implemented');\n  }\n}\n\nFeedForward.trainDefaults = {\n  iterations: 20000,\n  errorThresh: 0.005,\n  log: false,\n  logPeriod: 10,\n  learningRate: 0.3,\n  callback: null,\n  callbackPeriod: 10,\n  reinforce: false\n};\n\nFeedForward.defaults = {\n  learningRate: 0.3,\n  momentum: 0.1,\n  binaryThresh: 0.5,\n  hiddenLayers: null,\n  inputLayer: null,\n  outputLayer: null\n};"]}